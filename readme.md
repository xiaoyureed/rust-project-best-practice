> ç”±äºä¼šä¸æ–­å¢æ·»å†…å®¹, æ”¾åœ¨å•ç‹¬ä»“åº“ç»´æŠ¤æœ‰ç‚¹éº»çƒ¦, æœ€æ–°ç‰ˆæ¬åˆ°äº† ğŸ‘‰ğŸ»[è¿™é‡Œ](https://xiaoyureed.github.io/docs/rust-note/)

<!-- TOC -->

- [ç®€å•ä»‹ç»](#ç®€å•ä»‹ç»)
    - [ä½¿ç”¨åœºæ™¯](#ä½¿ç”¨åœºæ™¯)
    - [ç‰¹æ€§](#ç‰¹æ€§)
    - [è¯­ä¹‰ æ¦‚å¿µ](#è¯­ä¹‰-æ¦‚å¿µ)
- [å¼€å‘ç¯å¢ƒé…ç½®](#å¼€å‘ç¯å¢ƒé…ç½®)
    - [install](#install)
    - [å‘½ä»¤è¡Œå·¥å…·ä½¿ç”¨](#å‘½ä»¤è¡Œå·¥å…·ä½¿ç”¨)
    - [IDE](#ide)
    - [é…ç½®å›½å†…é•œåƒ](#é…ç½®å›½å†…é•œåƒ)
- [æ ‡å‡†åº“](#æ ‡å‡†åº“)
    - [path è·¯å¾„](#path-è·¯å¾„)
    - [æ—¶é—´](#æ—¶é—´)
- [2015 å¯¹æ¯” 2018](#2015-å¯¹æ¯”-2018)
    - [nll](#nll)
    - [Raw identifier](#raw-identifier)
    - [ç®€åŒ–æ¨¡å¼åŒ¹é…](#ç®€åŒ–æ¨¡å¼åŒ¹é…)
    - [main å‡½æ•°å¯ä»¥è¿”å› Result](#main-å‡½æ•°å¯ä»¥è¿”å›-result)
    - [impl trait æŠ½è±¡ç±»å‹](#impl-trait-æŠ½è±¡ç±»å‹)
- [è¯­æ³•](#è¯­æ³•)
    - [æ³¨é‡Š](#æ³¨é‡Š)
    - [å˜é‡èµ‹å€¼](#å˜é‡èµ‹å€¼)
        - [é»˜è®¤æ˜¯ä¸å¯å˜çš„](#é»˜è®¤æ˜¯ä¸å¯å˜çš„)
        - [å­—é¢é‡](#å­—é¢é‡)
    - [åŸºæœ¬æ•°æ®ç±»å‹](#åŸºæœ¬æ•°æ®ç±»å‹)
        - [å€¼ç±»å‹ and å¼•ç”¨ç±»å‹](#å€¼ç±»å‹-and-å¼•ç”¨ç±»å‹)
        - [å¸¸é‡ é™æ€å˜é‡](#å¸¸é‡-é™æ€å˜é‡)
        - [æ•°å­—](#æ•°å­—)
        - [å¸ƒå°”å€¼ å­—ç¬¦ å­—èŠ‚](#å¸ƒå°”å€¼-å­—ç¬¦-å­—èŠ‚)
        - [æ•°ç»„](#æ•°ç»„)
        - [Range èŒƒå›´](#range-èŒƒå›´)
        - [åˆ‡ç‰‡](#åˆ‡ç‰‡)
        - [str å­—ç¬¦ä¸²åˆ‡ç‰‡](#str-å­—ç¬¦ä¸²åˆ‡ç‰‡)
        - [åŸç”ŸæŒ‡é’ˆ raw pointer](#åŸç”ŸæŒ‡é’ˆ-raw-pointer)
        - [never ç±»å‹ æ„Ÿå¹å·](#never-ç±»å‹-æ„Ÿå¹å·)
    - [å­—ç¬¦ä¸²](#å­—ç¬¦ä¸²)
        - [å‡ ç§å­—ç¬¦ä¸²åŒºåˆ«](#å‡ ç§å­—ç¬¦ä¸²åŒºåˆ«)
        - [å¸¸ç”¨æ–¹æ³•](#å¸¸ç”¨æ–¹æ³•)
        - [å­—ç¬¦ä¸²è½¬æ¢](#å­—ç¬¦ä¸²è½¬æ¢)
        - [æ ¼å¼åŒ–](#æ ¼å¼åŒ–)
        - [è°ƒè¯•æ‰“å°å¤åˆç±»å‹ Debug Display](#è°ƒè¯•æ‰“å°å¤åˆç±»å‹-debug-display)
        - [é—®å·æ“ä½œç¬¦ å¤šæ¬¡å†™](#é—®å·æ“ä½œç¬¦-å¤šæ¬¡å†™)
    - [é›†åˆ](#é›†åˆ)
        - [Vec åŠ¨æ€æ•°ç»„](#vec-åŠ¨æ€æ•°ç»„)
        - [åŒç«¯é˜Ÿåˆ— VecDeque](#åŒç«¯é˜Ÿåˆ—-vecdeque)
        - [é“¾è¡¨ Linkedlist](#é“¾è¡¨-linkedlist)
        - [hashmap æ— åºå“ˆå¸Œè¡¨](#hashmap-æ— åºå“ˆå¸Œè¡¨)
            - [å“ˆå¸Œè¡¨åŸºæœ¬ä½¿ç”¨](#å“ˆå¸Œè¡¨åŸºæœ¬ä½¿ç”¨)
            - [å¤åˆç±»å‹ä½œä¸º key](#å¤åˆç±»å‹ä½œä¸º-key)
            - [å“ˆå¸Œç¢°æ’æ”»å‡»](#å“ˆå¸Œç¢°æ’æ”»å‡»)
        - [BTreeMap æœ‰åºå“ˆå¸Œè¡¨](#btreemap-æœ‰åºå“ˆå¸Œè¡¨)
        - [hashset æ— åºé›†åˆ](#hashset-æ— åºé›†åˆ)
        - [BTreeSet æœ‰åºé›†åˆ](#btreeset-æœ‰åºé›†åˆ)
        - [ä¼˜å…ˆé˜Ÿåˆ— BinaryHeap](#ä¼˜å…ˆé˜Ÿåˆ—-binaryheap)
    - [ç±»å‹è½¬æ¢](#ç±»å‹è½¬æ¢)
        - [åŸºæœ¬çš„ç±»å‹è½¬æ¢](#åŸºæœ¬çš„ç±»å‹è½¬æ¢)
        - [è½¬æ¢ç›¸å…³çš„ trait](#è½¬æ¢ç›¸å…³çš„-trait)
    - [æ‰€æœ‰æƒ](#æ‰€æœ‰æƒ)
        - [ä¸ºä»€ä¹ˆéœ€è¦æ‰€æœ‰æƒ RAIIæœºåˆ¶](#ä¸ºä»€ä¹ˆéœ€è¦æ‰€æœ‰æƒ-raiiæœºåˆ¶)
        - [åŸºæœ¬åŸåˆ™](#åŸºæœ¬åŸåˆ™)
        - [å­—ç¬¦ä¸²èµ‹å€¼çš„æ‰€æœ‰æƒ](#å­—ç¬¦ä¸²èµ‹å€¼çš„æ‰€æœ‰æƒ)
        - [å‡½æ•°å‚æ•°çš„æ‰€æœ‰æƒ](#å‡½æ•°å‚æ•°çš„æ‰€æœ‰æƒ)
        - [å‡½æ•°è¿”å›å€¼æ‰€æœ‰æƒ](#å‡½æ•°è¿”å›å€¼æ‰€æœ‰æƒ)
        - [å¤åˆç±»å‹ä¸­çš„æ‰€æœ‰æƒ](#å¤åˆç±»å‹ä¸­çš„æ‰€æœ‰æƒ)
        - [å¤šæ‰€æœ‰æƒ](#å¤šæ‰€æœ‰æƒ)
    - [ç”Ÿå‘½å‘¨æœŸå‚æ•°](#ç”Ÿå‘½å‘¨æœŸå‚æ•°)
        - [ä»€ä¹ˆæ˜¯ç”Ÿå‘½å‘¨æœŸ](#ä»€ä¹ˆæ˜¯ç”Ÿå‘½å‘¨æœŸ)
        - [ä¸ºä»€ä¹ˆå­˜åœ¨ç”Ÿå‘½å‘¨æœŸæ³¨é‡Š](#ä¸ºä»€ä¹ˆå­˜åœ¨ç”Ÿå‘½å‘¨æœŸæ³¨é‡Š)
        - [å‡½æ•°ä¸­çš„ç”Ÿå‘½å‘¨æœŸå‚æ•°](#å‡½æ•°ä¸­çš„ç”Ÿå‘½å‘¨æœŸå‚æ•°)
        - [ç»“æ„ä½“ä¸­ç”Ÿå‘½å‘¨æœŸ çœç•¥çš„è§„åˆ™](#ç»“æ„ä½“ä¸­ç”Ÿå‘½å‘¨æœŸ-çœç•¥çš„è§„åˆ™)
        - [é™æ€ç”Ÿå‘½å‘¨æœŸæ³¨é‡Š](#é™æ€ç”Ÿå‘½å‘¨æœŸæ³¨é‡Š)
        - [ç”Ÿå‘½å‘¨æœŸçº¦æŸ](#ç”Ÿå‘½å‘¨æœŸçº¦æŸ)
    - [å¼•ç”¨](#å¼•ç”¨)
        - [å¼•ç”¨åŸºæœ¬ä»‹ç»](#å¼•ç”¨åŸºæœ¬ä»‹ç»)
        - [ä¸å¯å˜å¼•ç”¨](#ä¸å¯å˜å¼•ç”¨)
        - [å¯å˜å¼•ç”¨](#å¯å˜å¼•ç”¨)
        - [å‚æ‚¬å¼•ç”¨é—®é¢˜ï¼ˆDangling References)](#å‚æ‚¬å¼•ç”¨é—®é¢˜dangling-references)
    - [è£¸æŒ‡é’ˆ](#è£¸æŒ‡é’ˆ)
    - [æ™ºèƒ½æŒ‡é’ˆ](#æ™ºèƒ½æŒ‡é’ˆ)
        - [æ™ºèƒ½æŒ‡é’ˆä»‹ç»](#æ™ºèƒ½æŒ‡é’ˆä»‹ç»)
        - [RAIIæœºåˆ¶ å®ç°å†…å­˜å›æ”¶](#raiiæœºåˆ¶-å®ç°å†…å­˜å›æ”¶)
        - [è‡ªå®šä¹‰æ™ºèƒ½æŒ‡é’ˆ](#è‡ªå®šä¹‰æ™ºèƒ½æŒ‡é’ˆ)
        - [Box æ— ç—›ä½¿ç”¨å †å†…å­˜](#box-æ— ç—›ä½¿ç”¨å †å†…å­˜)
            - [BoxåŸºæœ¬ä½¿ç”¨](#boxåŸºæœ¬ä½¿ç”¨)
            - [åŒ…è£…åŠ¨æ€å¤§å°ç±»å‹](#åŒ…è£…åŠ¨æ€å¤§å°ç±»å‹)
        - [Rc å’Œ Weak å…±äº«å †å†…å­˜](#rc-å’Œ-weak-å…±äº«å †å†…å­˜)
            - [Rc å¼ºå¼•ç”¨](#rc-å¼ºå¼•ç”¨)
            - [Weak å¼±å¼•ç”¨](#weak-å¼±å¼•ç”¨)
        - [RefCell å’Œ Cell æä¾›å†…éƒ¨å¯å˜æ€§](#refcell-å’Œ-cell-æä¾›å†…éƒ¨å¯å˜æ€§)
            - [Cell](#cell)
            - [RefCell](#refcell)
        - [Rc Box RefCell Cell å‡ ç§æŒ‡é’ˆçš„åŒºåˆ«å¯¹æ¯”](#rc-box-refcell-cell-å‡ ç§æŒ‡é’ˆçš„åŒºåˆ«å¯¹æ¯”)
        - [Pin å’Œ Unpin](#pin-å’Œ-unpin)
        - [Cow å†™æ—¶å¤åˆ¶](#cow-å†™æ—¶å¤åˆ¶)
    - [å‡½æ•°](#å‡½æ•°)
        - [å‡½æ•°åŸºæœ¬è¯­æ³•](#å‡½æ•°åŸºæœ¬è¯­æ³•)
        - [å‡½æ•°ä½“è¡¨è¾¾å¼](#å‡½æ•°ä½“è¡¨è¾¾å¼)
        - [å‡½æ•°ä½œä¸ºå‚æ•°](#å‡½æ•°ä½œä¸ºå‚æ•°)
        - [Result è¿”å›å€¼](#result-è¿”å›å€¼)
        - [ç¼–è¯‘æœŸå‡½æ•°æ‰§è¡Œ cfe](#ç¼–è¯‘æœŸå‡½æ•°æ‰§è¡Œ-cfe)
        - [å‘æ•£å‡½æ•°](#å‘æ•£å‡½æ•°)
        - [æ³›å‹å‡½æ•°](#æ³›å‹å‡½æ•°)
        - [é«˜é˜¶å‡½æ•°](#é«˜é˜¶å‡½æ•°)
            - [å‡½æ•°æŒ‡é’ˆ](#å‡½æ•°æŒ‡é’ˆ)
            - [ç¦æ­¢å‡½æ•°æ•è·å¤–éƒ¨ç¯å¢ƒä¸­å˜é‡](#ç¦æ­¢å‡½æ•°æ•è·å¤–éƒ¨ç¯å¢ƒä¸­å˜é‡)
    - [é—­åŒ…](#é—­åŒ…)
        - [é—­åŒ…åŸºæœ¬ä½¿ç”¨](#é—­åŒ…åŸºæœ¬ä½¿ç”¨)
        - [rust å®ç°é—­åŒ…çš„åŸç†](#rust-å®ç°é—­åŒ…çš„åŸç†)
        - [æ•è·ç¯å¢ƒå˜é‡ and ä¸‰ç§é—­åŒ…ç±»å‹](#æ•è·ç¯å¢ƒå˜é‡-and-ä¸‰ç§é—­åŒ…ç±»å‹)
        - [é—­åŒ…ä½œä¸ºè¿”å›å€¼ or å‚æ•°](#é—­åŒ…ä½œä¸ºè¿”å›å€¼-or-å‚æ•°)
            - [é€ƒé€¸é—­åŒ… éé€ƒé€¸é—­åŒ…](#é€ƒé€¸é—­åŒ…-éé€ƒé€¸é—­åŒ…)
            - [é—­åŒ…ä½œä¸ºå‚æ•°](#é—­åŒ…ä½œä¸ºå‚æ•°)
            - [é—­åŒ…ä½œä¸ºè¿”å›å€¼](#é—­åŒ…ä½œä¸ºè¿”å›å€¼)
            - [é—­åŒ…å‚æ•°ä¸­çš„ç”Ÿå‘½å‘¨æœŸ](#é—­åŒ…å‚æ•°ä¸­çš„ç”Ÿå‘½å‘¨æœŸ)
        - [è¿­ä»£å™¨](#è¿­ä»£å™¨)
            - [ä»€ä¹ˆæ˜¯è¿­ä»£å™¨](#ä»€ä¹ˆæ˜¯è¿­ä»£å™¨)
            - [Iterator trait](#iterator-trait)
            - [è¿­ä»£å™¨é€‚é…å™¨ æ”¶é›†å™¨ å‡½æ•°å¼é£æ ¼](#è¿­ä»£å™¨é€‚é…å™¨-æ”¶é›†å™¨-å‡½æ•°å¼é£æ ¼)
            - [è‡ªå®šä¹‰è¿­ä»£å™¨](#è‡ªå®šä¹‰è¿­ä»£å™¨)
            - [è‡ªå®šä¹‰é€‚é…å™¨ æ”¶é›†å™¨](#è‡ªå®šä¹‰é€‚é…å™¨-æ”¶é›†å™¨)
    - [æ¡ä»¶å¾ªç¯](#æ¡ä»¶å¾ªç¯)
    - [æ³›å‹](#æ³›å‹)
        - [å•æ€åŒ–](#å•æ€åŒ–)
        - [å¤šé‡çº¦æŸ åŠ å·](#å¤šé‡çº¦æŸ-åŠ å·)
        - [é»˜è®¤æ³›å‹å‚æ•° and å…³è”ç±»å‹](#é»˜è®¤æ³›å‹å‚æ•°-and-å…³è”ç±»å‹)
        - [ç©ºçº¦æŸ](#ç©ºçº¦æŸ)
        - [turbofish æ“ä½œç¬¦ and è¿”å›å€¼è‡ªåŠ¨æ¨å¯¼](#turbofish-æ“ä½œç¬¦-and-è¿”å›å€¼è‡ªåŠ¨æ¨å¯¼)
    - [trait](#trait)
        - [trait åŸºæœ¬ä½¿ç”¨](#trait-åŸºæœ¬ä½¿ç”¨)
        - [å­¤å„¿è§„åˆ™](#å­¤å„¿è§„åˆ™)
        - [ç‰¹åŒ– Specialization](#ç‰¹åŒ–-specialization)
        - [trait ä½œä¸ºå‚æ•° éœ€è¦ impl å‰ç¼€](#trait-ä½œä¸ºå‚æ•°-éœ€è¦-impl-å‰ç¼€)
        - [trait ä½œä¸º è¿”å›å€¼ è¿”å›åŠ¨æ€ç±»å‹](#trait-ä½œä¸º-è¿”å›å€¼-è¿”å›åŠ¨æ€ç±»å‹)
        - [æ´¾ç”Ÿ trait å’Œ è‡ªåŠ¨æ¨å¯¼ traitå®ç°](#æ´¾ç”Ÿ-trait-å’Œ-è‡ªåŠ¨æ¨å¯¼-traitå®ç°)
        - [è¿ç®—ç¬¦é‡è½½](#è¿ç®—ç¬¦é‡è½½)
        - [trait ç»§æ‰¿](#trait-ç»§æ‰¿)
        - [é™æ€åˆ†å‘ åŠ¨æ€åˆ†å‘](#é™æ€åˆ†å‘-åŠ¨æ€åˆ†å‘)
        - [æŠ½è±¡ç±»å‹](#æŠ½è±¡ç±»å‹)
            - [traitå¯¹è±¡](#traitå¯¹è±¡)
            - [traitå¯¹è±¡å®‰å…¨é—®é¢˜ Sized trait](#traitå¯¹è±¡å®‰å…¨é—®é¢˜-sized-trait)
            - [impl trait](#impl-trait)
        - [traitçš„ç±»å‹è½¬æ¢](#traitçš„ç±»å‹è½¬æ¢)
        - [From trait Into trait](#from-trait-into-trait)
        - [DerefMutå’Œ Deref](#derefmutå’Œ-deref)
        - [AsRef trait AsMut trait](#asref-trait-asmut-trait)
        - [Borrow trait](#borrow-trait)
        - [Debug trait](#debug-trait)
        - [Drop trait èµ„æºé‡Šæ”¾](#drop-trait-èµ„æºé‡Šæ”¾)
        - [Clone trait](#clone-trait)
        - [æ ‡ç­¾ trait](#æ ‡ç­¾-trait)
            - [Send trait å’Œ Sync trait](#send-trait-å’Œ-sync-trait)
            - [Copy trait](#copy-trait)
            - [Sized trait  å’Œ Unsized trait å’Œ åŠ¨æ€ç±»å‹](#sized-trait--å’Œ-unsized-trait-å’Œ-åŠ¨æ€ç±»å‹)
        - [Default trait](#default-trait)
        - [Extend trait](#extend-trait)
        - [Any trait](#any-trait)
        - [å’Œæ¯”è¾ƒæ’åºç›¸å…³çš„trait](#å’Œæ¯”è¾ƒæ’åºç›¸å…³çš„trait)
    - [å…ƒç»„](#å…ƒç»„)
    - [ç»“æ„ä½“](#ç»“æ„ä½“)
        - [ç»“æ„ä½“åŸºæœ¬ä½¿ç”¨](#ç»“æ„ä½“åŸºæœ¬ä½¿ç”¨)
        - [å…ƒç»„ç»“æ„ä½“ and å•å…ƒç»“æ„ä½“](#å…ƒç»„ç»“æ„ä½“-and-å•å…ƒç»“æ„ä½“)
        - [ç»“æ„ä½“æ–¹æ³•](#ç»“æ„ä½“æ–¹æ³•)
        - [new type æ¨¡å¼ å’Œ ç±»å‹åˆ«å Selfåˆ«å](#new-type-æ¨¡å¼-å’Œ-ç±»å‹åˆ«å-selfåˆ«å)
        - [æ¡ˆä¾‹ å½©è‰²å‘½ä»¤è¡Œè¾“å‡º](#æ¡ˆä¾‹-å½©è‰²å‘½ä»¤è¡Œè¾“å‡º)
    - [æšä¸¾](#æšä¸¾)
        - [æšä¸¾åŸºæœ¬ä½¿ç”¨](#æšä¸¾åŸºæœ¬ä½¿ç”¨)
        - [Option](#option)
        - [c é£æ ¼çš„æšä¸¾](#c-é£æ ¼çš„æšä¸¾)
        - [æ¡ˆä¾‹ å½©è‰²å‘½ä»¤è¡Œè¾“å‡ºä¼˜åŒ–](#æ¡ˆä¾‹-å½©è‰²å‘½ä»¤è¡Œè¾“å‡ºä¼˜åŒ–)
        - [å®ä¾‹ åˆ›å»ºé“¾è¡¨](#å®ä¾‹-åˆ›å»ºé“¾è¡¨)
    - [match æ¨¡å¼åŒ¹é…](#match-æ¨¡å¼åŒ¹é…)
        - [æ¨¡å¼åŒ¹é…ç®€å•ä½¿ç”¨](#æ¨¡å¼åŒ¹é…ç®€å•ä½¿ç”¨)
        - [if lef while let è¯­æ³•ç³–](#if-lef-while-let-è¯­æ³•ç³–)
    - [é”™è¯¯å¤„ç†](#é”™è¯¯å¤„ç†)
        - [æ–­è¨€](#æ–­è¨€)
        - [panic å’Œ Abort](#panic-å’Œ-abort)
        - [Result  å’Œ é—®å·æ“ä½œç¬¦](#result--å’Œ-é—®å·æ“ä½œç¬¦)
        - [é”™è¯¯è£…ç®± è‡ªå®šä¹‰å¼‚å¸¸](#é”™è¯¯è£…ç®±-è‡ªå®šä¹‰å¼‚å¸¸)
        - [æ•è·å¼‚å¸¸](#æ•è·å¼‚å¸¸)
        - [é”™è¯¯å¤„ç†è¿›åŒ–è¿‡ç¨‹](#é”™è¯¯å¤„ç†è¿›åŒ–è¿‡ç¨‹)
        - [ç¬¬ä¸‰æ–¹åº“å¤„ç†å¼‚å¸¸](#ç¬¬ä¸‰æ–¹åº“å¤„ç†å¼‚å¸¸)
    - [io](#io)
        - [å‘½ä»¤è¡Œå‚æ•°](#å‘½ä»¤è¡Œå‚æ•°)
        - [æ–‡ä»¶ io](#æ–‡ä»¶-io)
    - [é¢å‘å¯¹è±¡ oop](#é¢å‘å¯¹è±¡-oop)
        - [å¯è§æ€§](#å¯è§æ€§)
        - [å¤šæ€](#å¤šæ€)
        - [å‘ä¸‹è½¬å‹](#å‘ä¸‹è½¬å‹)
        - [å„ç§selfåŒºåˆ†ä½¿ç”¨](#å„ç§selfåŒºåˆ†ä½¿ç”¨)
        - [è®¾è®¡æ¨¡å¼](#è®¾è®¡æ¨¡å¼)
            - [å»ºé€ è€…æ¨¡å¼](#å»ºé€ è€…æ¨¡å¼)
            - [è®¿é—®è€…æ¨¡å¼](#è®¿é—®è€…æ¨¡å¼)
            - [raiiæ¨¡å¼](#raiiæ¨¡å¼)
    - [å­è¿›ç¨‹](#å­è¿›ç¨‹)
    - [åå°„](#åå°„)
    - [å®](#å®)
        - [å®åŸºæœ¬ä»‹ç»](#å®åŸºæœ¬ä»‹ç»)
        - [å£°æ˜å®](#å£°æ˜å®)
            - [åˆ›å»ºå®](#åˆ›å»ºå®)
            - [é‡å¤å¾ªç¯åŒ¹é…](#é‡å¤å¾ªç¯åŒ¹é…)
            - [å®é™…æ¡ˆä¾‹](#å®é™…æ¡ˆä¾‹)
        - [å®è°ƒè¯•](#å®è°ƒè¯•)
        - [è¿‡ç¨‹å®](#è¿‡ç¨‹å®)
            - [è¿‡ç¨‹å®ä»‹ç»](#è¿‡ç¨‹å®ä»‹ç»)
            - [è‡ªå®šä¹‰å±æ€§å®](#è‡ªå®šä¹‰å±æ€§å®)
            - [å‡½æ•°è°ƒç”¨å®](#å‡½æ•°è°ƒç”¨å®)
            - [derive å®](#derive-å®)
        - [ä½¿ç”¨ç¬¬ä¸‰æ–¹åŒ…](#ä½¿ç”¨ç¬¬ä¸‰æ–¹åŒ…)
        - [ç¼–è¯‘å™¨æ’ä»¶](#ç¼–è¯‘å™¨æ’ä»¶)
- [unsafe å±è”½å†…å­˜å®‰å…¨æ£€æŸ¥](#unsafe-å±è”½å†…å­˜å®‰å…¨æ£€æŸ¥)
    - [unsafe åŸºæœ¬åœºæ™¯](#unsafe-åŸºæœ¬åœºæ™¯)
    - [äº¤å‰ç¼–è¯‘](#äº¤å‰ç¼–è¯‘)
    - [ffi å¤–éƒ¨å‡½æ•°æ¥å£](#ffi-å¤–éƒ¨å‡½æ•°æ¥å£)
        - [ffi åŸºæœ¬ä»‹ç»](#ffi-åŸºæœ¬ä»‹ç»)
        - [åœ¨ rust ä¸­è°ƒç”¨ C å‡½æ•°](#åœ¨-rust-ä¸­è°ƒç”¨-c-å‡½æ•°)
        - [åœ¨ rustè°ƒç”¨ cpp](#åœ¨-rustè°ƒç”¨-cpp)
        - [åœ¨ c ä¸­è°ƒç”¨ rust](#åœ¨-c-ä¸­è°ƒç”¨-rust)
- [å†…å­˜ç®¡ç†](#å†…å­˜ç®¡ç†)
    - [å † å’Œ æ ˆ](#å †-å’Œ-æ ˆ)
    - [å†…å­˜å¯¹é½](#å†…å­˜å¯¹é½)
    - [æ‰‹åŠ¨å †å†…å­˜åˆ†é…](#æ‰‹åŠ¨å †å†…å­˜åˆ†é…)
- [å·¥ç¨‹ç®¡ç† æ¨¡å—](#å·¥ç¨‹ç®¡ç†-æ¨¡å—)
    - [æ¦‚å¿µç®€å•è§£é‡Š](#æ¦‚å¿µç®€å•è§£é‡Š)
    - [ç¼–è¯‘å™¨ç‰ˆæœ¬ç®¡ç†](#ç¼–è¯‘å™¨ç‰ˆæœ¬ç®¡ç†)
    - [ä¸ºé¡¹ç›®å•ç‹¬æŒ‡å®šconfig é…ç½®](#ä¸ºé¡¹ç›®å•ç‹¬æŒ‡å®šconfig-é…ç½®)
    - [ä¾èµ–ç®¡ç† cargo](#ä¾èµ–ç®¡ç†-cargo)
        - [cargo åŸºæœ¬å‘½ä»¤](#cargo-åŸºæœ¬å‘½ä»¤)
        - [æ–‡ä»¶å¸ƒå±€ç»“æ„](#æ–‡ä»¶å¸ƒå±€ç»“æ„)
        - [Cargo.toml](#cargotoml)
        - [cargo.lock](#cargolock)
        - [workspace](#workspace)
        - [ä¾èµ–çš„ç‰ˆæœ¬å·è§„åˆ™](#ä¾èµ–çš„ç‰ˆæœ¬å·è§„åˆ™)
    - [build.rs](#buildrs)
    - [é¡¹ç›®ç®¡ç†æ¡ˆä¾‹](#é¡¹ç›®ç®¡ç†æ¡ˆä¾‹)
        - [å¯¼å‡ºè‡ªå®šä¹‰å®](#å¯¼å‡ºè‡ªå®šä¹‰å®)
        - [å¯¼å…¥è‡ªå®šä¹‰ crate](#å¯¼å…¥è‡ªå®šä¹‰-crate)
        - [æ‰§è¡Œå­ç›®å½•ä¸­çš„ module](#æ‰§è¡Œå­ç›®å½•ä¸­çš„-module)
        - [å¯¼å…¥è‡ªå®šä¹‰ module](#å¯¼å…¥è‡ªå®šä¹‰-module)
        - [å¯¼å…¥ç¬¬ä¸‰æ–¹ crate](#å¯¼å…¥ç¬¬ä¸‰æ–¹-crate)
- [å•å…ƒæµ‹è¯•](#å•å…ƒæµ‹è¯•)
- [äº¤å‰ç¼–è¯‘ and æ¡ä»¶ç¼–è¯‘](#äº¤å‰ç¼–è¯‘-and-æ¡ä»¶ç¼–è¯‘)
- [å¹¶å‘](#å¹¶å‘)
    - [é€šç”¨æ¦‚å¿µ](#é€šç”¨æ¦‚å¿µ)
        - [è¿›ç¨‹ and çº¿ç¨‹](#è¿›ç¨‹-and-çº¿ç¨‹)
        - [äº‹ä»¶å›è°ƒå®ç°çš„å¼‚æ­¥å¹¶å‘](#äº‹ä»¶å›è°ƒå®ç°çš„å¼‚æ­¥å¹¶å‘)
    - [çº¿ç¨‹åŸºæœ¬ä½¿ç”¨](#çº¿ç¨‹åŸºæœ¬ä½¿ç”¨)
        - [åˆ›å»ºçº¿ç¨‹](#åˆ›å»ºçº¿ç¨‹)
        - [è‡ªå®šä¹‰é…ç½®çº¿ç¨‹](#è‡ªå®šä¹‰é…ç½®çº¿ç¨‹)
        - [çº¿ç¨‹æœ¬åœ°å˜é‡](#çº¿ç¨‹æœ¬åœ°å˜é‡)
        - [æ‰‹åŠ¨é˜»å¡å”¤é†’](#æ‰‹åŠ¨é˜»å¡å”¤é†’)
    - [çº¿ç¨‹åŒæ­¥](#çº¿ç¨‹åŒæ­¥)
        - [é”™è¯¯ç¤ºä¾‹](#é”™è¯¯ç¤ºä¾‹)
        - [é”](#é”)
        - [åŸå­ç±»å‹](#åŸå­ç±»å‹)
        - [channel](#channel)
    - [å¤šçº¿ç¨‹å°ä¾‹å­](#å¤šçº¿ç¨‹å°ä¾‹å­)
        - [å®ç°çº¿ç¨‹æ± ](#å®ç°çº¿ç¨‹æ± )
        - [å®ç° map-reduce ç®—æ³•](#å®ç°-map-reduce-ç®—æ³•)
        - [å¤šçº¿ç¨‹ç»Ÿè®¡å’Œ](#å¤šçº¿ç¨‹ç»Ÿè®¡å’Œ)
        - [å¸¦çº¿ç¨‹æ± çš„ webserver](#å¸¦çº¿ç¨‹æ± çš„-webserver)
    - [rayon å¹¶è¡Œæ‰§è¡Œä»»åŠ¡](#rayon-å¹¶è¡Œæ‰§è¡Œä»»åŠ¡)
    - [CrossBeam æ— é”çš„æ•°æ®ç»“æ„](#crossbeam-æ— é”çš„æ•°æ®ç»“æ„)
    - [Arc å’Œ Rc](#arc-å’Œ-rc)
    - [RwLock å’Œ RefCell](#rwlock-å’Œ-refcell)
    - [Mutex](#mutex)
    - [AtomicPtr å’Œ Cell](#atomicptr-å’Œ-cell)
- [å¼‚æ­¥å¹¶å‘](#å¼‚æ­¥å¹¶å‘)
    - [å¼‚æ­¥æ¦‚å¿µ](#å¼‚æ­¥æ¦‚å¿µ)
        - [ä¸ºä»€ä¹ˆä½¿ç”¨å¼‚æ­¥](#ä¸ºä»€ä¹ˆä½¿ç”¨å¼‚æ­¥)
        - [æ™®é€šå¤šçº¿ç¨‹ webserver](#æ™®é€šå¤šçº¿ç¨‹-webserver)
        - [æ”¹è¿›åçš„å¼‚æ­¥ç‰ˆæœ¬](#æ”¹è¿›åçš„å¼‚æ­¥ç‰ˆæœ¬)
    - [åŸºæœ¬ä½¿ç”¨](#åŸºæœ¬ä½¿ç”¨)
        - [block_on](#block_on)
        - [await](#await)
        - [join](#join)
    - [futureå¹¶å‘æ¨¡å¼](#futureå¹¶å‘æ¨¡å¼)
        - [futureåº•å±‚æ˜¯ç”Ÿæˆå™¨](#futureåº•å±‚æ˜¯ç”Ÿæˆå™¨)
        - [futureåŸºæœ¬ä½¿ç”¨](#futureåŸºæœ¬ä½¿ç”¨)
        - [åŠ¨æ‰‹å®ç° Future ç±»å‹](#åŠ¨æ‰‹å®ç°-future-ç±»å‹)
        - [åŠ¨æ‰‹å®ç° å¼‚æ­¥ sleep](#åŠ¨æ‰‹å®ç°-å¼‚æ­¥-sleep)
    - [async-std](#async-std)
    - [tokio](#tokio)
- [ç®€å•æ–‡ä»¶ç³»ç»Ÿ](#ç®€å•æ–‡ä»¶ç³»ç»Ÿ)
- [ç½‘ç»œç¼–ç¨‹](#ç½‘ç»œç¼–ç¨‹)
    - [tcp](#tcp)
    - [udp](#udp)
- [æ¶ˆæ¯ä¸­é—´ä»¶](#æ¶ˆæ¯ä¸­é—´ä»¶)
- [æ¸¸æˆå¼€å‘](#æ¸¸æˆå¼€å‘)
- [çˆ¬è™«](#çˆ¬è™«)
- [rpc æ¡†æ¶](#rpc-æ¡†æ¶)
- [ç¼–å†™ä»£ç†](#ç¼–å†™ä»£ç†)
    - [http ä»£ç†](#http-ä»£ç†)
    - [socket ä»£ç†](#socket-ä»£ç†)
- [webassembly](#webassembly)
- [å’Œ Python äº¤äº’](#å’Œ-python-äº¤äº’)
- [å’Œ js JavaScript nodejs äº¤äº’](#å’Œ-js-javascript-nodejs-äº¤äº’)
- [å’Œ java äº¤äº’](#å’Œ-java-äº¤äº’)
    - [rust è°ƒç”¨ java](#rust-è°ƒç”¨-java)
    - [java è°ƒç”¨ rust](#java-è°ƒç”¨-rust)
- [å¼€å‘å¾®ä¿¡å°ç¨‹åº-web æ¸¸æˆ](#å¼€å‘å¾®ä¿¡å°ç¨‹åº-web-æ¸¸æˆ)
- [ç¬¬ä¸‰æ–¹ crates](#ç¬¬ä¸‰æ–¹-crates)
    - [æ¡Œé¢å¼€å‘](#æ¡Œé¢å¼€å‘)
    - [è§†é¢‘å¤„ç†](#è§†é¢‘å¤„ç†)
    - [å›¾ç‰‡å¤„ç†](#å›¾ç‰‡å¤„ç†)
    - [æ¸¸æˆå¼€å‘ä¸‰æ–¹åº“](#æ¸¸æˆå¼€å‘ä¸‰æ–¹åº“)
    - [web å¼€å‘](#web-å¼€å‘)
        - [webæ¡†æ¶](#webæ¡†æ¶)
        - [orm](#orm)
        - [http client](#http-client)
    - [åºåˆ—åŒ–ååºåˆ—åŒ–](#åºåˆ—åŒ–ååºåˆ—åŒ–)
        - [toml](#toml)
        - [json](#json)
    - [æ—¥å¿—ç³»ç»Ÿ](#æ—¥å¿—ç³»ç»Ÿ)
        - [env_logger](#env_logger)
        - [log4rs and log](#log4rs-and-log)
    - [æ–‡æœ¬è§£æå™¨](#æ–‡æœ¬è§£æå™¨)
    - [lazy static å»¶è¿Ÿåˆå§‹åŒ–](#lazy-static-å»¶è¿Ÿåˆå§‹åŒ–)
    - [ç”µå­ä¹¦](#ç”µå­ä¹¦)
    - [å‘½ä»¤è¡Œç¨‹åº](#å‘½ä»¤è¡Œç¨‹åº)
        - [structopt](#structopt)
        - [clap](#clap)
    - [å¼‚æ­¥ç¼–ç¨‹](#å¼‚æ­¥ç¼–ç¨‹)
    - [websocket](#websocket)
    - [ç¼©å°ä½“ç§¯](#ç¼©å°ä½“ç§¯)
    - [http client](#http-client-1)
    - [å®¹é”™è¿è¡Œæ—¶](#å®¹é”™è¿è¡Œæ—¶)
    - [åˆ†å‘å·¥å…·](#åˆ†å‘å·¥å…·)
    - [é”™è¯¯å¤„ç†](#é”™è¯¯å¤„ç†-1)
    - [å¹¶å‘ç¼–ç¨‹](#å¹¶å‘ç¼–ç¨‹)
    - [gui å›¾å½¢åº“](#gui-å›¾å½¢åº“)
    - [åº•å±‚ç½‘ç»œ api](#åº•å±‚ç½‘ç»œ-api)
    - [æ­£åˆ™](#æ­£åˆ™)
    - [éšæœº](#éšæœº)
        - [rand éšæœºæ•°å­—](#rand-éšæœºæ•°å­—)
    - [æœç´¢å¼•æ“](#æœç´¢å¼•æ“)
    - [æ¸¸æˆå¼•æ“](#æ¸¸æˆå¼•æ“)
    - [å¼€æºé›†åˆå®¹å™¨](#å¼€æºé›†åˆå®¹å™¨)
- [å¼€æºé¡¹ç›®](#å¼€æºé¡¹ç›®)
- [å‚è€ƒé“¾æ¥](#å‚è€ƒé“¾æ¥)

<!-- /TOC -->



# ç®€å•ä»‹ç»

## ä½¿ç”¨åœºæ™¯

ä¼ ç»Ÿå‘½ä»¤è¡Œç¨‹åº - Rust ç¼–è¯‘å™¨å¯ä»¥ç›´æ¥ç”Ÿæˆç›®æ ‡å¯æ‰§è¡Œç¨‹åºï¼Œä¸éœ€è¦ä»»ä½•è§£é‡Šç¨‹åºã€‚

Web åº”ç”¨ - Rust å¯ä»¥è¢«ç¼–è¯‘æˆ WebAssemblyï¼ŒWebAssembly æ˜¯ä¸€ç§ JavaScript çš„é«˜æ•ˆæ›¿ä»£å“ã€‚

ç½‘ç»œæœåŠ¡å™¨ - Rust ç”¨æä½çš„èµ„æºæ¶ˆè€—åšåˆ°å®‰å…¨é«˜æ•ˆï¼Œä¸”å…·å¤‡å¾ˆå¼ºçš„å¤§è§„æ¨¡å¹¶å‘å¤„ç†èƒ½åŠ›ï¼Œååˆ†é€‚åˆå¼€å‘æ™®é€šæˆ–æç«¯çš„æœåŠ¡å™¨ç¨‹åºã€‚

åµŒå…¥å¼è®¾å¤‡ - Rust åŒæ—¶å…·æœ‰JavaScript ä¸€èˆ¬çš„é«˜æ•ˆå¼€å‘è¯­æ³•å’Œ C è¯­è¨€çš„æ‰§è¡Œæ•ˆç‡ï¼Œæ”¯æŒåº•å±‚å¹³å°çš„å¼€å‘ã€‚

ç»¼ä¸Š, æ˜¯ cpp çš„æœ‰åŠ›ç«äº‰è€…


## ç‰¹æ€§

- Rust æ˜¯åŸºäº LLVM çš„è¯­è¨€

- æ‰€æœ‰æƒç³»ç»Ÿå‡ ä¹è§£å†³äº†é‡æŒ‡é’ˆ, å¼ºå¤§çš„ç±»å‹ç³»ç»Ÿ

- zero cost abstract (ç¼–è¯‘æœŸé—´å³å¯ç¼–è¯‘æˆæœºå™¨ç , è¿è¡Œæ—¶æ²¡æœ‰å¼€é”€), æ²¡æœ‰ runtime å’Œ gc, å’Œ c æ— ç¼äº¤äº’

- è‡ªå¸¦æµ‹è¯•, cargo å·¥å…·

https://opensource.com/article/20/5/rust-java ä¸ºä»€ä¹ˆjava -> rust


## è¯­ä¹‰ æ¦‚å¿µ

1. èŒƒå¼: é¢å‘å¯¹è±¡ , å‡½æ•°å¼
1. è¯­ä¹‰: æ‰€æœ‰æƒ, move, copy, å€Ÿç”¨, lifecycle, drop
1. ç±»å‹ç³»ç»Ÿ: æ³›å‹, trait, å¤šæ€, ç±»å‹æ¨æ–­
1. å†…å­˜ç®¡ç†: heap, stack, raii

1, 2, 3 ç‚¹æ¶‰åŠåˆ°å¼€å‘è€…çš„æ“ä½œ, 2,3,4 ç¼–è¯‘å™¨æ“ä½œ


# å¼€å‘ç¯å¢ƒé…ç½®

## install

git ç¯å¢ƒæ”¯æŒ

https://www.rust-lang.org/tools/install

ä¼šè‡ªåŠ¨å®‰è£… cargo

å®‰è£…å®Œæˆåé€€å‡ºå†æ¬¡è¿›å…¥ terminal, rustc ç­‰å‘½ä»¤è‡ªåŠ¨åŠ å…¥ path äº†

ç»™nightlyé€šé“ç”¨æˆ·çš„å°æç¤ºï¼šåœ¨æ›´æ–°rustä¹‹åä½¿ç”¨cargo-sweepæ¥å¸®åŠ©ä½ æ¸…ç†åƒåœ¾
å¯¹äºnightlyé€šé“çš„ç”¨æˆ·æ¥è¯´ï¼Œé€šå¸¸åœ¨ä½¿ç”¨è¿‡ç¨‹ä¸­ä¼šä¼´éšç€é¢‘ç¹çš„å‡çº§ä½ çš„rustç‰ˆæœ¬ï¼Œè€Œå¯¹äºæ—¥å¸¸ç»´æŠ¤çš„é¡¹ç›®ï¼Œå¦‚æœä½ å‡çº§äº†rustç‰ˆæœ¬ä¹‹åï¼Œtargetç¼–è¯‘æ–‡ä»¶å¤¹é‡Œé¢ä¼šç”Ÿæˆå¤šä¸ªç‰ˆæœ¬çš„ç¼–è¯‘æ–‡ä»¶ã€‚è¿™ä¸ªæ—¶å€™å°±æ˜¯ä½¿ç”¨cargo sweepçš„æ—¶å€™äº†ï¼Œå®ƒä¼šå¸®ä½ æ¸…ç†æ‰é™¤äº†å½“å‰ç‰ˆæœ¬ä»¥å¤–çš„targetç›®å½•ä¸‹å¤šä½™çš„æ–‡ä»¶ã€‚

ç”¨ä¾‹ï¼š cargo sweep -i -r -v ~/src

-i æ˜¯å¼€å¯ä¿ç•™~/srcç›®å½•ä¸‹targetæ–‡ä»¶å¤¹å†…å½“å‰ç”µè„‘ä¸Šå·²å®‰è£…rustç‰ˆæœ¬çš„ç¼–è¯‘æ–‡ä»¶ã€‚
-r æ˜¯å¼€å¯é€’å½’ï¼ˆrecursivelyï¼‰æœç´¢
-v æ˜¯å¼€å¯è¯¦ç»†ï¼ˆå•°å—¦æ¨¡å¼ï¼Œå¼€å¯ä¹‹åä¼šå‘Šè¯‰ä½ å®ƒå¹²äº†å•¥ã€‚ï¼‰
å¦‚æœä½ çš„ç”µè„‘ä¸Šæ²¡æœ‰cargo sweepï¼Œå¯ä»¥ç”¨ä»¥ä¸‹å‘½ä»¤å®‰è£…ï¼š cargo install cargo-sweep

Read More: https://www.reddit.com/r/rust/comments/jfdiao/tip_for_nightly_users_use_cargosweep_after/

## å‘½ä»¤è¡Œå·¥å…·ä½¿ç”¨


```sh
rustc --version
# ç¼–è¯‘å•ä¸ªæ–‡ä»¶, ç”Ÿæˆ xxx å¯æ‰§è¡Œæ–‡ä»¶
rustc <xxx.rs>
# ç¼–è¯‘ è¿è¡Œ dry.rs ä¸‹çš„ test mod, æ— éœ€ mainå‡½æ•°
rustc --test dry.rs && ./dry


# ç®¡ç† rust ç‰ˆæœ¬, 

rustup update

# rust æœ‰ stable (é»˜è®¤)ã€nightly ç‰ˆæœ¬ä¹‹åˆ†
rustup install nightly

# å½“å‰é¡¹ç›®ä¸‹ç”Ÿæ•ˆ
rustup override set nightly
rustup override set stable

# è®¾ç½®é»˜è®¤å€¼, å¯¹å…¨å±€æ‰€æœ‰é¡¹ç›®ç”Ÿæ•ˆ
rustup default stable
rustup default nightly
```


## IDE

1. VSCode + rust æ’ä»¶ + native debug æ’ä»¶ + TabNine æç¤ºæ’ä»¶ + better toml plugin [ + crates æ–¹ä¾¿åŒ…ç®¡ç†çš„æ’ä»¶]

1. vscode + rust-analyzer plugin + CodeLLDB plugin (debug) + even better toml plugin (better toml) æ ¼å¼åŒ– toml [+ crates]

1. clion/idea + rust æ’ä»¶ + toml æ’ä»¶ + NativeDebugæ’ä»¶



å…¶ä»–ä»£ç æç¤ºé…ç½®: (æ¨è vscode + æ’ä»¶, å°±æ— éœ€å¦‚ä¸‹çš„é…ç½®äº†)

```sh
# https://www.jianshu.com/p/c952db541d79
# ä»£ç æç¤º
cargo install racer
# å¦‚æœä¸æˆåŠŸ, å‡çº§åˆ° nightly
rustup install nightly
# å¦‚æœæŠ¥é”™ï¼Œåˆ™éœ€è¦åˆ‡æ¢åˆ°nightlyç‰ˆæœ¬çš„ç¼–è¯‘å™¨
# ç„¶åå†æ¬¡ å®‰è£… racer
rustup default nightly

# æˆ–è€… ç›´æ¥
cargo +nightly install racer

# ä»£ç åˆ†æ
rustup component add clippy

```


## é…ç½®å›½å†…é•œåƒ

https://www.cnblogs.com/dhcn/p/12100675.html


```t
[registry]
token = "xxx crate.io token" # æ³¨å†Œè´¦å·åç”±ç½‘ç«™é¢å‘, ç”¨äºå‘å¸ƒåŒ…
# æ”¾åˆ° `$HOME/.cargo/config` æ–‡ä»¶ä¸­
[source.crates-io]
registry = "https://github.com/rust-lang/crates.io-index"

# æ›¿æ¢æˆä½ åå¥½çš„é•œåƒæº
replace-with = 'rustcc'
#replace-with = 'ustc'

# æ¸…åå¤§å­¦
[source.tuna]
registry = "https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git"

# ä¸­å›½ç§‘å­¦æŠ€æœ¯å¤§å­¦
[source.ustc]
registry = "git://mirrors.ustc.edu.cn/crates.io-index"

# ä¸Šæµ·äº¤é€šå¤§å­¦
[source.sjtu]
registry = "https://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index"

# rustccç¤¾åŒº
[source.rustcc]
registry = "git://crates.rustcc.cn/crates.io-index"

# å‘½ä»¤åˆ«å
[alias]
b = "build"
t = "test"
r = "run"
rr = "run --release"
ben = "bench"
space_example = ["run", "--release", "--", "\"command list\""]
```




# æ ‡å‡†åº“



## path è·¯å¾„

```rust

/// è·¯å¾„
/// 
/// Path å¯ä» OsStr ç±»å‹åˆ›å»º
/// 
/// Path åˆ†ä¸ºä¸¤ç§ï¼šposix::Pathï¼Œé’ˆå¯¹ ç±» UNIX ç³»ç»Ÿï¼›ä»¥åŠ windows::Pathï¼Œé’ˆå¯¹ Windowsã€‚
/// prelude ä¼šé€‰æ‹©å¹¶è¾“å‡ºç¬¦åˆå¹³å°ç±»å‹ çš„ Path ç§ç±»ã€‚(prelude æ˜¯ Rust è‡ªåŠ¨åœ°åœ¨æ¯ä¸ªç¨‹åºä¸­å¯¼å…¥çš„ä¸€äº›é€šç”¨çš„ä¸œè¥¿)
/// 
/// Path åœ¨å†…éƒ¨å¹¶ä¸æ˜¯ç”¨ UTF-8 å­—ç¬¦ä¸²è¡¨ç¤ºçš„ï¼Œè€Œæ˜¯å­˜å‚¨ä¸ºè‹¥å¹²å­—èŠ‚ï¼ˆVec<u8>ï¼‰çš„ vectorã€‚
/// å› æ­¤ï¼Œå°† Path è½¬åŒ–æˆ &str å¹¶éé›¶å¼€é”€çš„ï¼ˆfreeï¼‰ï¼Œä¸”å¯èƒ½å¤±è´¥ï¼ˆå› æ­¤å®ƒ è¿”å›ä¸€ä¸ª Optionï¼‰
/// 
fn path_demo() {
    println!("-------------path_demo-------------");
    use std::path::Path;

    let path = Path::new(".");


    // è·¯å¾„æ˜¯å¦å­˜åœ¨
    Path::new("/etc/hosts").exists()
    // æˆ–è€…
    fs::metadata(path).is_ok()

    
    // `display` æ–¹æ³•è¿”å›ä¸€ä¸ªå¯æ˜¾ç¤ºï¼ˆshowableï¼‰çš„ç»“æ„ä½“
    let display = path.display();
    println!("path = {}", display);

    // `join` ä½¿ç”¨æ“ä½œç³»ç»Ÿç‰¹å®šçš„åˆ†éš”ç¬¦æ¥åˆå¹¶è·¯å¾„åˆ°ä¸€ä¸ªå­—èŠ‚å®¹å™¨ï¼Œå¹¶è¿”å›æ–°çš„è·¯å¾„
    let new_path = path.join("a").join("b");

    // å°†è·¯å¾„è½¬æ¢æˆä¸€ä¸ªå­—ç¬¦ä¸²åˆ‡ç‰‡
    match new_path.to_str() {
        None => panic!("new path is not a valid UTF-8 sequence"),
        Some(s) => println!("new path is {}", s),
    }


}
```


## æ—¶é—´


```rust

fn time_demo() {
    let start = SystemTime::now();
    for _ in 0..10000000 {
        let _a = "hello".to_string();
    }
    println!("{} ms", SystemTime::now().duration_since(start).unwrap().as_millis());
}



```

# 2015 å¯¹æ¯” 2018


## nll


```rust
// nll ç‰¹æ€§
// 2015 edition çš„å‘¨æœŸæ£€æŸ¥ä¼šè®¤ä¸º å˜é‡æœ‰æ•ˆç›´åˆ°ä½œç”¨åŸŸç»“æŸ
// 2018 edition ä¼šåˆ†æä»£ç , ç¡®è®¤å˜é‡åé¢ä¸ä¼šç”¨åˆ°, åˆ™æå‰é”€æ¯å˜é‡
{
    let mut x = 2;
    let y = &mut x;
    *y += 1; // 2018 edition åœ¨è¿™ä¸€æ­¥å, é”€æ¯ y
    println!("{}", x); // 2015 åˆ°è¿™ä¸€æ­¥æ‰é”€æ¯ y
}




// éè¯æ³•ä½œç”¨åŸŸç”Ÿå‘½å‘¨æœŸ (Non-Lexical Lifetime, NLL
fn foo<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() % 2 == 0 {
        x
    } else {
        y
    }
}
fn main(){
    let x = String::from("hello");
    //2015 ä¸­ error, 2018 å¼•å…¥äº† nll, ä¸æŠ¥é”™
    let z;
    let y = String::from("world");
    z = foo(&x, &y); // 2015 è®¤ä¸ºåˆ°è¿™é‡Œ y å·²ç»å¤±æ•ˆäº†, æ‰€ä»¥æŠ¥é”™, å®é™…è¿™ä¸ç¬¦åˆç›´è§‰
    println!("{:?}", z);
}

// nll æ— æ³•è§£å†³çš„é—®é¢˜
fn get_default<'r,K:Hash+Eq+Copy,V:Default>(map: &'r mut HashMap<K,V>,
                                            key: K)
                                            -> &'r mut V {
    match map.get_mut(&key) { // -------------+ 'r
        Some(value) => value,              // |
        None => {                          // |
            map.insert(key, V::default()); // |
            //  ^~~~~~ ERROR               // |
            map.get_mut(&key).unwrap()     // |
        }                                  // |
    }                                      // |
}  
// ä¿®æ­£å¦‚ä¸‹:
fn get_default2<'r,K:Hash+Eq+Copy,V:Default>(map: &'r mut HashMap<K,V>,
                                             key: K)
                                             -> &'r mut V {
    if map.contains_key(&key) {
    // ^~~~~~~~~~~~~~~~~~ 'n
        return match map.get_mut(&key) { // + 'r
            Some(value) => value,        // |
            None => unreachable!()       // |
        };                               // v
    }

    // At this point, `map.get_mut` was never
    // called! (As opposed to having been called,
    // but its result no longer being in use.)
    map.insert(key, V::default()); // OK now.
    map.get_mut(&key).unwrap()
}



```

## Raw identifier

```rs
// åˆ©ç”¨ Raw identifier å°†è¯­è¨€å…³é”®å­—ç”¨ä½œå‡½æ•°å (ä¸€èˆ¬ç”¨äº FFI ä¸­ï¼Œç”¨äºé¿å… C å‡½æ•°åå’Œ Rust çš„å…³é”®å­—æˆ–ä¿ç•™å­—é‡å)
fn r#match(needle : &str , haystack : &str) - > bool
```



## ç®€åŒ–æ¨¡å¼åŒ¹é…


```rs

// match æ¨¡å¼åŒ¹é…

fn main() {
    let o = &Some("h".to_owned());
    // 2015
    //  refä¹Ÿæ˜¯ä¸€ç§æ¨¡å¼åŒ¹é…ï¼Œæ˜¯ä¸ºäº† è§£æ„ &Some(ref s)ä¸­ s çš„å¼•ç”¨ï¼Œé¿å…å…¶ä¸­çš„ s è¢«è½¬ç§»æ‰€æœ‰æƒ ã€‚
    match o {
        &Some(ref v) => println!("{}", v),
        _ => (),
    }
    // 2018
    //ä¸ éœ€è¦å†ä½¿ç”¨å¼•ç”¨æ“ä½œç¬¦å’Œ refæ¥è¿›è¡Œè§£æ„äº†ã€‚åœ¨æ–°çš„ç‰ˆæœ¬ä¸­ ï¼Œ match åŒ¹é…ä¼šè‡ªåŠ¨å¤„ç†è¿™ç§æƒ…å†µ
    match o {
        Some(v) => println!("{}", v),
        _ => (),
    }

    
}

```

## main å‡½æ•°å¯ä»¥è¿”å› Result


```rs


// åœ¨ Rust 2015ç‰ˆæœ¬ä¸­ï¼Œ main å‡½æ•°å¹¶ä¸èƒ½è¿”å› Result<T E>ã€‚ä½†æ˜¯åœ¨å®é™…å¼€å‘ä¸­ï¼Œ äºŒè¿›åˆ¶ å¯æ‰§è¡Œåº“ä¹Ÿéœ€è¦è¿”å›é”™è¯¯ï¼Œ æ¯”å¦‚ï¼Œ è¯»å–æ–‡ä»¶çš„æ—¶å€™å‘ç”Ÿäº†é”™è¯¯ï¼Œ è¿™æ—¶éœ€è¦æ­£å¸¸é€€å‡ºç¨‹åºã€‚äº æ˜¯åœ¨ Rust 2018 ç‰ˆæœ¬ä¸­ï¼Œå…è®¸ main å‡½æ•°è¿”å› Result<T, E>äº†

```

## impl trait æŠ½è±¡ç±»å‹


```rs


// å¯ ä»¥é™æ€åˆ†å‘çš„æŠ½è±¡ç±»å‹ impl Trait





```

# è¯­æ³•

## æ³¨é‡Š

```rust
//! Hello Demo
//!   åŒ…æ³¨é‡Š
//! crate spec...

use std::io::Read;
use std::io;
use std::fmt;
use std::io::{stdout, BufWriter}; 
use std::fs::File;


///
///
/// main æ–¹æ³•çš„æ³¨é‡Š
///
/// ```
/// æ”¯æŒ md
/// ```
fn main() {
    println!("Hello, world!");

}



```




## å˜é‡èµ‹å€¼


### é»˜è®¤æ˜¯ä¸å¯å˜çš„


```rust


fn variables() {
    let a = 12;

    // äºŒæ¬¡èµ‹å€¼ä¸è¡Œ
    // ä¹Ÿå°±æ˜¯è¯´ a æ˜¯ä¸å¯å˜å˜é‡
    // a = 10;

    // ä½†æ˜¯èƒ½äºŒæ¬¡ç»‘å®š, é‡å½±/é®è”½ï¼ˆShadowingï¼‰
    // è¿™é‡Œçš„ a å’Œä¹‹å‰çš„ a æ²¡å…³ç³», ç”šè‡³ç±»å‹éƒ½èƒ½æ”¹å˜
    let a = 11;
    println!("a = {}", a);
    let a = "new a";
    println!("a = {}", a);

    // å¯å˜å˜é‡
    // èƒ½å¤Ÿè¢«äºŒæ¬¡èµ‹å€¼
    let mut b = 10;
    b = 33;
    println!("b = {}", b);
    // è¿™æ˜¯ä¸è¡Œçš„, å› ä¸º b å·²ç»è¢«ä½¿ç”¨è¿‡äº†
    // b = "bb";

    // æ‰‹åŠ¨æŒ‡å®šç±»å‹, æ— ç¬¦å· 64 ä½æ•´å‹å˜é‡
    // å¦‚æœæ²¡æœ‰å£°æ˜ç±»å‹ï¼Œi å°†è‡ªåŠ¨è¢«åˆ¤æ–­ä¸ºæœ‰ç¬¦å· 32 ä½æ•´å‹å˜é‡
    let i: u64 = 12;

    

}


```

### å­—é¢é‡

```rust
// å­—é¢é‡
    //
    // å¸¦åç¼€çš„å­—é¢é‡ï¼Œå…¶ç±»å‹åœ¨åˆå§‹åŒ–æ—¶å·²ç»çŸ¥é“äº†ã€‚
    let x = 1u8;
    let y = 2u32;
    let z = 3f32;
    let s = "hello";
```


## åŸºæœ¬æ•°æ®ç±»å‹


### å€¼ç±»å‹ and å¼•ç”¨ç±»å‹

å€¼ç±»å‹æ˜¯æŒ‡æ•°æ®ç›´æ¥å­˜å‚¨åœ¨æ ˆä¸­çš„æ•°æ®ç±»å‹ ï¼Œä¸€äº›åŸç”Ÿç±»å‹ï¼Œæ¯”å¦‚æ•°å€¼ ã€å¸ƒå°”å€¼ã€ç»“æ„ä½“, æšä¸¾ç­‰éƒ½æ˜¯å€¼ç±»å‹ã€‚å› æ­¤å¯¹å€¼ç±»å‹çš„æ“ä½œæ•ˆç‡ä¸€èˆ¬æ¯”è¾ƒé«˜ï¼Œä½¿ç”¨å®Œç«‹å³ä¼šè¢«å›æ”¶, è¿™äº›åŸºæœ¬ç±»å‹å®ç°äº† Copy trait, èµ‹å€¼è¯­å¥ä¸­ä¼šæ‰§è¡Œæ‹·è´

å¼•ç”¨ç±»å‹å°†æ•°æ®å­˜å‚¨åœ¨å †ä¸­ï¼Œè€Œæ ˆä¸­åªå­˜æ”¾æŒ‡å‘å †ä¸­æ•°æ®çš„åœ°å€, å¦‚æ•°ç»„, å­—ç¬¦ä¸²; å› æ­¤å¯¹å¼•ç”¨ç±»å‹çš„æ“ä½œæ•ˆç‡ä¸€èˆ¬æ¯”è¾ƒä½

### å¸¸é‡ é™æ€å˜é‡

```rust

// å¸¸é‡, é™æ€å˜é‡: åœ¨å…¨å±€å£°æ˜å¸¸é‡ or å˜é‡
    // éœ€è¦æ‰‹åŠ¨æŒ‡å®šç±»å‹
    // åŒºåˆ«/å¼‚åŒ:
    // - éƒ½æ˜¯åœ¨ç¼–è¯‘æœŸæ±‚å€¼çš„ï¼Œæ‰€ä»¥ä¸èƒ½ç”¨äºå­˜å‚¨éœ€è¦åŠ¨æ€åˆ†é…å†…å­˜çš„ç±»å‹ï¼Œæ¯”å¦‚ HashMap, vec
    // 
    // - é™æ€å˜é‡æœ‰å›ºå®šçš„å†…å­˜åœ°å€ (åˆ†é…åœ¨é™æ€å­˜å‚¨åŒº), å¯ä»¥æ˜¯å¯å˜çš„ (ç”¨ mut ä¿®é¥°), å¯èƒ½æœ‰å†…å­˜å®‰å…¨é—®é¢˜, æ‰€ä»¥ä¿®æ”¹éœ€è¦åœ¨ unsafe ä¸­; 
    // - å¸¸é‡æ²¡æœ‰å›ºå®šçš„å†…å­˜åœ°å€, ä¸å¯å˜ (ä¼šè¢«å†…è”, åœ¨è¢«ç”¨åˆ°çš„åœ°æ–¹ä¼šè¢«å¤åˆ¶è¿‡å», ç”¨ä¸åˆ°å†…å­˜åœ°å€)

    // æ™®é€šå¸¸é‡ ä¸èƒ½å¼•ç”¨ é™æ€å˜é‡

    // ä½¿ç”¨åœºæ™¯:
    // åœ¨å­˜å‚¨çš„æ•°æ®æ¯”è¾ƒå¤§ã€éœ€è¦å¼•ç”¨åœ°å€æˆ–å…·æœ‰å¯å˜æ€§çš„æƒ…å†µä¸‹ä½¿ç”¨é™æ€å˜é‡;å¦åˆ™ï¼Œåº”è¯¥ ä¼˜å…ˆä½¿ç”¨æ™®é€šå¸¸é‡
    const MAX_POINTS: u32 = 100_000;
    static LANGUAGE: &'static str = "Rust";//"string" å­—é¢é‡é»˜è®¤ç”Ÿå‘½å‘¨æœŸå°±æ˜¯ static çš„
```

### æ•°å­—

```rust
/// å¯¹äº åŸºæœ¬æ•°æ®ç±»å‹, æ•°æ®çš„å…‹éš†, ç§»åŠ¨éƒ½æ˜¯åœ¨æ ˆä¸Š, æ— éœ€å­˜å‚¨åˆ°å †ä¸­
fn basic_types() {
    // æ•´å‹

    // å æ® 8 bit
    const A: i8 = -2; // æœ‰ç¬¦å·
    const B: u8 = 2; // æ— ç¬¦å·
                     // const b: u8 = -2; // é”™è¯¯

    // å æ® 16 bit
    // i16 u16

    // å æ® 32 bit
    // i32 u32

    // 64 bit
    // i64 u64

    // 128
    // i128 u128

    // arch ç±»å‹
    // isize	usize
    //é•¿åº¦å–å†³äºæ‰€è¿è¡Œçš„ç›®æ ‡å¹³å°ï¼Œå¦‚æœæ˜¯ 32 ä½æ¶æ„çš„å¤„ç†å™¨å°†ä½¿ç”¨ 32 ä½ä½é•¿åº¦æ•´å‹ã€‚

    const C: i16 = 10_000; // 10è¿›åˆ¶
    const D: i16 = 0xff; // 16è¿›åˆ¶
    const E: i16 = 0o77; // 8 è¿›åˆ¶
    const F: i16 = 0b1111_0000; // äºŒè¿›åˆ¶
    

    // æµ®ç‚¹æ•°
    let x = 2.0; // é»˜è®¤ f64
    let y: f32 = 3.0; // f32

// ç›¸å…³å‡½æ•°
i32::min_value();-----2147483648
max_value()
// https://cloud.tencent.com/developer/article/1518453
```

### å¸ƒå°”å€¼ å­—ç¬¦ å­—èŠ‚


```rust



    // å¸ƒå°”å€¼, ç±»å‹ bool
    let is_a = true;

    // å­—ç¬¦, å•å¼•å·
    //4 ä¸ªå­—èŠ‚, æ”¯æŒä¸­æ–‡
    const CC: char = 'c';
    let heart_eyed_cat = 'ğŸ˜»';


    // å­—èŠ‚å­—é¢é‡, å¦‚ b'*' è¡¨ç¤º 42u8
    const G: u8 = b'A'; // å­—èŠ‚, åªèƒ½ u8 ç±»å‹
    const n: u8 = b'\n';

    std::mem:size_of<&[u32; 5]>() //å‡½æ•°å¯ä»¥è¿”å›ç±»å‹çš„å­—èŠ‚æ•°
    // &[u32;5]ç±»å‹ä¸ºæ™®é€šæŒ‡é’ˆ (å› ä¸ºæ•°ç»„çš„å…ƒç´ ç±»å‹, å…ƒç´ ä¸ªæ•°ç¡®å®šäº†, æ— éœ€é¢å¤–çš„å®¹é‡æ¥å­˜å‚¨æ•°æ®çš„é•¿åº¦)ï¼Œå 8ä¸ªå­—èŠ‚:
    // &mut[u32]ç±»å‹ä¸ºèƒ–æŒ‡é’ˆ (å®½åº¦æ˜¯åŒå®½åº¦çš„, æ•°ç»„çš„å…ƒç´ ä¸ªæ•°ä¸ç¡®å®š, é™¤äº†è¦ä¿å­˜æŒ‡å‘èµ·å§‹ä½ç½®çš„åœ°å€å¤–, è¿˜è¦ä¿å­˜æ•°æ®çš„é•¿åº¦  )ï¼Œå 16 ä¸ªå­—èŠ‚ã€‚ å¯è§ï¼Œ æ•´æ•´å¤šå‡ºäº†ä¸€å€çš„å ç”¨ç©ºé—´ï¼Œè¿™ä¹Ÿæ˜¯ç§°å…¶ä¸ºèƒ–æŒ‡é’ˆçš„åŸå› 
```


### æ•°ç»„


```rust

// å¯¹äºåŸå§‹å›ºå®šé•¿åº¦æ•°ç»„ï¼Œåªæœ‰å®ç° Copy trait çš„ç±»å‹æ‰èƒ½ä½œä¸ºå…¶å…ƒç´  ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œåªæœ‰ å¯ä»¥åœ¨æ ˆä¸Šå­˜æ”¾çš„å…ƒç´ æ‰å¯ä»¥å­˜æ”¾åœ¨è¯¥ç±»å‹çš„æ•°ç»„ä¸­ (åªæœ‰ç¡®å®šå¤§å°ç±»å‹(sized type)çš„å®ä¾‹æ‰å¯ä»¥æ”¾åˆ°æ ˆä¸Šï¼Œä¹Ÿå°±æ˜¯ï¼Œå¯ä»¥é€šè¿‡ä¼ å€¼çš„æ–¹å¼ä¼ é€’)

// ä¸ç¡®å®šå¤§å°ç±»å‹(unsized tpe)çš„å®ä¾‹ä¸èƒ½æ”¾åˆ°æ ˆä¸Šè€Œä¸”å¿…é¡»é€šè¿‡ä¼ å¼•ç”¨çš„æ–¹å¼ä¼ é€’

    // å¯ä»¥è‡ªåŠ¨æ¨æ–­ç±»å‹
    let a = [1, 2, 3, 4, 5];
    // a æ˜¯ä¸€ä¸ªé•¿åº¦ä¸º 5 çš„æ•´å‹æ•°ç»„

    let b = ["January", "February", "March"];
    // b æ˜¯ä¸€ä¸ªé•¿åº¦ä¸º 3 çš„å­—ç¬¦ä¸²æ•°ç»„


    // æ˜ç¡®æŒ‡å®šç±»å‹, æ•°ç»„ç±»å‹å¯ä»¥é€šè¿‡ [T, N] æ˜ç¡®æŒ‡å®š, T ä¸ºå…ƒç´ ç±»å‹, N ä¸º ä¸ªæ•°; å¦‚ [u8; 4] è¿™æ˜¯é™æ€ç±»å‹ (å› ä¸ºå·²çŸ¥å¤§å°äº†)
    // [u8] åªèƒ½æ˜¯åŠ¨æ€å¤§å°ç±»å‹, for don't know the size 
    let c: [i32; 5] = [1, 2, 3, 4, 5];
    // c æ˜¯ä¸€ä¸ªé•¿åº¦ä¸º 5 çš„ i32 æ•°ç»„

    let d = [3; 5];// ä½¿ç”¨é»˜è®¤ç±»å‹ i32, å…ƒç´ éƒ½ä¸º 3, ä¸ªæ•°ä¸º 5 ä¸ª
    // ç­‰åŒäº let d = [3, 3, 3, 3, 3];

    let d = [3u8; 5];// æŒ‡å®šç±»å‹ä¸º u8

    // æ•°ç»„è®¿é—®
    let first = a[0];
    let second = a[1];

    a[0] = 123; // é”™è¯¯ï¼šæ•°ç»„ a ä¸å¯å˜
    
    let mut a = [1, 2, 3];
    a[0] = 4; // æ­£ç¡®
    
    // æ•°ç»„éå†
    for ele in a.iter() {
        println!("{}", ele);
    }

    // 
    // è¿æ¥ä¸¤ä¸ª array å¯ä»¥ä½¿ç”¨ join


    // match è¯­æ³•
    // é€šè¿‡åŒ¹é…æ•°ç»„çš„ä¸åŒå…ƒ å¯ä»¥å®ç°æŒ‡å®šçš„åŠŸèƒ½ ã€‚
    // æŒ‘é€‰å‡ºä»¥ 3 ç»“å°¾å’Œç¬¬ äºŒä¸ªå…ƒç´ ä¸º 2 çš„æ•°ç»„ã€‚
    fn pick(arr: [i32; 3])  {// è¿™ä¸ªæœ‰é™åˆ¶, å‚æ•°æ•°ç»„çš„å…ƒç´ ä¸ªæ•°ä¸å¯å˜, å¿…é¡»ä¸º 3
        match arr {
            [_, _, 3] => println!("ends with 3"),
            [a, 2, c] => println!("{:?}, 2, {:?}", a,  c),
        //  matchåŒ¹é…çš„æœ€åä¸€ä¸ªåˆ†æ”¯ï¼Œå¿…é¡»ä½¿ç”¨é€šé…ç¬¦æˆ–å…¶ä»–å˜é‡æ¥ç©·å°½æšä¸¾
            [_, _, _] => println!("pass!"),
        }
    }
    // å˜é•¿å‚æ•°
    // åˆ©ç”¨æ•°ç»„åˆ‡ ç‰‡å°±å¯ä»¥æ¨¡æ‹Ÿå˜é•¿å‚æ•°çš„å‡½æ•°
    fn sum(num: &[i32]) { // åŸç´ ä¸ªæ•°å¯å˜
        match num {
            [one] => println!(" at least two"),
            [first, second] => println!("{:?} + {:?} = {:?} ", first, second, first+second),
            _ => println!("sum is {:?}", num.iter().fold(0, |sum, i| sum + i) ),
        }
    }
    fn main() {
        sum(&[1]);
        sum(&[1, 2]);
        sum(&[1, 2, 3]);
        sum(&[1, 2, 3, 5]);
    }


    // äºŒåˆ†æŸ¥æ‰¾
    // æ ¹æ®å…ƒç´ æŸ¥æ‰¾ç´¢å¼•
    if let Ok(9) = arr.binary_search(&13) {}
    // ç­‰ä»·
    arr.binary_search_by(|x| x.cmp(&13))
    // binary search by_key


    let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];
    assert_eq!(s.binary_search(&13),  Ok(9));
    assert_eq!(s.binary_search(&4),   Err(7));
    let r = s.binary_search(&1);
    assert!(match r { Ok(1...4) => true, _ => false, });
    let seek = 13;
    assert_eq!(
        s.binary_search_by(|probe| probe.cmp(&seek)),
       Ok(9)
   );
   let s = [(0, 0), (2, 1), (4, 1), (5, 1), (3, 1),
              (1, 2), (2, 3), (4, 5), (5, 8), (3, 13),
              (1, 21), (2, 34), (4, 55)];
   assert_eq!(
       s.binary_search_by_key(&13, |&(a,b)| b),
       Ok(9)
   );
    

```


### Range èŒƒå›´

```rust
// /åŒ…å¤´ä¸åŒ…å°¾
(1..5) <=> std::ops::Range {start: 1, end: 5}

(1..=5) <=> std::ops::RangeInclusive::new(1, 5)
(3..6).sum()
for i in 0..4 {
    
}
for i in 0..=4) {
    
}
```

### åˆ‡ç‰‡

```rust


///åˆ‡ç‰‡
///
/// åˆ‡ç‰‡æ˜¯å¯¹åŸå§‹æ•°æ®é›†åˆçš„éƒ¨åˆ†å¼•ç”¨, æ²¡æœ‰åŸå§‹ æ•°æ®é›†åˆ çš„æ‰€æœ‰æƒ (åŸå§‹æ•°æ®é›†åˆå¯èƒ½æ˜¯ æ•°ç»„, Vec);æ— æ³•ä¿®æ”¹åŸå§‹å€¼
///
/// è‹¥åŸå§‹å€¼ ä¸º T, åˆ™ åˆ‡ç‰‡ç±»å‹ä¸º  &[T] or &mut[T]
/// 
/// ..y ç­‰ä»·äº 0..y (åŒ…å¤´ä¸åŒ…å°¾å·´)
/// x.. ç­‰ä»·äºä½ç½® x åˆ°æ•°æ®ç»“æŸ
/// .. ç­‰ä»·äºä½ç½® 0 åˆ°ç»“æŸ
/// 
/// 
/// 
fn slice_vec() {
    // å­—ç¬¦ä¸²åˆ‡ç‰‡   
    let s = String::from("broadcast");
    let part1 = &s[0..5];// æˆªå–å­ä¸², å­—ç¬¦ä¸²åˆ‡ç‰‡å°±æ˜¯ &str ç±»å‹
    let part2 = &s[5..9];
    println!("{}={}+{}", s, part1, part2);

    // è¢«åˆ‡ç‰‡å¼•ç”¨çš„å­—ç¬¦ä¸²ç¦æ­¢æ›´æ”¹åŸå§‹å€¼
    let mut s = String::from("xxxxxx");
    let slice = &s[0..3];
    s.push_str("yes!"); // é”™è¯¯

    //æ•°ç»„åˆ‡ç‰‡
    let arr = [1, 3, 5, 7, 9];
    let part = &arr[0..3];
    for i in part.iter() {
        println!("{}", i);//1, 3, 5
    }

    // ä¸¤ä¸ª const fn æ–¹æ³•: len(), is_empty()

    // é€šè¿‡ &mut å®šä¹‰å¯å˜åˆ‡ç‰‡
    let arr = &mut [1,2,3];
    arr[1] = 0;

    // åŠ¨æ€æ•°ç»„è½¬åˆ‡ç‰‡
    let arr = &vec![1,2,3][..];
    
}
```



### str å­—ç¬¦ä¸²åˆ‡ç‰‡

```rust
// str æ˜¯å…¸å‹çš„åŠ¨æ€å¤§å°ç±»å‹ (DST), ç¼–è¯‘æœŸä¸å¯çŸ¥å¤§å°, åˆ†é…åœ¨å †ä¸Š
//æ‰€ä»¥ç¼–è¯‘å™¨è¦æ±‚å¿…é¡»ä»¥ä¸å¯å˜å€Ÿç”¨çš„å½¢å¼åœ¨ä»£ç ä¸­å­˜åœ¨ å³ &str, è¿™ä¸ªå€Ÿç”¨çš„å¤§å°æ˜¯ç¡®å®šçš„(ä¸€ä¸ªæŒ‡é’ˆ+é•¿åº¦), &str å­˜å‚¨åœ¨æ ˆä¸Š, å¯¹åº”çš„ str å­˜åœ¨ å †ä¸Š
// 
// å­—ç¬¦ä¸²å­—é¢é‡æ˜¯ç‰¹æ®Šçš„ str, ç‰¹æ®Šåœ¨å…¶å…·æœ‰é™æ€ç”Ÿå‘½å‘¨æœŸ, å¿…é¡»ä»¥ç±»å‹  &'static  str æ¥æ”¶
//
//fat pointer(èƒ–æŒ‡é’ˆ): åŒ…å« DST çš„åœ°å€ä¿¡æ¯ å’Œ é•¿åº¦çš„æŒ‡é’ˆ, &str å³èƒ–æŒ‡é’ˆ

let ss = "hello world";
let ptr = ss.as_ptr();
let s = unsafe {
    let slice = std::slice::from_raw_parts(ptr, ss.len());
    std::str::from_utf8(slice).unwrap()
};
if ss == s {
    println!("equal");//equal
}
```



### åŸç”ŸæŒ‡é’ˆ raw pointer

åˆ†ä¸º ä¸å¯å˜ raw pointer å’Œ å¯å˜ raw pointer

æŒ‡é’ˆä¸åŒäº å¼•ç”¨, æŒ‡é’ˆç±»å‹ *T, å¼•ç”¨ç±»å‹ &T

```rs
#![feature(never_type)]

let mut a = 10;
let a_ptr = &mut a as *mut i32;
let b = Box::new(20);
let b_ptr = &*b as *const i32;
unsafe { 
    *a_ptr += *b_ptr;
}
println!("{:?}", a);//30
```


### never ç±»å‹ æ„Ÿå¹å·

```rs
// åº•ç±»å‹ botto type
// BangType
// 
// Rust ä¸­æœ‰å¾ˆå¤šç§æƒ…å†µç¡® å®æ²¡æœ‰å€¼ï¼Œä½†ä¸ºäº†ç±»å‹å®‰å…¨ï¼Œå¿…é¡»æŠŠè¿™äº›æƒ…å†µçº³å…¥ç±»å‹ç³»ç»Ÿè¿›è¡Œç»Ÿä¸€ å¤„ç†
// 
// å‘æ•£å‡½æ•° (Diverging Function ): æ°¸è¿œä¸ä¼šæœ‰è¿”å›å€¼çš„å‡½æ•°, å¦‚ panic! æˆ–è€… std::process: :exit ...
// continue å’Œ break å…³é”®å­—
//loopå¾ªç¯
// ç©ºæšä¸¾ï¼Œæ¯”å¦‚ enumVoid{}

# ! [feature (never_type)]// éœ€è¦æ”¯æŒ
fn foo() -> i32 {
    // !è¡¨ç¤ºæ°¸è¿œä¸ä¼šæœ‰è¿”å›å€¼çš„ç±»å‹
    let x: ! = {
        return 11;// ç›´æ¥fooå‡½æ•°è¿”å›é€€å‡ºäº†, æ‰€ä»¥ x æ°¸è¿œä¸ä¼šæœ‰è¿”å›å€¼, æ˜¯ ! ç±»å‹
    };

    // panic å®åœ¨ match åˆ†æ”¯ä¸­ä½¿ç”¨æ—¶, å³ä½¿æ²¡æœ‰è¿”å›å’Œå…¶ä»–åˆ†æ”¯ç›¸åŒçš„ç±»å‹, ä¹Ÿæ²¡æŠ¥é”™, ä¸ºä»€ä¹ˆ?
    // å› ä¸ºè¿”å› äº† ! ç±»å‹, (never ç±»å‹å¯ä»¥è½¬ä¸ºä»»ä½•ç±»å‹)

    // ç©ºæšä¸¾çš„ç”¨æ³•åœºæ™¯:
    enum Void {}
    let res: Result<i32, Void> = Ok(11);
    let Ok(num) = res;//å½“ç„¶è¿™é‡Œä¹Ÿå¯ä»¥ç”¨ if let è¯­å¥å¤„ç†
}
```






## å­—ç¬¦ä¸²

### å‡ ç§å­—ç¬¦ä¸²åŒºåˆ«

```rust

/// å­—ç¬¦ä¸²
///
/// - str è¡¨ç¤ºå›ºå®šé•¿åº¦çš„å­—ç¬¦ä¸², å± äºåŠ¨æ€å¤§ å° ç±»å‹ (DST)ï¼Œä¿è¯ æœ‰æ•ˆ UTF-8 , åœ¨ç¼–è¯‘æœŸå¹¶ä¸èƒ½ç¡®å®šå…¶å¤§å°ï¼Œæ‰€ä»¥åœ¨ç¨‹åºä¸­æœ€å¸¸è§åˆ°çš„æ˜¯ str çš„åˆ‡ç‰‡ (Slice)ç±»å‹ &strã€‚  
//      &str è¡¨ç¤ºå­—ç¬¦ä¸²å­—é¢é‡, æ˜¯å¼•ç”¨ç±»å‹; å­—ç¬¦ä¸²åˆ‡ç‰‡å°±æ˜¯ &str, å’Œç¨‹åºä»£ç æ®µå­˜å‚¨åœ¨ä¸€èµ·(åœ¨ç¼–è¯‘æœŸé—´åœ°å€å°±çŸ¥é“äº†), æ‰§è¡Œçš„æ˜¯å¤åˆ¶è¯­ä¹‰
///
/// - String ç±»å‹, é•¿åº¦å¯å˜, å¯ä¿®æ”¹, å­˜å‚¨ä¸ºç”±å­—èŠ‚ç»„æˆçš„ vectorï¼ˆVec<u8>ï¼‰ï¼Œä½†ä¿è¯äº†å®ƒä¸€å®šæ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„ UTF-8 åºåˆ—, å­—ç¬¦åºåˆ—åˆ†é…åœ¨å †, æ‰§è¡Œçš„æ˜¯ç§»åŠ¨è¯­ä¹‰
///
///     String æœ‰ä¸€ä¸ªå­—ç¬¦å¼€å§‹ä½ç½®å±æ€§ ptr, å’Œä¸€ä¸ªå­—ç¬¦ä¸²é•¿åº¦å±æ€§ len, å’Œå †åˆ†é…çš„å®¹é‡ capacity, è¿™äº›å±æ€§ä½äº æ ˆ, å®é™…å­—ç¬¦åºåˆ—å­˜åœ¨ å †
///     str    æœ‰  ptr å’Œ len, å±æ€§, å†…å®¹éƒ½åœ¨ æ ˆ
// 
// - CStrï¼Œ è¡¨ç¤ºç”±Cåˆ†é…è€Œè¢«Rustå€Ÿç”¨çš„å­—ç¬¦ä¸²ï¼Œ ä¸€èˆ¬ç”¨äºå’ŒCè¯­è¨€äº¤äº’ã€‚
// - CStringï¼Œ è¡¨ç¤ºç”± Rust åˆ†é…ä¸”å¯ä»¥ä¼ é€’ç»™ C å‡½æ•°ä½¿ç”¨çš„ C å­—ç¬¦ä¸² ï¼ŒåŒæ ·ç”¨ äºå’Œ C è¯­è¨€äº¤äº’ã€‚
// 
// - OsStrï¼Œ è¡¨ç¤ºå’Œæ“ä½œç³»ç»Ÿç›¸å…³çš„å­—ç¬¦ä¸²ã€‚è¿™æ˜¯ä¸ºäº†å…¼å®¹ Windowsç³»ç»Ÿã€‚
// - OsStringï¼Œè¡¨ç¤º OsStr çš„å¯å˜ç‰ˆæœ¬ ã€‚ä¸ Rust å­—ç¬¦ä¸²å¯ä»¥ç›¸äº’è½¬æ¢
// - Pathï¼Œè¡¨ç¤ºè·¯å¾„ï¼Œå®šä¹‰äº std::pathæ¨¡å—ä¸­ã€‚ PathåŒ…è£…äº† OsS
// - PathBuf. ft~ Path é…å¯¹ï¼Œ æ˜¯ Path çš„å¯å˜ç‰ˆæœ¬ ã€‚ PathBufåŒ…è£…äº† OsStringã€‚
///
```

### å¸¸ç”¨æ–¹æ³•

```rust
fn str_string() {

    
// å­—ç¬¦ä¸²è½¬ä¹‰
    // é•¿å­—ç¬¦ä¸²
    let long_string = "String literals
                        can span multiple lines.
                        The linebreak and \' indentation here 
                        can be escaped too!";
    println!("{}", long_string);

    b' '  è¡¨ç¤º ç©ºæ ¼å­—ç¬¦

    
    let str_value: &'static str = "1234";// å­—ç¬¦ä¸²åˆ‡ç‰‡
    //ç®€å•å†™æ³•ä¸º
    let str_value = "1234";

    let s = string::new() // æ­¤æ—¶è¿˜å¹¶æœªåœ¨å †ä¸Šåˆ†é…ç©ºé—´
    let str1 = String::from("hello");
    // æŒ‡å®šå †å®¹é‡
    let s =  String : :with_capacity (20)
    // å†æ¬¡åˆ†é…å®¹é‡
    s.reserve(lO)
    
    let one = 1.to_string();         // æ•´æ•°åˆ°å­—ç¬¦ä¸²
    let float = 1.3.to_string();     // æµ®ç‚¹æ•°åˆ°å­—ç¬¦ä¸²
    let slice = "slice".to_string(); // å­—ç¬¦ä¸²åˆ‡ç‰‡åˆ°å­—ç¬¦ä¸²
    
    

    // æ–°å¢ æ·»åŠ 
    //å®šä¹‰ä¸€ä¸ªå¯å˜å­—ç¬¦ä¸²ï¼Œå¹¶å¯¹å…¶è¿›è¡Œä¿®æ”¹
    let mut string_value: String = "1111".to_string();
    // æˆ–è€…
    // let string_value = String::from("222");
    string_value.push_str("333");// æ·»åŠ å­—ç¬¦ä¸²åˆ‡ç‰‡
    string_value.push('!'); // æ·»åŠ å­—ç¬¦

    // æ’å…¥
    s.insert(0, 'fâ€™)
    s. insert_str(O,â€barâ€)

    // è¿æ¥
    // String ç±»å‹çš„å­—ç¬¦ä¸²ä¹Ÿå®ç°äº† Add<&str> å’Œ AddAssign<&str>ä¸¤ä¸ª traitï¼Œè¿™æ„å‘³ç€å¯ä»¥ä½¿ç”¨â€œ+â€å’Œâ€œ+=â€æ“ä½œç¬¦æ¥è¿æ¥å­—ç¬¦ä¸²
    // æ“ä½œç¬¦ å³è¾¹çš„å­—ç¬¦ä¸²å¿…é¡»ä¸ºåˆ‡ç‰‡ç±»å‹ (&str)



    // æ›¿æ¢
    //
    string.replace("old_str", "new str");

    
    // åˆ é™¤
    s .remove (3) //æŒ‡å®šä½ç½®
    s.pop()//æœ€åä¸€ä¸ªå­—ç¬¦, å¹¶ä¸”è¿”å›
    s. truncate (3)//æŒ‡å®šä½ç½®åˆ°æœ«å°¾åˆ é™¤
    s .clear( );//æ¸…ç©º
    s .drain (..beta_offset) .collect()// æˆªå–æºçš„æŒ‡å®šèŒƒå›´å¹¶è¿”å›, æºä¼šæ”¹å˜, åªç•™ä¸‹å‰©ä¸‹çš„éƒ¨åˆ†
    s.drain(..)// ç­‰ä»· clear, æˆªå–æºçš„å…¨éƒ¨, æºå˜ç©º



    // trim é¦–å°¾å»é™¤
    //
    let chars_to_trim: &[char] = &[' ', ','];
    // å»é™¤ string é¦–å°¾çš„å­—ç¬¦, è¿™äº›å­—ç¬¦åœ¨ chars_to_trim ä¸­æŒ‡å®š
    let trimmed_str: &str = string.trim_matches(chars_to_trim);



    // æŸ¥æ‰¾
    // æ ‡å‡†åº“ä¸­å¹¶æ²¡æœ‰æä¾›æ­£åˆ™è¡¨è¾¾å¼æ”¯æŒï¼Œè¿™æ˜¯å› ä¸ºæ­£åˆ™è¡¨è¾¾å¼ç®—æ˜¯å¤–éƒ¨DSLï¼Œ å¦‚æœ ç›´æ¥å°†å…¶å¼•å…¥æ ‡å‡†åº“ä¸­ï¼Œåˆ™ä¼šç ´å Rustçš„ä¸€è‡´æ€§
    // ç¬¬ä¸‰æ–¹åŒ… regex
    // Rust ä¸­è¿™é‡Œä½¿ç”¨ çš„å­—ç¬¦åŒ¹é…ç®— æ³•å¹¶é KMPï¼Œè€Œæ˜¯å®ƒçš„å˜ç§åŒå‘( Two-Way)å­—ç¬¦ä¸²åŒ¹é…ç®—æ³• ï¼Œè¯¥ç®—æ³•çš„ä¼˜åŠ¿åœ¨äºæ‹¥æœ‰å¸¸é‡çº§çš„ç©ºé—´å¤æ‚åº¦ã€‚å®ƒå’Œ KMP çš„å…±åŒç‚¹åœ¨äºå…¶æ—¶é—´å¤æ‚åº¦ä¹Ÿæ˜¯ O(n)
    // 
    // å­˜åœ¨æ€§åˆ¤æ–­ã€‚ ç›¸å…³æ–¹æ³•åŒ…æ‹¬contains (æ”¯æŒ å­—ç¬¦/å­—ç¬¦ä¸²/è°“è¯)ã€ starts_with (æ”¯æŒå­—ç¬¦/å­—ç¬¦ä¸²)ã€ ends_with
    // ä½ç½®åŒ¹é… ã€‚ç›¸å…³æ–¹æ³•åŒ…æ‹¬ findã€ rfind (ä»å³è¾¹å¼€å§‹æœç´¢, æ”¯æŒè°“è¯)ã€‚
    // åˆ†å‰²å­—ç¬¦ä¸² ã€‚ç›¸å…³æ–¹æ³•åŒ…æ‹¬ splitã€rsplitã€split_terminator(å»æ‰æ•°ç»„lastå…ƒç´ çš„å¤šä½™)ã€rsplit_terminatorã€splitn (æŒ‡å®šåˆ†å‰²åçš„æ•°ç»„é•¿åº¦)ã€rsplitnã€‚ 
    // æ•è·åŒ¹é…, è¿”å›æ•°ç»„ã€‚ ç›¸å…³æ–¹æ³•åŒ…æ‹¬ matchsã€ rmatchesã€ match_indices (è¿”å›çš„æ˜¯å…ƒç»„æ•°ç»„, åŒ…å«äº†ç´¢å¼•)ã€ rmatch_indicesã€‚ 
    // åˆ é™¤åŒ¹é…ã€‚ ç›¸å…³æ–¹æ³•åŒ…æ‹¬ trim(åˆ é™¤ä¸¤å¤´ç©ºæ ¼, ä¸èƒ½æŒ‡å®š pattern å‚æ•°), trim_left, trim_right , trim_matches(å¯æŒ‡å®š pattern å‚æ•°)ã€trim_left_matchesã€trim_right_matchesã€‚ 
    // æ›¿ä»£åŒ¹é…ã€‚ ç›¸å…³æ–¹æ³•åŒ…æ‹¬ replaceã€ replacen(æŒ‡å®šæ›¿æ¢å­—ç¬¦çš„ä¸ªæ•°)
    





    // ç»Ÿè®¡é•¿åº¦
    // å­—ç¬¦ å­—èŠ‚
    //
    let s = "hello";
    //å­—èŠ‚
    let len = s.len();// 5, å­—èŠ‚æ•°, æ¯ä¸ªè‹±æ–‡å­—ç¬¦å ä½1å­—èŠ‚
    let s = "ä½ å¥½";
    let len = s.len();//6, å› ä¸ºä¸­æ–‡æ˜¯ UTF-8 ç¼–ç çš„ï¼Œæ¯ä¸ªå­—ç¬¦é•¿ 3 å­—èŠ‚
    let s = "helloä½ å¥½";
    let len = s.bytes().count();//æä¾›äº† bytes å’Œ chars ä¸¤ä¸ªæ–¹æ³•æ¥åˆ†åˆ«è¿”å›æŒ‰å­—èŠ‚ å’ŒæŒ‰å­—ç¬¦è¿­ä»£çš„æ³•ä»£å™¨
    //å­—ç¬¦
    let len = s.chars().count();// 7, ç»Ÿè®¡å­—ç¬¦æ•° (ç»Ÿè®¡å­—ç¬¦çš„é€Ÿåº¦æ¯”ç»Ÿè®¡æ•°æ®é•¿åº¦çš„é€Ÿåº¦æ…¢å¾—å¤š)
    //éå†å­—ç¬¦
    for c in s.chars() {
        print!("{} ", c);
    }
    // or
    let s: String = s.chars() .enumerate() .map(| (i, c) | {}).collect()

    // æŒ‰ç´¢å¼•è®¿é—®å­—ç¬¦
    let mut result = s.into_bytes();//é€šè¿‡ into_bytesæ–¹æ³•å°†å­—ç¬¦ä¸²è½¬æ¢ä¸º Vec<u8>åºåˆ—
        (0..bs.len()).for_each(|i| println!("index = {:?}, value = {:?}", i, char::from(bs[i])));
    let new_s = String: :from_utf8(result).unwrap()
    

    // è·å–å•ä¸ªå­—ç¬¦
    let s = String::from("ENä¸­æ–‡");
    let a = s.chars().nth(2); //nth å‡½æ•°æ˜¯ä»è¿­ä»£å™¨ä¸­å–å‡ºæŸå€¼çš„æ–¹æ³•ï¼Œä¸è¦åœ¨éå†ä¸­è¿™æ ·ä½¿ç”¨ï¼å› ä¸º UTF-8 æ¯ä¸ªå­—ç¬¦çš„é•¿åº¦ä¸ä¸€å®šç›¸ç­‰
    println!("{:?}", a);//Some('ä¸­')

    
    // æŒ‡å®šç´¢å¼•èŒƒå›´æ¥è·å–å­—ç¬¦ä¸²åˆ‡ç‰‡
    let v =  String::from("hello");
    let s: Some<&str> = v.get(0..1);
    v.get_mut((xxx))
    assert ! (!v .is_char boundary(4)) ;//éªŒè¯æŸä¸ªç´¢å¼•ä½ç½®æ˜¯å¦ä¸ºåˆæ³•çš„è¾¹ç•Œ, å› ä¸ºå¯èƒ½æŸä¸ªå­—ç¬¦å æ®äº†å¤šä¸ªç´¢å¼•ä½ç½®(stringçš„æ–¹æ³•é»˜è®¤éƒ½æ˜¯æŒ‰ç…§å­—èŠ‚æ¥å¤„ç†çš„, ä¹Ÿå°±æ˜¯ä¸€ä¸ªç´¢å¼•ä½ç½®å¯¹åº”ä¸€ä¸ªå­—èŠ‚, æŸäº›å­—ç¬¦è‹±æ–‡å­—ç¬¦å¤–çš„å­—ç¬¦å¯èƒ½ä¸æ­¢ä¸€ä¸ªå­—èŠ‚)









    // åˆ†å‰²
    let bool_s = s.is_char_boundary(12)
    s.split_at(12)// éœ€è¦å…ˆæ£€æŸ¥ç´¢å¼•æ˜¯å¦æ˜¯åˆæ³•å­—ç¬¦è¾¹ç•Œ


    // ç©ºæ ¼åˆ†å‰², é€†åº
    let pangram: &'static str = "the quick brown fox jumps over the lazy dog";
    for word in pangram.split_whitespace().rev() {
        println!("> {}", word);
    }

    
    // å­—ç¬¦ä¸²åˆ†å‰²æˆå­—ç¬¦ï¼Œæ’åºå¹¶ç§»é™¤é‡å¤å€¼
    let mut chars: Vec<char> = pangram.chars().collect();
    chars.sort();
    chars.dedup(); //å»é‡


    



    // è·å–å­—èŠ‚ éå†å­—èŠ‚
    // as_bytes()
    //
    fn first_word(s: &String) -> usize {
        // å­—èŠ‚æ•°ç»„, ä¸€ä¸ªè‹±æ–‡å­—ç¬¦å ä¸€ä¸ªå­—èŠ‚
        let bytes = s.as_bytes();
        for (i, &item) in bytes.iter().enumerate() {
            if item == b' ' {// å¦‚æœæ˜¯ç©ºæ ¼
                return i;
            }
        }
        s.len()
    }
    first_word(&"hello world".to_owned());// 5

```


### å­—ç¬¦ä¸²è½¬æ¢

```rs
 //
    //
    // å¤æ‚ç±»å‹çš„ç±»å‹è½¬æ¢ ç›¸äº’è½¬æ¢ äº’è½¬
    //
    // String => &str
    let s1 = String::from("hello");
    // æ–¹æ³•1
    let s2 = &s1[..]; 
    let ssss = &s1[..2];// æˆªå–å­ä¸²
    // æ–¹æ³•2
    let sss: &str = &s1.as_str();
    //
    // æ–¹æ³•3
    // *s1 æ˜¯ str ç±»å‹, &*s1 å³ä¸º &str ç±»å‹
    let new_str = &*s1;
    //
    //
    // &str -> String
    let new_string = new_str.to_string();//to_stringåº•å±‚è°ƒç”¨çš„String::from
    let new_string1 = s2.to_string();
    println!("new_string = {}, new_string1 = {}", new_string, new_string1);
    // &str -> String
    let string = "hello".to_owned(); //æœ€å¸¸ç”¨, å§ "hello"ä»æ ˆè½¬ç§»åˆ°å †, to_owned æ–¹æ³•åˆ©ç”¨ &str åˆ‡ç‰‡å­—èŠ‚åºåˆ—ç”Ÿæˆæ–°çš„ Stringå­—ç¬¦ä¸² ï¼Œ to_stringæ–¹æ³•æ˜¯å¯¹ String::from çš„åŒ…è£…, ä¸¤è€…æ€§èƒ½ç›¸å½“

    // &str -> String
    let _s: String = "hello".into();



    // string -> T
    // std::stræ¨¡å—ä¸­æä¾›çš„ parseæ³›å‹æ–¹æ³•æ¥å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºæŒ‡å®šçš„ç±»å‹
    // åº•å±‚æ˜¯ FromStr::from_str

    //T -> string
    // format!()
    let s = format!("{}", xxx); 
```


### æ ¼å¼åŒ– 

```rust

    // æ‹¼æ¥
    // æ–°åŠ çš„å­—ç¬¦ä¸²å¿…é¡»æ˜¯  &str
    //
    let str1 = String::from("hello");
    let str2 = String::from("world");
    let str3 = str1 + "-" + &str2;
    
    // or
    let s = format!("{} - {}", str3, str2);



    //
    // æ ¼å¼åŒ–è¾“å‡º
    // ç”±ä¸€äº›å®(macro)è´Ÿè´£è¾“å‡ºï¼Œè¿™äº›å®å®šä¹‰åœ¨std::fmtä¸­
    //
    // åŸç†æ˜¯: å¿…é¡»å®ç° std::fmt::Display è¿™ä¸ªtraitæä¾›çš„ fmt æ–¹æ³•
    //
    // format!()ï¼šå‘å­—ç¬¦ä¸²ä¸­è¾“å‡ºæ ¼å¼åŒ–å­—ç¬¦ä¸²ã€‚
    // print()!ï¼šå‘æ ‡å‡†è¾“å‡ºæ‰“å°å­—ç¬¦ä¸²ã€‚
    // println()!ï¼šå‘æ ‡å‡†è¾“å‡ºæ‰“å°å­—ç¬¦ä¸²ï¼ŒåŒæ—¶ä¼šæ‰“å°ä¸€ä¸ªæ¢è¡Œç¬¦ã€‚
    // eprint()!ï¼šå‘æ ‡å‡†é”™è¯¯æ‰“å°å­—ç¬¦ä¸²ã€‚
    // eprintln()!ï¼šå‘æ ‡å‡†é”™è¯¯æ‰“å°å­—ç¬¦ä¸²ï¼ŒåŒæ—¶ä¹Ÿä¼šæ‰“å°ä¸€ä¸ªæ¢è¡Œç¬¦


    // å ä½ç¬¦ 
    // {} -> Display
    // {:?} -> Debug
    // {:#?} -> æ ¼å¼åŒ–çš„ Debug
    // {:o} -> å…«è¿›åˆ¶
    // {:x} -> åå…­è¿›åˆ¶å°å†™
    // {:X}   åå…­è¿›åˆ¶å¤§å†™
    // {:p}   æŒ‡é’ˆåœ°å€
    // {:b}   äºŒè¿›åˆ¶
    // {:e}   æ•°å­—æ ¼å¼, æŒ‡æ•°å°å†™
    // {:E}   æŒ‡æ•°å¤§å†™




    println!("hello {}", "world");
    println!("{0} {1}", "hello", "world");
    println!("{h} {w}", h = "hello", w = "world");
    // ä»¥äºŒè¿›åˆ¶çš„æ ¼å¼æ‰“å°æ•°å­—
    println!(
        "{} of {:b} people know binary, the other half doesn't",
        1, 2
    );
    // å³å¯¹é½å®½åº¦ä¸º6
    println!("{number:>width$}", number = 1, width = 6);// '.....1'
    // ä½¿ç”¨å­—ç¬¦0å¡«å……å¯¹é½çš„å­—ç¬¦ä¸²
    println!("{number:>0width$}", number = 1, width = 6);// '000001'

    let s = format!("hello {}", "world");
    println!("{}", s);
    // åå…­è¿›åˆ¶è¾“å‡º
    format!("0x{:X}", 100); //-> "0xDEADBEEF"
                            // å…«è¿›åˆ¶è¾“å‡º
    format!("0o{:o}", 100); //-> "0o33653337357"


```

### è°ƒè¯•æ‰“å°å¤åˆç±»å‹ Debug Display


```rust
    //è°ƒè¯•
    //
    // fmt::Debug ç±»ä¼¼ Display è¿™ä¸ª trait, ä½†æ˜¯èƒ½å¤Ÿç”± rust è‡ªåŠ¨æ¨å¯¼å®ç°, æ— éœ€æ‰‹åŠ¨å®ç°
    // 
    // fmt::Debugæ˜¯Rustæ ‡å‡†åº“å·²ç»å®šä¹‰å¥½çš„ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ç»§æ‰¿çš„æ–¹å¼ï¼Œè·å¾—fmt::Debugçš„èƒ½åŠ›, 
    //å³å®šä¹‰ struct æ—¶ æ·»åŠ  #[derive(Debug)]
    //å…¶ä»–çš„è¿˜æœ‰ #[allow(dead_code)] ç”¨äºå±è”½å¯¹æœªä½¿ç”¨ä»£ç çš„è­¦å‘Š
    #[derive(Debug)] 
    struct DebugDemo(i32);
    let debug_demo = DebugDemo(11);
    println!("Debug - {:?}", debug_demo);
    println!("{0:?}", debug_demo);// ç­‰æ•ˆ

    //
    // fmt::Display è‡ªå®šä¹‰æ‰“å°
    //æ˜¯ä¸€ä¸ªç”¨äºè‡ªå®šä¹‰æ ¼å¼åŒ–è¾“å‡ºçš„æ¥å£
    //
    // å¯¹äºæ³›å‹å®¹å™¨, å¦‚ Vec<T>, éœ€è¦è‡ªå·±å®ç°fmt::Display, æˆ–è€…ç›´æ¥ ç”¨fmt::Debug
    //
    struct DisplayDemo(i32);
    impl fmt::Display for DisplayDemo {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {

            write!(f, "({})", self.0)
        }
    }
    let display_demo = DisplayDemo(11);
    println!("display - {}", display_demo);


```

### é—®å·æ“ä½œç¬¦ å¤šæ¬¡å†™

```rust

    // "?" é—®å·æ“ä½œç¬¦: å°è¯•è§£åŒ…, è¿”å›å€¼ä¸º è§£åŒ…åçš„å€¼, æœ‰å¼‚å¸¸, è¿”å›å¼‚å¸¸, æ²¡æœ‰åˆ™ç»§ç»­åç»­ä»£ç 
    //
    //è€ƒè™‘è¿™ç§åœºæ™¯: å¯¹ä¸€ä¸ªç»“æ„ä½“æƒ³å®ç° fmt::Displayï¼Œä½†æ˜¯å…¶ä¸­çš„å…ƒç´ éœ€è¦ä¸€ä¸ªæ¥ä¸€ä¸ªåœ°å†™å‡ºå»ï¼Œ
    //é—®é¢˜åœ¨äºæ¯ä¸ª write! éƒ½è¦ç”Ÿæˆä¸€ä¸ª fmt::Resultã€‚
    //
    //è§£å†³: write!(f, "{}", value)?;  å¤šæ¬¡å†™
    // å¯¹ `write!` è¿›è¡Œå°è¯•ï¼ˆtryï¼‰ï¼Œè§‚å¯Ÿæ˜¯å¦å‡ºé”™ã€‚è‹¥å‘ç”Ÿé”™è¯¯ï¼Œè¿”å›ç›¸åº”çš„é”™è¯¯ã€‚
    // å¦åˆ™ï¼ˆæ²¡æœ‰å‡ºé”™ï¼‰ç»§ç»­æ‰§è¡Œåé¢çš„è¯­å¥ã€‚ åŒ try!(xxx)
    //
    //
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        // ä½¿ç”¨å…ƒç»„çš„ä¸‹æ ‡è·å–å€¼ï¼Œå¹¶åˆ›å»ºä¸€ä¸ª `vec` çš„å¼•ç”¨ã€‚
        let vec = &self.0;

        write!(f, "[")?;//å¤šæ¬¡å†™

         // éå†ä¸‹æ ‡
        for (count, v) in vec.iter().enumerate() {
            // å¯¹æ¯ä¸ªå…ƒç´ ï¼ˆç¬¬ä¸€ä¸ªå…ƒç´ é™¤å¤–ï¼‰åŠ ä¸Šé€—å·ã€‚
            // ä½¿ç”¨ `?` æˆ– `try!` æ¥è¿”å›é”™è¯¯ã€‚
            if count != 0 { write!(f, ", ")?; }
            write!(f, "{}", v)?;
        }

        // åŠ ä¸Šé…å¯¹ä¸­æ‹¬å·ï¼Œå¹¶è¿”å›ä¸€ä¸ª fmt::Result å€¼ã€‚
        write!(f, "]")
    }

}

```



## é›†åˆ

std::collections ä¸‹æœ‰å››ç§é›†åˆ

- çº¿æ€§åºåˆ—: Vec(å‘é‡), VecDeque (åŒç«¯é˜Ÿåˆ—), LinkedList (é“¾è¡¨)
- æ˜ å°„è¡¨: hashmap(æ— åºå“ˆå¸Œè¡¨), BTreeMap(æœ‰åºå“ˆå¸Œè¡¨)
- é›†åˆ: hashset(æ— åºé›†åˆ), btreeset(æœ‰åºé›†åˆ)
- ä¼˜å…ˆé˜Ÿåˆ—: binaryHeap (äºŒå‰å †)

### Vec åŠ¨æ€æ•°ç»„

```rust

/// å‘é‡ Vec
/// åŠ¨æ€æ•°ç»„, ç±»ä¼¼ javaä¸­çš„ ArrayList
/// 
///Vectoræ•°ç»„å¤©ç”Ÿå°±å¯ä»¥ä½œ ä¸ºå…ˆè¿›åå‡º(FILO)çš„æ ˆç»“æ„ä½¿ç”¨
/// 
//
    println!("Vector -------------------------------");
    //ä¸€ä¸ª vector ä½¿ç”¨ 3 ä¸ªè¯æ¥è¡¨ç¤ºï¼šä¸€ä¸ªæŒ‡å‘æ•°æ®çš„æŒ‡é’ˆï¼Œvector çš„é•¿åº¦ï¼Œè¿˜æœ‰å®ƒçš„å®¹é‡ã€‚æ­¤å®¹é‡æŒ‡æ˜äº†è¦ä¸ºè¿™ä¸ª vector ä¿ç•™å¤šå°‘å†…å­˜ã€‚
    //vector çš„é•¿åº¦ åªè¦å°äºè¯¥å®¹é‡ï¼Œå°±å¯ä»¥éšæ„å¢é•¿ï¼›å½“éœ€è¦è¶…è¿‡è¿™ä¸ªé˜ˆå€¼æ—¶ï¼Œä¼šç»™ vector é‡æ–°åˆ†é…ä¸€æ®µ æ›´å¤§çš„å®¹é‡ã€‚
    // 
    // æ‰©å®¹: è‡ªåŠ¨æŒ‰ç…§ 2 å€æ‰©å®¹
    //
    let vec: Vec<i32> = Vec::new(); // åˆ›å»ºç±»å‹ä¸º i32 çš„ç©ºå‘é‡
    // é¢„åˆ†é… 10 ä¸ªå•ä½
    // çœŸæ­£åˆ†é… çš„å †å†…å­˜ å¤§ å° ç­‰äºæ•°ç»„ä¸­å…ƒç´ ç±»å‹æ‰€å å­—èŠ‚ä¸ç»™å®šå®¹é‡å€¼ ä¹‹ç§¯
    Vee::with capacity(1O)
    let vector = vec![1, 2, 4, 8];     // é€šè¿‡æ•°ç»„å’Œå®åˆ›å»ºå‘é‡ // v: Vec<i32>
    let v = vec![0; 10]; // ten zeroes
    let mut vec_fixed: Vec<_>= (0..10).collect();
    // è·å–
    println!("{:?}, v[0] = {}", vec, vec[0]);//ä¸‹æ ‡å¿…é¡»æ˜¯ usize ç±»å‹

    // vec è½¬æ¢ æ•°ç»„/åˆ‡ç‰‡
    let arr = vec[..];

     // é•¿åº¦
     vec.len();

    // æ·»åŠ , åˆ é™¤
    // ç±»ä¼¼ æ ˆ
    vec.push(6);//å°¾æ’
    vec.push(7);
    if let Some(x) = vec.pop() {// å°¾éƒ¨åˆ é™¤è¿”å›
        println!("popped: {}", x);// 7
    } else {
        println!("None");
    }
    println!("after pop: {:?}", vec); // [6]

    // ä» 0 ä½ç½®å¼€å§‹æ¸…é™¤åˆ°æœ«å°¾, ç­‰åŒæ¸…ç©ºæ•°æ®, ä½†æ˜¯å†…å­˜æ²¡æœ‰é‡Šæ”¾, åªæ˜¯æ“¦é™¤äº†æ•°æ®
    vec . truncate (0);
    // æ¸…ç©º
    vec.clear()
    // é‡Šæ”¾ç©ºé—²å®¹é‡
    vec.shrink_to_fit() //æ–¹æ³•ï¼Œé¢„åˆ†é…çš„å †å†…å­˜è¢«é‡Šæ”¾äº†

    // äº¤æ¢
    v.swap(1, 3);

    // å…¨éƒ¨æ›¿æ¢
    // copy_from_slice æ–¹æ³•å¯ä»¥ä½¿ç”¨ä¸€ä¸ªæ•°ç»„åˆ‡ç‰‡å°†åŸ vec æ•° ç»„ ä¸­çš„å…ƒç´ å…¨éƒ¨æ›¿æ¢, æ•°ç»„åˆ‡ç‰‡å¿…é¡»å’ŒåŸæ•°ç»„ç­‰é•¿, åªæ”¯æŒå®ç° Copy è¯­ä¹‰çš„å…ƒç´ 
    //  clone_from sliceæ–¹æ³•çš„æ•ˆæœå’Œ copy_ä»•om sliceæ˜¯ç­‰ä»·çš„ï¼Œ ä½†å®ƒä»¬çš„åŒºåˆ«æ˜¯ï¼Œ clone from slice æ–¹æ³•æ”¯æŒå®ç° Clone çš„ç±»å‹å…ƒç´ ã€‚

    // æ·»åŠ å¦å¤–çš„ vector
    let mut v2 = vec![100, 101];
    vec.append(&mut v2);
    println!("vec: {:?}", vec);
    println!("v2: {:?}", v2);//v2: []

    // å¤„ç†ä¸‹æ ‡è¶Šç•Œ
    match vec.get(7) { // è¿”å›çš„æ˜¯ Option<T>
        Some(x) => println!("Item 7 is {}", x),
        None => println!("Sorry, this vector is too short.")
    }

    //  containsã€ starts withå’Œ ends with
    

    // è¿­ä»£
    // è¿­ä»£å‡ºçš„æ˜¯å…ƒç´ å¼•ç”¨
    for ele in &vec {
        println!("ä¸å¯å˜å¼•ç”¨: {}", ele);
    }
    // å¯å˜è¿­ä»£
    for ele in &mut vec {
        println!("å¯å˜å¼•ç”¨: {}", ele);
        // æ­¤æ—¶å¯ä»¥ä¿®æ”¹å…ƒç´ 
        *ele *= 10;// ç¬¬ä¸€ä¸ª* è¡¨ç¤ºæ ¹æ®åœ°å€å–å¾—å€¼, ç¬¬äºŒä¸ª*æ˜¯è¿ç®—ç¬¦
    }
    // å¸¦ä¸‹æ ‡è¿­ä»£
    for (i, v) in vec.iter().enumerate() {
        println!("{}: {}", i,v);
    }
    for ele in vec {
        println!("æœ¬ä½“: {}", ele);
    }

    // ç±»å‹æ¨æ–­
    //
    // å› ä¸ºæœ‰ç±»å‹è¯´æ˜ï¼Œç¼–è¯‘å™¨çŸ¥é“ `elem` çš„ç±»å‹æ˜¯ u8ã€‚
    let elem = 5u8;
    // åˆ›å»ºä¸€ä¸ªç©ºå‘é‡ï¼ˆvectorï¼Œå³ä¸å®šé•¿çš„ï¼Œå¯ä»¥å¢é•¿çš„æ•°ç»„ï¼‰ã€‚
    let mut vec = Vec::new();

    vec.push(elem);
    // å•Šå“ˆ èªæ˜ï¼ç°åœ¨ç¼–è¯‘å™¨çŸ¥é“ `vec` æ˜¯ u8 çš„å‘é‡äº†ï¼ˆ`Vec<u8>`ï¼‰ã€‚

    println!("{:?}", vec);
```


### åŒç«¯é˜Ÿåˆ— VecDeque


```rs
// æ˜¯ä¸€ç§ åŒæ—¶å…·æœ‰ é˜Ÿåˆ—(å…ˆè¿›å…ˆå‡º)å’Œæ ˆ (åè¿›å…ˆå‡º)æ€§è´¨çš„æ•°æ® ç»“æ„ ã€‚ åŒç«¯é˜Ÿåˆ—ä¸­çš„å…ƒç´ å¯ ä»¥ä»ä¸¤ç«¯å¼¹å‡ºï¼Œæ’å…¥å’Œåˆ é™¤æ“ä½œè¢«é™å®š åœ¨é˜Ÿåˆ—çš„ä¸¤ç«¯è¿›è¡Œ
// å†…éƒ¨ä¸»è¦ç»´æŠ¤ä¸€ä¸ªç¯å½¢ç¼“å†²åŒº (RingBuffer), ç”±ä¸¤ä¸ªæŒ‡é’ˆå’Œ ä¸€ ä¸ªå¯å¢é•¿æ•°ç»„ç»„æˆ ã€‚ è¿™ä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«ä¸º å¤´æŒ‡é’ˆ( Head Pointer)å’Œå°¾æŒ‡é’ˆ( Tail Pointer)ã€‚ å…¶ä¸­å¤´æŒ‡é’ˆæ°¸è¿œæŒ‡å‘åº”è¯¥å†™å…¥æ•°æ® çš„ä½ç½®ï¼Œè€Œå°¾æŒ‡é’ˆæ°¸ è¿œæŒ‡ å‘å¯ä»¥è¯»å–çš„ç¬¬ä¸€ä¸ªå…ƒç´ 

// ç¼“å†²åŒºæº¢å‡º
// å‡è®¾ç¼“å†²åŒºæ•°ç»„åˆå§‹å¤§å°ä¸º8, ç¯å½¢ ç¼“å†²åŒºä¸ºç©º æ—¶ï¼Œä¸¤ä¸ªæŒ‡é’ˆéƒ½æŒ‡å‘ä½ç½® 0ã€‚å½“æœ‰æ–°å…ƒç´  æ’å…¥æ—¶ï¼Œå¦‚æœ ç›´æ¥æ’å…¥ä½ç½® 0ï¼Œåˆ™å°†ç”¨äºå†™å…¥æ•°æ® çš„ Head æŒ‡é’ˆæŒ‡å‘ä½ç½® 1ï¼Œ è€Œç”¨äºè¯»å–æ•°æ®çš„ Tail æŒ‡é’ˆä¾ æ—§æŒ‡å‘ä½ç½® 0
// å½“æ’å…¥ç¬¬ 8 ä¸ªå…ƒç´ æ—¶ï¼Œ Head å’Œ Tail æŒ‡é’ˆå°†å†æ¬¡é‡å , 
// å¦‚æœè¿™æ—¶ç»§ç»­ç»™ç¼“å†²åŒºæ·»åŠ æ–°å…ƒç´  ï¼Œ é‚£ä¹ˆä½ç½® ã€‚ å¤„çš„æ•°æ®å°†è¢« å…¶ä»–æ•°æ®è¦†ç›–ï¼Œè¿™å°±ä¼šé€ æˆç¼“å†²åŒºæº¢å‡ºæ”»å‡»; ä¸ºäº†é¿å…è¿™ç§æƒ…å†µï¼Œéœ€è¦ç©ºå‡ºä¸€ä¸ªä½ç½®ï¼Œ ä¸èƒ½æ’å…¥å…ƒç´  ï¼Œ è¿™æ ·æ‰å¯ä»¥åŒºåˆ†å¤´å’Œå°¾
// è¦åˆ¤æ–­ç¯å½¢ç¼“å†²åŒºæ˜¯å¦ä¸ºæ»¡çŠ¶æ€ï¼Œå°±å¿…é¡»çœ‹å®¹é‡å’Œå¤§å°çš„å·®æ˜¯å¦ä¸º l
```


### é“¾è¡¨ Linkedlist

å› ä¸ºæ˜¯åŒå‘åˆ—è¡¨ï¼Œ æ‰€ä»¥æä¾›äº† push back å’Œ push front ä¸¤ç±»æ–¹æ³•ï¼Œæ–¹ä¾¿æ“ä½œ æ­¤é“¾è¡¨ã€‚ä¹Ÿæä¾›äº† append æ–¹æ³• ï¼Œ å¯ä»¥ç”¨æ¥è¿æ¥ä¸¤ä¸ªé“¾è¡¨



### hashmap æ— åºå“ˆå¸Œè¡¨


Keyå¿…é¡»æ˜¯å¯å“ˆå¸Œçš„ç±»å‹ï¼Œ Valueå¿…é¡»æ˜¯åœ¨ç¼–è¯‘æœŸå·²çŸ¥å¤§å°çš„ç±»å‹

#### å“ˆå¸Œè¡¨åŸºæœ¬ä½¿ç”¨

```rust

///HashMap çš„é”®å¯ä»¥æ˜¯å¸ƒå°”å‹ã€æ•´å‹ã€å­—ç¬¦ä¸²ï¼Œæˆ–ä»»æ„å®ç°äº† Eq å’Œ Hash trait çš„å…¶ä»–ç±»å‹
///HashMap åœ¨å æ®äº†å¤šä½™ç©ºé—´æ—¶è¿˜å¯ä»¥ç¼©å° è‡ªå·±
/// 
/// 
/// 
fn hash_table() {
    use std::collections::HashMap;
    
    let mut map = HashMap::new();//ä¸ä¼šé¢„åˆ†é…å†… å­˜ã€‚è‹¥å§‹ç»ˆä¸æ·»åŠ å…ƒç´ , ä¼šç¼–è¯‘æŠ¥é”™, ç¼–è¯‘å™¨è®¤ä¸º map æ²¡æœ‰åˆå§‹åŒ–

    HashMap::with_capacity(unit) //åˆ›å»ºå…·æœ‰ä¸€å®šåˆå§‹å®¹é‡çš„ HashMap
    
    // ä» vector æ„é€ 
    let keys = vec!["a", "b"];
    let values = vec![0, 1];
    let m: HashMap<_, _> = keys.iter().zip(values.iter()).collect();
    // å¦ä¸€ç§åˆå§‹åŒ–æ–¹æ³•
    let map: HashMap<char, i32> = vec![
            ('I', 1),
            ('V', 5),
            ('X', 10),
            ('L', 50),
            ('C', 100),
            ('D', 500),
            ('M', 1000),
        ]
        .into_iter()
        .collect();

    // æ’å…¥
    // å¦‚æœè¢«æ’å…¥çš„å€¼ä¸ºæ–°å†…å®¹ï¼Œé‚£ä¹ˆ `HashMap::insert()` è¿”å› `None`ï¼Œ
    // å¦åˆ™è¿”å› `Some(è¢«è¦†ç›–çš„ value)`
    map.insert("color", "red");// æ²¡æœ‰å£°æ˜æ•£åˆ—è¡¨çš„æ³›å‹ï¼Œæ˜¯å› ä¸º Rust çš„è‡ªåŠ¨åˆ¤æ–­ç±»å‹æœºåˆ¶ã€‚
    map.insert("size", "10 m^2");

    //ä¸å­˜åœ¨æ‰æ’å…¥å€¼ red, å¹¶ä¸”è¿”å›è¯¥å€¼çš„å¯å˜å€Ÿç”¨, (ä¸€èˆ¬çš„æ’å…¥åˆ™æ˜¯æœ‰åˆ™è¦†ç›–æ—§çš„å€¼)
    // or_insert_with(FnOnce) ä¼ é€’ä¸€ä¸ªå¯è®¡ç®—çš„é—­åŒ…ä½œä¸ºè¦æ’å…¥çš„å€¼, é—­åŒ…æ²¡æœ‰å‚æ•°
    // key()
    map.entry("color").or_insert("red");// , è¿”å› "red" çš„ &mut T 

    //åˆ é™¤
    map.remove(&("Ashley")); 


    // è·å–
    //
    // æ¥å—ä¸€ä¸ªå¼•ç”¨å¹¶è¿”å› Option<&V>
    let one = map.get(&"color");
    // or
    let one = map["color"]
    println!("one is a Option<&V> ,  {}", *(one.unwrap()));
    // å¯å˜è·å–(ä¿®æ”¹) 
    let mut map = HashMap::new();
    map.insert(1, "a");
    if let Some(x) = map.get_mut(&1) {
        *x = "b";
    }

    // æ˜¯å¦åŒ…å«
    if !book_reviews.contains_key("rust book") {
        println!("find {} times ", book_reviews.len());// é•¿åº¦
    }
    

    // è¿­ä»£
    for p in map.iter() {//è¿­ä»£å…ƒç´ æ˜¯è¡¨ç¤ºé”®å€¼å¯¹çš„å…ƒç»„
        println!("{:?}", p);
    }
    for (k, v) in &map {// å…ƒç´ ä¸º (&'a key, &'a value) å¯¹
        println!("{}, {}", k, v);
    }

    // é€šè¿‡keyså’Œvaluesæ–¹æ³•å¯ä»¥åˆ†åˆ«å•ç‹¬è·å–HashMapä¸­çš„é”®/å€¼çš„è¿­ä»£å™¨
    for key in book_reviews.keys() {
        println!("{}", key);
    }
   for val in book_reviews.values() {
       println!("{}", val);
   }

    // ç»Ÿè®¡å¥å­ä¸­çš„å•è¯ä¸ªæ•°
    let text = "aa bb cc bb";
    let mut counter = HashMap::new();
    for word in text.split_whitespace() {
        let count = counter.entry(word).or_insert(0);// 
        *count += 1;
    }
    for (word, count) in counter {
        println!("{}, {}", word, count);
    }



    // åˆå¹¶å¤šä¸ª HashMap
    // åˆå¹¶ä¸¤ä¸ªæˆ–å¤šä¸ª HashMap, å°½é‡ä½¿ç”¨ extendæˆ–å…¶ä»–è¿­ä»£å™¨é€‚é…å™¨æ–¹å¼ï¼Œ è€Œä¸è¦ç”¨ forå¾ªç¯æ¥æ’å…¥ ,å¦åˆ™ä¼šå¸¦æ¥æ€§èƒ½ é—®é¢˜
    map1.extend(map2);//æœ¬è´¨ä¸Šï¼Œ åœ¨ extendæ–¹æ³•å†…éƒ¨ä¹Ÿå°† HashMapè½¬æ¢ä¸ºæ³•ä»£å™¨è¿›è¡Œæ“ä½œ
    map1.into_iter().chain(map2).collect()//åŒæ ·æ˜¯é€šè¿‡ into_iterå¾—åˆ° Chainè¿­ä»£å™¨ ç„¶åæ“ä½œ
    // è¢«æ·»åŠ çš„ map_ref æ˜¯ä¸ªå¼•ç”¨, åŸå§‹ map ä¸ä¼šä¸¢å¤±æ‰€æœ‰æƒ
    map1.extend(
        map_ref.into_iter()
            .map(|(k, v)| (k.clone(), v.clone()))
   );




```


#### å¤åˆç±»å‹ä½œä¸º key



```rust
    // åŸºç¡€ç±»å‹çš„ æµ®ç‚¹æ•°, æ— æ³•ä½œä¸º key

    // å¤æ‚ç±»å‹ä½œä¸ºé”® key, å¿…é¡»å®ç° Hashå’ŒEq trait
    //
    //f32 å’Œ f64 æ²¡æœ‰å®ç° Hashï¼Œè¿™å¾ˆå¤§ç¨‹åº¦ä¸Šæ˜¯ç”±äºè‹¥ä½¿ç”¨æµ®ç‚¹æ•°ä½œä¸º æ•£åˆ—è¡¨çš„é”®ï¼Œæµ®ç‚¹ç²¾åº¦è¯¯å·®ä¼šå¾ˆå®¹æ˜“å¯¼è‡´é”™è¯¯
    //
    //å¯¹äºæ‰€æœ‰çš„é›†åˆç±»ï¼ˆcollection classï¼‰ï¼Œå¦‚æœå®ƒä»¬åŒ…å«çš„ç±»å‹éƒ½åˆ†åˆ«å®ç°äº† Eq å’Œ Hashï¼Œ
    //é‚£ä¹ˆè¿™äº›é›†åˆç±»ä¹Ÿå°±å®ç°äº† Eq å’Œ Hashã€‚ä¾‹å¦‚ï¼Œè‹¥ T å®ç°äº† Hashï¼Œåˆ™ Vec<T> ä¹Ÿå®ç°äº† Hash
    //
    //è‡ªå®šä¹‰ç±»å‹å¯ä»¥è½»æ¾åœ°å®ç° Eq å’Œ Hashï¼Œåªéœ€åŠ ä¸Šä¸€è¡Œä»£ç ï¼š#[derive(PartialEq, Eq, Hash)]
    //
    // Eq è¦æ±‚ä½ å¯¹æ­¤ç±»å‹æ¨å¯¼ PartiaEqã€‚
    #[derive(PartialEq, Eq, Hash)]
    struct Account<'a>{
        username: &'a str,
        password: &'a str,
    }
    struct AccountInfo<'a>{
        name: &'a str,
        email: &'a str,
    }
    type Accounts<'a> = HashMap<Account<'a>, AccountInfo<'a>>;
    fn try_logon<'a>(accounts: &Accounts<'a>,
            username: &'a str, password: &'a str){
        println!("Username: {}", username);
        println!("Password: {}", password);
        println!("Attempting logon...");

        let logon = Account {
            username: username,
            password: password,
        };

        match accounts.get(&logon) {
            Some(account_info) => {
                println!("Successful logon!");
                println!("Name: {}", account_info.name);
                println!("Email: {}", account_info.email);
            },
            _ => println!("Login failed!"),
        }
    }



    

}

```

#### å“ˆå¸Œç¢°æ’æ”»å‡»

map åº•å±‚ä½¿ç”¨æ•°ç»„å­˜å‚¨æ•°æ®, éœ€è¦ä¸€ä¸ªé«˜æ•ˆçš„ hash å‡½æ•°å‡åŒ€çš„å°†å…ƒç´ åˆ†æ•£å­˜å‚¨åœ¨ æ•°ç»„ä¸­ 

è´Ÿè½½å› å­: å½“å‰çš„é»˜è®¤æ‰©å®¹ç­–ç•¥ ä¸ºè´Ÿè½½å› å­è¾¾åˆ° 0.9 æ—¶åˆ™è¿›è¡Œæ‰©å®¹

Rustæ ‡å‡†åº“å®ç°çš„ HashMapï¼Œ é»˜è®¤çš„ Hash å‡½æ•°ç®—æ³•æ˜¯ SipHashl3o å¦å¤–ï¼Œæ ‡å‡†åº“è¿˜å®ç° äº† SipHash24, SipHashç®—æ³•å¯ä»¥é˜²æ­¢ Hashç¢°æ’æ‹’ç»æœåŠ¡æ”»å‡»(Hash Collision DoS)ï¼Œè¿™ç§
æ”»å‡»æ˜¯ä¸€ç§åŸºäºå„è¯­è¨€ Hash ç®—æ³•çš„éšæœºæ€§è€Œç²¾å¿ƒæ„é€ å‡ºæ¥çš„å¢å¼º Hashç¢°æ’çš„æ‰‹æ®µï¼Œè¢«æ”»å‡» çš„æœåŠ¡å™¨ CPU å ç”¨ç‡ä¼šè½»æ¾åœ°åˆ¶å‡åˆ° 100%



å¦‚ä½•è§£å†³å“ˆå¸Œç¢°æ’?

- å¤–éƒ¨æ‹‰é“¾æ³•: åœ¨æ•°ç»„çš„æ¯ä¸ªå…ƒç´ ä½ç½®, é‡åˆ°ç¢°æ’å, ç”Ÿé•¿å‡ºä¸€ä¸ªé“¾è¡¨, ä½†æ˜¯æœ‰é€€åŒ–åˆ°å•é“¾è¡¨çš„é£é™©
- å¼€æ”¾å®šå€æ³•: åœ¨å‘ç”Ÿå†²çªæ—¶ç›´æ¥å»å¯»æ‰¾ä¸‹ä¸€ä¸ªç©ºçš„åœ°å€, å¼€æ”¾å®šå€æ³•çš„ä¼˜ç‚¹åœ¨äºè®¡ç®—ç®€å•ã€å¿«æ·ï¼Œå¤„ç†æ–¹ä¾¿:ç¼ºç‚¹æ˜¯å®ƒä¼š äº§ç”Ÿèšé›† ç°è±¡ï¼Œå¹¶ä¸”åˆ é™¤å…ƒ ç´ ä¹Ÿä¼šå˜å¾—ååˆ†å¤æ‚(å› ä¸ºå¹¶ä¸èƒ½çœŸçš„åˆ é™¤ï¼Œ å¦åˆ™ä¼šç ´åå¯»å€çš„æ­£ç¡®æ€§)
    å¯»æ‰¾ä¸‹ä¸€ä¸ªç©ºåœ°å€çš„è¡Œä¸ºï¼Œå«ä½œæ¢æµ‹ (Probe)ã€‚ä¾æ¬¡ ä¸€ ä¸ªä¸ªåœ° å¯»æ‰¾ å«ä½œ ç»­æ€§æ¢æµ‹( Linear Probing), rust é‡‡ç”¨è¿™ç§

>åœ¨çº¿æ€§æ¢æµ‹æ—¶ï¼Œå¦‚æœé‡åˆ°ç©ºæ¡¶ï¼Œ åˆ™æ­£å¸¸æ’å…¥; å¦‚æœé‡åˆ°æ¡¶å·± ç»è¢«å ç”¨ ï¼Œé‚£ä¹ˆ å°±è¦çœ‹å ç”¨è¿™ä¸ªæ¡¶çš„é”®å€¼å¯¹æ˜¯ç»å† è¿‡å‡ æ¬¡ æ¢æµ‹æ‰è¢«æ’å…¥è¯¥ä½ç½® çš„ï¼Œ å¦‚æœè¯¥é”®å€¼å¯¹çš„æ¢æµ‹æ¬¡æ•°æ¯”å½“å‰å¾…æ’å…¥çš„é”®å€¼å¯¹çš„æ¢æµ‹æ¬¡æ•°å°‘ï¼Œåˆ™å®ƒå±äºâ€œå¯Œç¿â€ï¼Œ å°±æŠŠå½“å‰çš„é”®å€¼å¯¹æ’å…¥è¯¥ä½ç½®ï¼Œå†æ¥ç€æ‰¾ä¸‹ä¸€ä¸ªä½ç½®æ¥å®‰ç½®è¢«æ›¿æ¢çš„â€œå¯Œç¿â€é”®å€¼å¯¹ã€‚ æ­£æ˜¯å›  ä¸ºè¿™ç§â€œåŠ« å¯Œæµè´« â€çš„æ€è·¯ï¼Œè¿™ç§ ç®—æ³•æ‰è¢«ç§° ä¸ºç½— å®¾æ±‰ç®—æ³•ã€‚



### BTreeMap æœ‰åºå“ˆå¸Œè¡¨

åŸºäº B æ ‘çš„æœ‰åºæ˜ å°„é›†å®ç°ï¼ŒæŒ‰ Key æ’åº


### hashset æ— åºé›†åˆ





```rust

// HashSet<K> BTreeSet<K>å…¶å®å°±æ˜¯ HashMap<K, V>å’Œ BTrå·³eMap<K, V>æŠŠ Value è®¾ç½® ä¸ºç©ºå…ƒç»„çš„ç‰¹å®šç±»å‹ï¼Œç­‰ä»·äº HashSet<K, ()>å’Œ BTreeSet<K, ()>


//
    //æ•£åˆ—é›† HashSet
    //
    //unionï¼ˆå¹¶é›†ï¼‰ï¼šè·å¾—ä¸¤ä¸ªé›†åˆä¸­çš„æ‰€æœ‰å…ƒç´ ï¼ˆä¸å«é‡å¤å€¼ï¼‰ã€‚
    // differenceï¼ˆå·®é›†ï¼‰ï¼šè·å–å±äºç¬¬ä¸€ä¸ªé›†åˆè€Œä¸å±äºç¬¬äºŒé›†åˆçš„æ‰€æœ‰å…ƒç´ ã€‚
    // intersectionï¼ˆäº¤é›†ï¼‰ï¼šè·å–åŒæ—¶å±äºä¸¤ä¸ªé›†åˆçš„æ‰€æœ‰å…ƒç´ ã€‚
    // symmetric_differenceï¼ˆå¯¹ç§°å·®ï¼‰ï¼šè·å–æ‰€æœ‰åªå±äºå…¶ä¸­ä¸€ä¸ªé›†åˆï¼Œè€Œä¸åŒæ—¶å±äº ä¸¤ä¸ªé›†åˆçš„æ‰€æœ‰å…ƒç´ ã€‚
    //
    use std::collections::HashSet;
    let mut a: HashSet<i32> = vec!(1i32, 2, 3).into_iter().collect();
    let mut b: HashSet<i32> = vec!(2i32, 3, 4).into_iter().collect();
    a.insert(4); // å¦‚æœå€¼å·²ç»å­˜åœ¨ï¼Œé‚£ä¹ˆ `HashSet::insert()` è¿”å› false
    a.contains(&4);//æ˜¯å¦å­˜åœ¨
    //å¹¶é›†
    let c = a.union(&b).collect::<Vec<&i32>>();

```


### BTreeSet æœ‰åºé›†åˆ



### ä¼˜å…ˆé˜Ÿåˆ— BinaryHeap

ä½¿ç”¨ peekæ–¹æ³•å¯ä»¥ å–å‡ºå †ä¸­çš„æœ€å¤§å€¼





## ç±»å‹è½¬æ¢


### åŸºæœ¬çš„ç±»å‹è½¬æ¢


```rust


    // ç±»å‹è½¬æ¢
    //
    //Rust ä¸æä¾›åŸç”Ÿç±»å‹ä¹‹é—´çš„éšå¼ç±»å‹è½¬æ¢ï¼ˆcoercionï¼‰ï¼Œä½†å¯ä»¥ä½¿ç”¨ as å…³é”®å­—è¿›è¡Œæ˜¾ å¼ç±»å‹è½¬æ¢ï¼ˆcastingï¼‰
    //
    println!("------ç±»å‹è½¬æ¢--------------------------");
    let decimal = 65.4321_f32; // é€šè¿‡å­—é¢é‡ç›´æ¥å£°æ˜ç±»å‹

    // é”™è¯¯ï¼ä¸æä¾›éšå¼è½¬æ¢
    let integer: u8 = decimal;
     // å¯ä»¥æ˜¾å¼è½¬æ¢
    let integer = decimal as u8;
    let character = integer as char;



```




### è½¬æ¢ç›¸å…³çš„ trait

```rust

//
//
// å…¶ä»–è½¬æ¢ç›¸å…³çš„ trait
//
//fromå’Œinto æ–¹æ³•æ˜¯ä¸€å¯¹ï¼Œå®ç°äº†From traitå°±ä¼šè‡ªåŠ¨åè¿‡æ¥å®ç°Into
// - std::convert::From æ¥å£å®šä¹‰ â€œæ€ä¹ˆæ ¹æ®å¦ä¸€ç§ç±»å‹ç”Ÿæˆè‡ªå·±â€
// - Into trait å°±æ˜¯æŠŠ From trait å€’è¿‡æ¥è€Œå·²; ä½¿ç”¨ Into trait é€šå¸¸è¦æ±‚æŒ‡æ˜è¦è½¬æ¢åˆ°çš„ç±»å‹
//
//- TryFrom and TryInto trait ç”¨äºæ˜“å‡ºé”™çš„è½¬æ¢ï¼Œä¹Ÿæ­£å› å¦‚æ­¤ï¼Œå…¶è¿”å›å€¼æ˜¯ Result 
//
//- ToString trait è¦æŠŠä»»ä½•ç±»å‹è½¬æ¢æˆ Stringï¼Œåªéœ€è¦å®ç° to_string æ–¹æ³•ã€‚
//ç„¶è€Œä¸è¦ç›´æ¥è¿™ä¹ˆåšï¼Œåº”è¯¥å®ç°fmt::Display traitï¼Œå®ƒä¼šè‡ªåŠ¨æä¾› ToStringï¼Œå¹¶ä¸”è¿˜å¯ä»¥ç”¨æ¥æ‰“å°ç±»å‹
//-  å¯¹åº”çš„æœ‰ FromStr, åªè¦å¯¹ç›®æ ‡ç±»å‹å®ç°äº† FromStr traitï¼Œå°±å¯ä»¥ç”¨ parse æŠŠå­—ç¬¦ä¸²è½¬æ¢æˆç›®æ ‡ç±»å‹
//
use std::convert::From;
#[derive(Debug)]
struct Number {
    value: i32,
}
impl From<i32> for Number {
    fn from(item: i32) -> Self {
        Number { value: item }
    }
}
let num = Number::from(30);
println!("My number is {:?}", num);
let int = 5;
let num: Number = int.into();// num ç±»å‹å¿…é¡»æŒ‡å®š
println!("My number is {:?}", num);



```



## æ‰€æœ‰æƒ


### ä¸ºä»€ä¹ˆéœ€è¦æ‰€æœ‰æƒ RAIIæœºåˆ¶

æ‰€æœ‰æƒæ˜¯å¯¹å †å†…å­˜ä¸Šçš„æ•°æ®æ¥è¯´çš„, æ‰€æœ‰æƒä¸ºæ¯ä¸ªæ•°æ®è§„å®šäº†ä¸»äºº, é¿å…äº†æ•°æ®ç«äº‰, åŒæ—¶ä¹Ÿèƒ½å‡å°‘bug. 

æ ˆå†…å­˜ä¸­å˜é‡çš„ç”Ÿå‘½å‘¨æœŸæ˜¯çŸ­æš‚çš„, éšç€æ–¹æ³•è°ƒç”¨çš„ç»“æŸè€Œæ¸…ç†, å †å†…å­˜çš„å˜é‡è™½ç„¶å¯ä»¥é•¿ä¹…å­˜åœ¨, ä½†æ˜¯éçº¿ç¨‹ç§æœ‰, å…¶å†…éƒ¨çš„æ•°æ®éœ€è¦é€šè¿‡æ ˆå†…å­˜ä¸­çš„æŒ‡é’ˆæ¥ä½¿ç”¨

æŒ‡é’ˆåœ¨å †ä¸Šå¼€è¾Ÿå†…å­˜ ç©º é—´ï¼Œå¹¶æ‹¥æœ‰å…¶æ‰€æœ‰æƒï¼Œé€šè¿‡å­˜å‚¨äºstackä¸­çš„æŒ‡é’ˆæ¥ç®¡ç†å †å†…å­˜ , æ™ºèƒ½æŒ‡é’ˆçš„ RAII æœºåˆ¶åˆ©ç”¨stackçš„ç‰¹ç‚¹ï¼Œåœ¨å…ƒç´ è¢«è‡ªåŠ¨æ¸…ç©ºæ—¶è‡ªåŠ¨è°ƒç”¨ææ„å‡½æ•°ï¼Œæ¥é‡Šæ”¾æ™º èƒ½æŒ‡é’ˆæ‰€ç®¡ç†çš„å †å†…å­˜ ç©ºé—´


### åŸºæœ¬åŸåˆ™

```rust
// æ¯ç§ç¼–ç¨‹è¯­è¨€éƒ½æœ‰è‡ªå·±çš„ä¸€å¥—å†…å­˜ç®¡ç†çš„æ–¹æ³•ã€‚
//æœ‰äº›éœ€è¦æ˜¾å¼çš„åˆ†é…å’Œå›æ”¶å†…å­˜ï¼ˆå¦‚Cï¼‰ï¼Œ
// æœ‰äº›è¯­è¨€åˆ™ä¾èµ–äºåƒåœ¾å›æ”¶å™¨æ¥å›æ”¶ä¸ä½¿ç”¨çš„å†…å­˜ï¼ˆå¦‚Javaï¼‰ã€‚
// è€ŒRustä¸å±äºä»¥ä¸Šä»»ä½•ä¸€ç§ï¼Œå®ƒæœ‰ä¸€å¥—è‡ªå·±çš„å†…å­˜ç®¡ç†è§„åˆ™ï¼Œå«åšOwnershipã€‚
//
// //
// 1. åœ¨Rustä¸­ï¼Œæ¯ä¸€ä¸ªå€¼éƒ½æœ‰å¯¹åº”çš„å˜é‡ï¼Œè¿™ä¸ªå˜é‡ç§°ä¸ºå€¼çš„owner
// 
// 2. ä¸€ä¸ªå€¼åœ¨æŸä¸€æ—¶åˆ»åªèƒ½æœ‰ä¸€ä¸ªowner (åœ¨ä»»æ„ç»™å®šæ—¶åˆ»ï¼ŒæŸä¸ªå€¼åªèƒ½å­˜åœ¨ä¸€ä¸ªå¯å˜å¼•ç”¨æˆ–ä»»æ„æ•°é‡çš„ä¸å¯å˜å¼•ç”¨ )
//          ä¾‹å¦‚ , let a = 11, let b = Person {}; func(a, b); 
 //           å› ä¸ºå‡½æ•°è°ƒç”¨åº•å±‚å®é™…æ˜¯ å°† a, b èµ‹å€¼ç»™ å‡½æ•°æ ˆä¸­çš„ä¸´æ—¶å˜é‡, é€ æˆ a, b çš„æ‰€æœ‰æƒè½¬ç§»
//            å¯¹äº åŸºæœ¬ç±»å‹ a, å®ç°äº† copy trait, æ‰€æœ‰æƒè½¬ç§»çš„æ•ˆæœæ˜¯ å¤åˆ¶, a ä»ç„¶èƒ½ç»§ç»­ä½¿ç”¨
//            å¯¹äº ç¬¦åˆç±»å‹b, æ²¡æœ‰ copy trait, æ‰€æœ‰æƒè½¬ç§»å, b å°±å¤±æ•ˆäº†
//            
// 3. å½“ownerè¶…å‡ºä½œç”¨åŸŸåï¼Œå€¼ä¼šè¢«é”€æ¯


///å¯¹äºå †ä¸­çš„å†…å­˜, rustæ²¡æœ‰ç±»ä¼¼ c ä¸­ free() çš„èµ„æºé‡Šæ”¾å‡½æ•°
///rustç¼–è¯‘å™¨ä¼šåœ¨å˜é‡è¶…å‡ºå…¶ä½œç”¨åŸŸå, è‡ªåŠ¨æ·»åŠ è°ƒç”¨é‡Šæ”¾èµ„æºå‡½æ•°çš„æ­¥éª¤, æ¸…ç†å¯¹åº”çš„å †å†…å­˜
///
///


// ç¼–å†™ä»£ç éœ€è¦éµå¾ªçš„è§„åˆ™:
// 
// åœ¨ä¸å¯å˜å€Ÿç”¨æœŸé—´ï¼Œæ‰€æœ‰è€…ä¸èƒ½ä¿®æ”¹èµ„æºï¼Œå¹¶ä¸”ä¹Ÿä¸èƒ½å†è¿›è¡Œå¯å˜å€Ÿç”¨
// åœ¨å¯å˜å€Ÿç”¨æœŸé—´ï¼Œæ‰€æœ‰è€…ä¸èƒ½è®¿é—®èµ„æºï¼Œå¹¶ä¸”ä¹Ÿä¸èƒ½å†å‡ºå€Ÿæ‰€æœ‰æƒ


```

### å­—ç¬¦ä¸²èµ‹å€¼çš„æ‰€æœ‰æƒ


```rust
fn ownership() {
    // å¯¹äº basic type, æ•°æ®çš„äº’åŠ¨éƒ½å‘ç”Ÿåœ¨æ ˆä¸Š, å¤§å°å·²ç»ç¡®å®š, å¤åˆ¶èµ·æ¥å¾ˆå¿«, æ‰€ä»¥é‡‡ç”¨çš„æ˜¯å¤åˆ¶å…‹éš†
    let x = 5;
    let y = x; // ç°åœ¨æ ˆä¸­å°†æœ‰ä¸¤ä¸ªå€¼ 5
    println!("{}, {}", x, y);// éƒ½æœ‰æ•ˆ

    //äº§ç”Ÿä¸€ä¸ª String å¯¹è±¡ï¼Œå€¼ä¸º "hello"ã€‚é•¿åº¦å¯å˜, éœ€è¦åœ¨å †ä¸­å­˜å‚¨
    // s1 å­˜å‚¨åœ¨æ ˆ, ç»“æ„ä¸­åŒ…å«ä¸€ä¸ª ptr, æŒ‡å‘å †ä¸­çš„String å­—ç¬¦åºåˆ—
    let s1 = String::from("hello");
    let s2 = s1;// æ‹·è´ s1  æœ¬èº«ç»™ s2, å †ä¸­çš„æ•°æ®è¿˜æ˜¯åŒä¸€ä»½
    //
    // æ­¤æ—¶, s1å·²ç»å¤±æ•ˆäº†, è¡¨ç°çš„åƒ s1 ç§»åŠ¨åˆ° s2
    //ä¸ºä»€ä¹ˆrustè§„å®šæ­¤æ—¶ s1å¤±æ•ˆ?  å› ä¸ºå¦‚æœç¨‹åºåœ¨è¿™é‡Œç»“æŸ,  s1 å’Œ s2 éƒ½è¢«é‡Šæ”¾çš„è¯å †åŒºä¸­çš„ "hello" è¢«é‡Šæ”¾ä¸¤æ¬¡ï¼Œä¼šå‡ºé”™
    // ä¸ºäº†ç¡®ä¿å®‰å…¨ï¼Œåœ¨ç»™ s2 èµ‹å€¼æ—¶ s1 å·²ç»æ— æ•ˆäº†
    println!("s2 = {}", s2);
    println!("s1 = {}", s1); // é”™è¯¯

    // å¤åˆ¶å…‹éš†å †ä¸­çš„å¯¹è±¡
    let s1 = String::from("hello");
    let s2 = s1.clone();
    // æ­¤æ—¶, s1 s2 éƒ½æœ‰æ•ˆ
    println!("s1 = {}, s2 = {}", s1, s2);

```

### å‡½æ•°å‚æ•°çš„æ‰€æœ‰æƒ

```rust

    //
    // å‡½æ•° å‚æ•°çš„æ‰€æœ‰æƒæœºåˆ¶
    //
    //å¦‚æœå°†å˜é‡å½“ä½œå‚æ•°ä¼ å…¥å‡½æ•°ï¼Œé‚£ä¹ˆå®ƒå’Œç§»åŠ¨çš„æ•ˆæœæ˜¯ä¸€æ ·çš„ (å‡½æ•°å¤–éƒ¨çš„å˜é‡å¤±æ•ˆ)
    let s = String::from("nihao");
    let a = 11;
    fn fn_basic_type(a: i32) {
        println!("a = {}", a);
    } // å‡½æ•°ç»“æŸ, aåŸºæœ¬ç±»å‹, èµ„æºæ— éœ€é‡Šæ”¾
    fn fn_str_type(s: String) {
        println!("s = {}", s);
    } // å‡½æ•°ç»“æŸ, s èµ„æºè¢«é‡Šæ”¾

    // s è¢«ä½œä¸ºå‚æ•°ä¼ é€’åˆ°å‡½æ•°å†…, å½¢å‚æŒ‡å‘ Stringå¯¹è±¡, é‚£ä¹ˆå‰é¢çš„ s å¤±æ•ˆ
    //ç›¸å½“äºæ•°æ®è¢«ç§»åŠ¨äº†
    fn_str_type(s);
    // æ‰€ä»¥è¿™é‡Œ s æ— æ•ˆäº†
    println!(s);//error

    // a æ˜¯åŸºæœ¬ç±»å‹, å®ç°äº† copy trait, ä¼ é€’æ—¶æ˜¯ copy,
    fn_basic_type(a);
    // æ‰€ä»¥, æ­¤æ—¶ a ä»ç„¶æœ‰æ•ˆ
    println!("a = {}", a);


```

### å‡½æ•°è¿”å›å€¼æ‰€æœ‰æƒ

```rust


    //
    // å‡½æ•°è¿”å›å€¼çš„æ‰€æœ‰æƒ
    //
    //å‡½æ•°è¿”å›å€¼çš„å˜é‡æ‰€æœ‰æƒå°†ä¼šè¢«ç§»åŠ¨å‡ºå‡½æ•°å¹¶è¿”å›åˆ°è°ƒç”¨å‡½æ•°çš„åœ°æ–¹ï¼Œ
    //è€Œä¸ä¼šç›´æ¥è¢«æ— æ•ˆé‡Šæ”¾ã€‚
    fn return_str() -> String {
        let s = String::from("hello");
        return s;
    }
    fn give_and_return_str(s: String) -> String {
        s
    }
    let s1 = return_str(); // å‡½æ•°å°†å†…éƒ¨è¿”å›å€¼ç§»åŠ¨åˆ° s1
    let s2 = String::from("hello");
    let s3 = give_and_return_str(s2); // s2 è¢«ç§»åŠ¨å¤±æ•ˆ


```


### å¤åˆç±»å‹ä¸­çš„æ‰€æœ‰æƒ

```rust

// æ‰€æœ‰æƒæœºåˆ¶ä¼šå¸¦æ¥å¤æ‚æ€§
    //
    #[derive(Debug)]
    struct Person {
        name: String,
        email: String,
    }
    let mut p = Person {
        name: "xiaoyu".to_owned(),
        email: "775000738@qq.com".to_owned(),
    };

    let _name = p.name;// property "name" was been removed out of p
    println!("{:?}", p); // ç¼–è¯‘å‡ºé”™ "value borrowed here after partial move" , å±æ€§ name ä¸º string, æ²¡æœ‰ copy trait, è¢« move æ‰å, å€¼å°±ä¸º ç©ºäº†
    p.name = "xy".to_owned(); // é‡æ–°èµ‹å€¼
    println!("{:?}", p); // è¿™æ—¶ä¸ä¼šæŠ¥é”™äº†

    // æ¨¡æ‹ŸåŠ¨ç”»æ¸²æŸ“ç¤ºä¾‹
    struct Buffer {
        buf: String,
    }
    struct Render {
        current: Buffer,
        next: Buffer,
    }
    impl Render {
        fn update_buffer(&mut self, buf: String) {
            // ç¼–è¯‘é”™è¯¯, next æ²¡æœ‰å®ç° copy trait, è¢« move æ‰å, å°±ä¸º ç©ºäº†,
            //ä¸€ä¸ªå¯é€‰æ–¹æ¡ˆæ˜¯å®ç° copy trait, ä½†æ˜¯è¿™æ ·å°±æ²¡æ³•äº«å—æ–¹ä¾¿çš„ move è¯­ä¹‰äº†
            //
            self.current = self.next;
            self.next = Buffer {buf,};

            // è§£å†³:
            //éœ€è¦åŠ¨ç”¨ std::mem::replace(&dest, src) å‡½æ•°äº†ï¼Œ è¿™ä¸ªå‡½æ•°æŠŠ src çš„å€¼ move åˆ° dest ä¸­ï¼Œç„¶åæŠŠ dest å†è¿”å›å‡ºæ¥
            self.current = std::mem::replace(&mut self.next, Buffer {buf});
        }
    }
}


```

### å¤šæ‰€æœ‰æƒ

éœ€è¦ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆ

```rust
     

fn multi_ownership() {
    


    

    }
}


```

## ç”Ÿå‘½å‘¨æœŸå‚æ•°

### ä»€ä¹ˆæ˜¯ç”Ÿå‘½å‘¨æœŸ

```rs
let a = "hello";//letç»‘å®šäº†æ ‡è¯†ç¬¦ aå’Œå­˜ å‚¨å­—ç¬¦ä¸²çš„é‚£å—å†…å­˜ï¼Œä»è€Œ aå¯¹é‚£å—å†…å­˜æ‹¥æœ‰äº†æ‰€æœ‰æƒ, a ä¹Ÿå¯ç§°ä¸ºä¸€ä¸ªç»‘å®š
let b = a; // a çš„æ‰€æœ‰æƒè¢«è½¬ç»™b (a ä¸º &strç±»å‹, æ— æ³•å®ç° copy trait); å…¶å®ä¹Ÿå¯ä»¥ç†è§£ä¸ºå¯¹ aè¿›è¡Œè§£ç»‘ï¼Œç„¶åé‡æ–°ç»‘å®šç»™ bã€‚

// ç»‘å®šå…·æœ‰æ—¶æ•ˆæ€§ï¼Œä¹Ÿå°±æ˜¯æŒ‡å®ƒçš„ç”Ÿå­˜å‘¨æœŸ
```


### ä¸ºä»€ä¹ˆå­˜åœ¨ç”Ÿå‘½å‘¨æœŸæ³¨é‡Š

å› ä¸ºå­˜åœ¨ç”Ÿå‘½å‘¨æœŸæ£€æŸ¥, ç”Ÿå‘½å‘¨æœŸæ³¨é‡Šæ˜¯ç”¨æ¥æ–¹ä¾¿ç¼–è¯‘å™¨è¿›è¡Œç”Ÿå‘½å‘¨æœŸæ£€æŸ¥çš„ , å¹¶ä¸èƒ½æ”¹å˜ä»»ä½•å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸé•¿çŸ­

ä¸ºä»€ä¹ˆè¦ç”Ÿå‘½å‘¨æœŸæ£€æŸ¥? å› ä¸ºå­˜åœ¨å¼•ç”¨, å› ä¸ºè¦ä¿è¯å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸä¸èƒ½é•¿äºå‡ºå€Ÿæ–¹çš„ç”Ÿå‘½å‘¨æœŸ(é˜²æ­¢å‚æ‚¬å¼•ç”¨), æœ‰å¼•ç”¨å°±ä¼šæœ‰ç”Ÿå‘½å‘¨æœŸæ£€æŸ¥ 

ä¸ºä»€éœ€è¦å¼•ç”¨å‘¢? å¤åˆç±»å‹å¦‚æœå…‹éš†çš„è¯, ä¼šæœ‰æ€§èƒ½é—®é¢˜, è¿™ç§æƒ…å†µ, åªèƒ½ä¼ é€’å¼•ç”¨äº†.

>æ€»ç»“ä¸€ä¸‹å°±æ˜¯: å‡½æ•°å‚æ•°å¯ ä»¥æŒ‰å€¼ä¼ é€’ï¼Œ ä¹Ÿå¯ä»¥æŒ‰ å¼• ç”¨ä¼ é€’ã€‚å½“å‚æ•°æŒ‰å€¼ ä¼ é€’è‚˜ ï¼Œ ä¼šè½¬ç§»æ‰€æœ‰æƒæˆ–è€…æ‰§è¡Œå¤åˆ¶( Copy)è¯­ä¹‰ã€‚å½“å‚æ•°æŒ‰å¼•ç”¨ä¼ é€’ æ—¶ï¼Œ æ‰€æœ‰æƒä¸ä¼šå‘ç”Ÿ å˜åŒ– ï¼Œä½†æ˜¯éœ€è¦æœ‰ç”Ÿå‘½å‘¨æœŸå‚æ•° ã€‚å½“ ç¬¦åˆç”Ÿå‘½å‘¨æœŸå‚æ•°çœç•¥è§„ åˆ™æ—¶ï¼Œ ç¼–è¯‘å™¨å¯ ä»¥é€šè¿‡è‡ªåŠ¨å‡† æ–­è¡¥é½å‡½æ•°å‚æ•°çš„ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œå¦åˆ™ï¼Œéœ€è¦æ˜¾å¼åœ°ä¸ºå‚æ•°æ ‡æ˜ç”Ÿå‘½å‘¨æœŸå‚æ•°


```rust
/// ç”Ÿå‘½å‘¨æœŸæ³¨é‡Š: ç”¨æ¥æ ‡æ³¨å¤šä¸ªå˜é‡é—´ç”Ÿå‘½å‘¨æœŸçš„å…³ç³», æ¯”å¦‚ç”Ÿå‘½å‘¨æœŸæ˜¯å¦ä¸€æ ·é•¿
/// 
/// ç›®çš„: é¿å…å‚æ‚¬å¼•ç”¨
/// 
/// ç”Ÿå‘½å‘¨æœŸæ³¨é‡Šå¹¶ä¸æ”¹å˜ä»»ä½•å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸçš„é•¿çŸ­
/// å•ä¸ªçš„ç”Ÿå‘½å‘¨æœŸæ³¨è§£æœ¬èº«æ²¡æœ‰å¤šå°‘æ„ä¹‰ï¼Œå› ä¸ºç”Ÿå‘½å‘¨æœŸæ³¨è§£å‘Šè¯‰ Rust å¤šä¸ªå¼•ç”¨çš„æ³›å‹ç”Ÿå‘½å‘¨æœŸå‚æ•°å¦‚ä½•ç›¸äº’è”ç³»çš„
/// 
/// å¤§éƒ¨åˆ†æƒ…å†µ, ç”Ÿå‘½å‘¨æœŸéƒ½æ˜¯å¯ä»¥è‡ªåŠ¨æ¨æ–­çš„, å°±åƒç±»å‹æ¨æ–­ , æ²¡æ³•æ¨æ–­æ—¶, å°±éœ€è¦æ‰‹åŠ¨æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸæ³¨é‡Šäº†
// 
// è¯­æ³•: 
// &â€™a i32
// &'a mut i32 
/// 
/// 
fn life_cycle() {
    // çœ‹ä¸€ä¸ªæœ‰é—®é¢˜çš„ä¾‹å­:
    let a;
    {
        let x = 1;
        a = &x; // é”™è¯¯, `x` does not live long enough, å‡ºäº†x ä½œç”¨åŸŸ, a å¯¹ x çš„å€Ÿç”¨å°±å¤±æ•ˆäº†
    }
    println!("{}", a);// æ­¤æ—¶ a å˜ä¸ºå‚æ‚¬å¼•ç”¨

    &i32        // å¸¸è§„å¼•ç”¨
    &'a i32     // å«æœ‰ç”Ÿå‘½å‘¨æœŸæ³¨é‡Šçš„å¼•ç”¨
    &'a mut i32 // å¯å˜å‹å«æœ‰ç”Ÿå‘½å‘¨æœŸæ³¨é‡Šçš„å¼•ç”¨
    //

    // åªæœ‰ä¸€ä¸ªå‚æ•°å¹¶ä¸”ç›´æ¥è¿”å›çš„ä¾‹å­
    // å› ä¸ºç¼–è¯‘å™¨å¯ä»¥è‡ªå·±æ¨å¯¼å‡ºæ¥ï¼Œå‡½æ•° foo() çš„å‚æ•°å’Œè¿”å›å€¼éƒ½æ˜¯ä¸€ä¸ªå¼•ç”¨ï¼Œä»–ä»¬çš„ç”Ÿå‘½å‘¨æœŸæ˜¯ä¸€æ ·çš„ï¼Œæ‰€ä»¥ï¼Œä¹Ÿå°±å¯ä»¥ç¼–è¯‘é€šè¿‡
    fn foo (s: &mut String) -> &String {
        s.push_str("coolshell");
        s
    }
    let mut s = "hello, ".to_string();
    println!("{}", foo(&mut s))

    // è¿™ä¸ªä¾‹å­å°±ä¸è¡Œäº† , ç¼–è¯‘å™¨æ— æ³•åœ¨ç¼–è¯‘æœŸé—´çŸ¥é“ä¼šè¿”å›å“ªä¸ªå˜é‡, ä¹Ÿå°±æ— æ³•è‡ªåŠ¨æ¨å¯¼å‡ºç”Ÿå‘½å‘¨æœŸæ˜¯å¦ç¬¦åˆè¦æ±‚
    //
    // è¿™ä¸ªé”™è¯¯ä¾‹å­åªé’ˆå¯¹è¿”å›å¼•ç”¨çš„æƒ…å†µ
    //
    fn longer(s1: &str, s2: &str) -> &str {// error, è¿”å›çš„å¼•ç”¨ å¯èƒ½å’Œå‚æ•°å®šä¹‰çš„åœ°æ–¹ä¸åœ¨åŒä¸€ä¸ªä½œç”¨åŸŸ, è¿”å›çš„å¼•ç”¨å­©ç ¸ä½¿ç”¨çš„æ—¶å€™, å‚æ•°è¶…å‡ºä½œç”¨åŸŸè€Œå¤±æ•ˆäº†
        if s1.len() > s2.len() {s1}
        else {s2}
    }
    // æ­£ç¡®çš„å†™æ³•: éœ€è¦æ‰‹åŠ¨æŒ‡å®šç”Ÿå‘½å‘¨æœŸæ³¨é‡Š
    //
    fn longer<'a>(s1: &'a str, s2: &'a str) -> &'a str {//å‡½æ•°å®šä¹‰æŒ‡å®šäº†ç­¾åä¸­æ‰€æœ‰çš„å¼•ç”¨å¿…é¡»æœ‰ç›¸åŒçš„ç”Ÿå‘½å‘¨æœŸ 'a
    // åŠ ä¸Šå‘¨æœŸæ³¨é‡Šå°±æ˜¯å‘Šè¯‰ç¼–è¯‘å™¨: å‡½æ•°è¿”å›çš„å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸ <= æ¯ä¸ªä¼ å…¥å‚æ•°çš„ç”Ÿå‘½å‘¨æœŸ, å³è¿”å›å€¼åœ¨ä½¿ç”¨è¿‡ç¨‹ä¸­, æ˜¯å®‰å…¨çš„, ä¸ä¼šæŒ‡å‘ç©º
        if s2.len() > s1.len() {
            s2
        } else {
            s1
        }
    }
    let r;
    {
        let s1 = "rust";
        let s2 = "ecmascript";
        r = longer(s1, s2);
    }
    println!("{} is longer", r); // æ­¤æ—¶ s1, s2 éƒ½é”€æ¯äº†, ä¸ºä»€ä¹ˆ r ä»ç„¶æœ‰æ•ˆå‘¢? å› ä¸º s1, s2 éƒ½æ˜¯ &str ç±»å‹, åˆ†é…åœ¨ æ ˆä¸­, åœ¨æ–¹æ³•é€€å‡ºå‰, éƒ½æœ‰æ•ˆ

    //çœ‹ String çš„ä¾‹å­:
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz"); // è¿™é‡Œå°±æœ‰é—®é¢˜äº†, String ç±»å‹ å­—ç¬¦åºåˆ—åˆ†é…åœ¨ heap, è¶…å‡º ä½œç”¨åŸŸè‡ªè¡Œé”€æ¯äº†
        result = longer(string1.as_str(), string2.as_str());// error, borrowed value does not live long enough
                                                                //  string2 ç”Ÿå‘½å‘¨æœŸæ¯” result çŸ­
    }
    println!("The longest string is {}", result);


    //
    //åŠ ä¸åŠ  'a éƒ½æ˜¯é”™è¯¯, cannot return value referencing local variable `s`
    // å› ä¸ºå‡½æ•°ç»“æŸ, s ä¼šç¦»å¼€ä½œç”¨åŸŸ, è¢«æ¸…ç†
    // æœ€å¥½çš„è§£å†³æ–¹æ¡ˆæ˜¯è¿”å›ä¸€ä¸ªæœ‰æ‰€æœ‰æƒçš„æ•°æ®ç±»å‹è€Œä¸æ˜¯ä¸€ä¸ªå¼•ç”¨ï¼Œè¿™æ ·å‡½æ•°è°ƒç”¨è€…å°±éœ€è¦è´Ÿè´£æ¸…ç†è¿™ä¸ªå€¼äº†ã€‚
    //
    fn as_str<'a>(s: &'a str) -> &'a str {
        let s = String::from("hello");
        s.as_str() 
    }

```

### å‡½æ•°ä¸­çš„ç”Ÿå‘½å‘¨æœŸå‚æ•°

```rs
fn foo<â€™a>(s: &â€™a str, t: &â€™a str) -> &â€™a str
// è¾“å‡º(å€Ÿç”¨æ–¹)çš„ç”Ÿå‘½å‘¨æœŸé•¿åº¦å¿…é¡» çŸ­äº/ç­‰äº è¾“å…¥(å‡ºå€Ÿæ–¹)çš„ç”Ÿå‘½å‘¨æœŸé•¿åº¦
// -ã€‹è¿”å›çš„å¼•ç”¨å¿…é¡»å’Œè¾“å…¥å‚æ•°æœ‰ç‚¹å…³ç³»æ‰è¡Œ

```


### ç»“æ„ä½“ä¸­ç”Ÿå‘½å‘¨æœŸ çœç•¥çš„è§„åˆ™


```rust
// ç”Ÿå‘½å‘¨æœŸçœç•¥
//
// çœç•¥éµå¾ªçš„è§„åˆ™:
// - åªæœ‰ä¸€ä¸ªç”Ÿå‘½å‘¨æœŸå‚æ•°, å¯ä»¥çœç•¥, å¦‚ fn bar<'a>(x: &'a i32) -> &'a 32 ç­‰ä»· fn bar(x: &i32) -> &i32
// - æ¯ä¸ªå¼•ç”¨å‚æ•°éƒ½æœ‰å±äºè‡ªå·±çš„å‘¨æœŸå‚æ•°, å¦‚ fn foo<'a, 'b>(x: &'a i32, y: &'b i32), fn bar<'a>(x: &'a i32)
// - å¯¹äº struct çš„æ–¹æ³•, ç¬¬ä¸€ä¸ªå‚æ•°éƒ½æ˜¯ &self, é‚£ä¹ˆ self çš„å‘¨æœŸè¢«èµ‹äºˆæ‰€æœ‰è¾“å‡ºç”Ÿå‘½å‘¨æœŸå‚æ•° , æ‰€ä»¥ è¿”å›å‚æ•°å¯ä»¥çœç•¥å‘¨æœŸå‚æ•°
    //
    // 
    //
    // åŠ ä¸Šå‘¨æœŸæ³¨é‡Š, å‘Šè¯‰ç¼–è¯‘å™¨, ç»“æ„ä½“çš„ç”Ÿå‘½å‘¨æœŸ <= æˆå‘˜å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸ, å³æˆå‘˜çš„å‘¨æœŸè¦ä¿è¯ç»“æ„ä½“å‘¨æœŸçš„å®‰å…¨, æˆå‘˜çš„å‘¨æœŸå¿…é¡»è¦æ›´å¤§
    struct Str<'a> {
        content: &'a str // ä½¿ç”¨å­—ç¬¦ä¸²åˆ‡ç‰‡å¼•ç”¨, ä¹‹å‰éƒ½æ˜¯ä½¿ç”¨çš„ String 
    }
    impl<'a> Str<'a> {
        //
        //è¿™é‡Œè¿”å›å€¼å¹¶æ²¡æœ‰ç”Ÿå‘½å‘¨æœŸæ³¨é‡Šï¼Œä½†æ˜¯åŠ ä¸Šä¹Ÿæ— å¦¨ã€‚è¿™æ˜¯ä¸€ä¸ªå†å²é—®é¢˜ï¼Œæ—©
        //æœŸ Rust ä¸æ”¯æŒç”Ÿå‘½å‘¨æœŸè‡ªåŠ¨åˆ¤æ–­ï¼Œæ‰€æœ‰çš„ç”Ÿå‘½å‘¨æœŸå¿…é¡»ä¸¥æ ¼å£°æ˜ï¼Œä½†ä¸»æµ
        //ç¨³å®šç‰ˆæœ¬çš„ Rust å·²ç»æ”¯æŒäº†è¿™ä¸ªåŠŸèƒ½
        fn get_content(&self) -> &str {
            self.content
        }

        //æŒ‡å®š: ç»“æ„ä½“æ–¹æ³•çš„â€œå¼•ç”¨å‚æ•°â€çš„ç”Ÿå‘½å‘¨æœŸ >= ç»“æ„ä½“çš„ç”Ÿå‘½å‘¨æœŸ, ä¿è¯ç»“æ„ä½“å‘¨æœŸçš„å®‰å…¨
        // è‹¥æ²¡æœ‰ â€˜a, ä¼šæŠ¥é”™
        fn replate(&mut self, new: &'a str) {...}
    }
    let s = Str {
        content: "string_slice" // æ–¹ä¾¿å¤šäº†
    };
    println!("s.content = {}", s.get_content());

   
}


```

### é™æ€ç”Ÿå‘½å‘¨æœŸæ³¨é‡Š

```rust
 //é™æ€ç”Ÿå‘½å‘¨æœŸ
    //
    //'static æ‰€è¡¨ç¤ºçš„ç”Ÿå‘½å‘¨æœŸä»ç¨‹åºè¿è¡Œå¼€å§‹åˆ°ç¨‹åºè¿è¡Œç»“æŸã€‚
    //
    //æ‰€æœ‰å­—ç¬¦ä¸²å­—é¢é‡éƒ½æ˜¯ &'static str ï¼Œ
    let s: &'static str = "hello";
    // ç­‰ä»·
    let s = "hello";

    //ä¸€ä¸ªç»¼åˆä¾‹å­ğŸŒ°
    use std::fmt::Display;
    fn longest_with_an_announcement<'a, T>(x: &'a str, y: &'a str, ann: T) -> &'a str
        where T: Display
    {
        println!("Announcement! {}", ann);
        if x.len() > y.len() {
            x
        } else {
            y
        }
    }
```

### ç”Ÿå‘½å‘¨æœŸçº¦æŸ

```rs
// T:â€™aï¼Œ è¡¨ç¤ºTç±»å‹ä¸­çš„ä»»ä½•å¼•ç”¨éƒ½è¦â€œæ´»å¾—â€ å’Œ â€™a ä¸€æ ·é•¿ã€‚
// T: Trait + â€˜aï¼Œè¡¨ç¤º Tç±»å‹å¿…é¡»å®ç° Traitè¿™ä¸ª traitï¼Œå¹¶ä¸” Tç±»å‹ä¸­ä»»ä½•å¼•ç”¨éƒ½è¦â€œæ´»å¾—â€å’Œ â€™a ä¸€æ ·é•¿ã€‚

```


## å¼•ç”¨


### å¼•ç”¨åŸºæœ¬ä»‹ç»


```rust


/// å€Ÿç”¨(å¼•ç”¨)
/// "&"ç¬¦å·ç”¨äºä»å˜é‡å€Ÿç”¨æ‰€æœ‰æƒ, ç”Ÿæˆä¸€ä¸ªå˜é‡çš„å¼•ç”¨
/// ref å£°æ˜æŸä¸ªå˜é‡ä¸ºå¼•ç”¨ç±»å‹, ç”¨æ¥æ›´æ”¹èµ‹å€¼è¡Œä¸º, ä½¿å¾—æ™®é€šçš„å˜é‡èµ‹å€¼è¡Œä¸ºå˜ä¸ºç»™å¼•ç”¨èµ‹å€¼ ; å¯ç”¨äºå…ˆå£°æ˜æŸä¸ªå¼•ç”¨ç±»å‹, åèµ‹å€¼
/// 
///
///
/// å¼•ç”¨æœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ªç±»å‹å¹¶å…·æœ‰ä¸€ä¸ªå€¼ï¼Œè¿™ä¸ªå€¼è®°å½•çš„æ˜¯åˆ«çš„å€¼æ‰€åœ¨çš„ä½ç½®
///
/// å¼•ç”¨ä¸ä¼šè·å¾—å€¼çš„æ‰€æœ‰æƒ, å¼•ç”¨åªèƒ½ç§Ÿå€Ÿï¼ˆBorrowï¼‰å€¼çš„æ‰€æœ‰æƒ, æ‰€ä»¥ å˜é‡ a çš„å€¼è¢«å€Ÿç”¨ä¸º b æ—¶ï¼Œa æœ¬èº«ä»ç„¶æœ‰æ•ˆã€‚
/// 
/// è§£å¼•ç”¨ ä½¿ç”¨ * ---- åœ¨ç­‰å·å³è¾¹ (ä¼šè·å¾—åŸå§‹å€¼çš„æ‰€æœ‰æƒ)
/// å–åœ°å€ ä½¿ç”¨ & ---- åœ¨ç­‰å³è¾¹
/// è§£æ„ ä½¿ç”¨ & --- åœ¨ç­‰å·å·¦è¾¹
/// 
/// matchçš„æ¨¡å¼åŒ¹é…çš„åŒ¹é…é¡¹ä¸Šåªèƒ½ä½¿ç”¨ refï¼Œ
/// åœ¨å‡½æ•°å£°æ˜ä¸Šåªèƒ½ä½¿ç”¨&æ¥è¡¨ç¤ºå¼•ç”¨ç±»å‹
/// 
/// ä¸€ä¸ªå¼•ç”¨çš„ä½œç”¨åŸŸä»å£°æ˜çš„åœ°æ–¹å¼€å§‹ä¸€ç›´æŒç»­åˆ°æœ€åä¸€æ¬¡ä½¿ç”¨ä¸ºæ­¢
/// 
/// åœ¨ä»»æ„ç»™å®šæ—¶é—´ï¼Œè¦ä¹ˆ åªèƒ½æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œè¦ä¹ˆ åªèƒ½æœ‰å¤šä¸ªä¸å¯å˜å¼•ç”¨

// 
/// åˆ†ä¸ºå¯å˜, ä¸å¯å˜å¼•ç”¨
// 
// ä¸€ä¸ªåŸå§‹å€¼, å­˜åœ¨å¯å˜å€Ÿç”¨, å°±æ— æ³•å­˜åœ¨å…¶ä»–å€Ÿç”¨äº†, æ— è®ºæ˜¯å¯å˜å€Ÿç”¨è¿˜æ˜¯ä¸å¯å˜å€Ÿç”¨ (å¯å˜å€Ÿç”¨å…·æœ‰ç‹¬å æ€§)
// å­˜åœ¨ä¸å¯å˜å€Ÿç”¨, è¿˜èƒ½å­˜åœ¨å…¶ä»–ä¸å¯å˜å€Ÿç”¨ (ç›¸å½“äºå†…å­˜çš„è¯»å†™é” ï¼ŒåŒä¸€æ—¶åˆ»ï¼Œåªèƒ½ æ‹¥æœ‰ä¸€ä¸ªå†™é”ï¼Œæˆ–è€…å¤šä¸ªè¯»é”ï¼Œä¸èƒ½åŒæ—¶æ‹¥æœ‰)
/// 
let a = 20;  
let b = &a;  // å–åœ°å€
if a==*b  // true  , *å·ä¸ºè§£å¼•ç”¨ç¬¦å·
{  
println!("a and *b are equal");  // å°†æ‰“å°è¿™å¥
}  

else  
{  
println!("they are not equal");  
}  




    //
    //
    // ref å…³é”®å­—
    //
    let ref a=2;
    let a = &2; // ç­‰æ•ˆ, ä¸¤ä¸ªå€¼éƒ½æ˜¯&i32ç±»å‹

    let ref b: i32; // å…ˆå£°æ˜ä¸€ä¸ªå¼•ç”¨ç±»å‹
    //b = 1;// é”™è¯¯, ç±»å‹ä¸åŒ¹é…, expected `&i32`, found integer. expected &i32ï¼Œconsider borrowing here: `&1`
    b = &1;// å†èµ‹å€¼
    //
    // ä¸ºå‚æ•°å£°æ˜ç±»å‹çš„æ—¶å€™, åªèƒ½ç”¨ &, ä¸èƒ½ç”¨ ref, ref åªç”¨äºå˜é‡ç±»å‹å£°æ˜
    //
    struct B<'l> {
        pub a: &'l u32,
        pub b: ref u32, //é”™è¯¯, expected type, found keyword `ref`
    }
    let ref a = &1;
    let b = B{ a: a };

    fn test(a: ref i32) {    } // é”™è¯¯


    let v = 2;
    let mut v_mut = 2;
    match v {
        // ref ä¼šå£°æ˜ val æ˜¯ &i32 ç±»å‹, é€šè¿‡ val æ¥æ”¶ v
        ref val => println!("val æ˜¯å¼•ç”¨, val = {}", val),// æ‰“å°, *val ä¹Ÿå¯, æ‰“å°æ—¶å¯ä»¥çœç•¥ *
    }
    match v_mut {
        ref mut val => {
            // éœ€è¦ val å£°æ˜ä¸º mut
            *val = 3; 
            println!("val æ˜¯å¯å˜å¼•ç”¨, val = {}", val);
        },
    }





    // è§£å¼•ç”¨
    let r=&1;// r æ˜¯å¼•ç”¨ç±»å‹ &i32
    let &a=r;// a æ˜¯æ™®é€šç±»å‹, i32
    let c=*r; // c åŒ a, æ˜¯ i32 (è§£å¼•ç”¨)


    //
    // match ä¸­ä½¿ç”¨è§£å¼•ç”¨
    let r = &1;
    match r {
        &val => println!("é€šè¿‡è§£å¼•ç”¨è·å–å€¼: {}", val), 
    }

    
    match r {
        *val => println!("ä½¿ç”¨ * è§£å¼•ç”¨: {}", val),// é”™è¯¯, * ä¸èƒ½ç”¨æ¥åšå£°æ˜
    }
    // éœ€è¦å…ˆè§£å¼•ç”¨, å†å†…éƒ¨ä½¿ç”¨
    match *r {
        val => println!("åŒ¹é…å‰å…ˆè§£å¼•ç”¨: {}", val),
    }
    


}

```

### ä¸å¯å˜å¼•ç”¨

```rust
println!("------------------å¼•ç”¨/å€Ÿç”¨---------------------------");
    let s1 = String::from("hello");
    let s2 = &s1; // è·å–å¼•ç”¨
    println!("s1 is {}, s2 is {}", s1, s2);

    // å‡½æ•°è°ƒç”¨
    fn calculate_length(s: &String) -> usize {
        s.len()
    }
    let s1 = String::from("hello");
    let len = calculate_length(&s1);
    println!("The length of '{}' is {}.", s1, len);// s1 è¿˜æœ‰æ•ˆ

    let s1 = String::from("hello");
    let s2 = &s1;
    // é”™è¯¯, æ‰§è¡Œè¿™å¥, s1 ä¼šç§»åŠ¨è€Œå¤±æ•ˆ
    // é€ æˆ s2 å¯¹ s1 çš„ç§Ÿå€Ÿä¹Ÿå¤±æ•ˆ
    let s3 = s1;
    println!("{}", s2);//error

    let s1 = String::from("hello");
    let mut s2 = &s1;
    let s3 = s1;
    s2 = &s3; // // é‡æ–°ä» s3 ç§Ÿå€Ÿæ‰€æœ‰æƒ, è¦æ±‚ s2 æ˜¯ mut çš„
    println!("s2 = {}", s2);

    //
    // å¼•ç”¨çš„æ‰€æœ‰æƒæ˜¯ç§Ÿå€Ÿçš„, ä¸å…è®¸ä¿®æ”¹å€¼
    //
    let s1 = String::from("run");
    let s2 = &s1;
    println!("{}", s2);
    s2.push_str("oob"); // é”™è¯¯ï¼Œç¦æ­¢ä¿®æ”¹ç§Ÿå€Ÿçš„å€¼

```



### å¯å˜å¼•ç”¨



```rust



fn borrow() {
    

    //
    //å¯å˜å¼•ç”¨
    //
    // å¯ä¿®æ”¹å€¼çš„ç§Ÿå€Ÿ
    let mut s1 = String::from("run");
    // s1 æ˜¯å¯å˜çš„
    let s2 = &mut s1;
    // s2 æ˜¯å¯å˜çš„å¼•ç”¨
    s2.push_str("oob");
    println!("å¯å˜å¼•ç”¨, s2 = {}", s2);//runoob
    println!("s1 = {}", s1);//runoob

    //
    //å¯å˜å¼•ç”¨ä¸å…è®¸å¤šé‡å¼•ç”¨
    //
    //ä¸€ä¸ªå€¼è¢«å¯å˜å¼•ç”¨æ—¶ä¸å…è®¸å†æ¬¡è¢«ä»»ä½•å¼•ç”¨ã€‚
    // ä¸»è¦å‡ºäºå¯¹å¹¶å‘çŠ¶æ€ä¸‹å‘ç”Ÿæ•°æ®è®¿é—®ç¢°æ’çš„è€ƒè™‘ï¼Œåœ¨ç¼–è¯‘é˜¶æ®µå°±é¿å…äº†è¿™ç§äº‹æƒ…çš„å‘ç”Ÿ
    let mut s = String::from("hello");
    let r1 = &mut s;
    // é”™è¯¯, å› ä¸º ä¸¤ä¸ªå¯å˜å¼•ç”¨æŒ‡å‘äº† s;
    let r2 = &mut s;

    // ç±»ä¼¼çš„å¤šé‡å¼•ç”¨é—®é¢˜
    //
    let mut s = String::from("hello");
    let r1 = &s; // æ²¡é—®é¢˜
    let r3 = &mut s; // å¤§é—®é¢˜
    println!("{}", r1);


```

### å‚æ‚¬å¼•ç”¨é—®é¢˜ï¼ˆDangling References)


```rust



    //
    //å‚æ‚¬å¼•ç”¨ï¼ˆDangling Referencesï¼‰---- å¦‚ä½•è§£å†³ -> ç”Ÿå‘½å‘¨æœŸæ³¨é‡Š
    //
    //
    // å‚æ‚¬å¼•ç”¨ï¼ˆDangling References): æ²¡æœ‰å®é™…æŒ‡å‘ä¸€ä¸ªçœŸæ­£èƒ½è®¿é—®çš„æ•°æ®çš„æŒ‡é’ˆ
    //
    //åœ¨ Rust è¯­è¨€é‡Œä¸å…è®¸å‡ºç°
    fn dangle() -> &String {
        let s = String::from("hello");
        //å‡½æ•°çš„ç»“æŸï¼Œå…¶å±€éƒ¨å˜é‡çš„å€¼æœ¬èº«æ²¡æœ‰è¢«å½“ä½œè¿”å›å€¼ï¼Œè¢«é‡Šæ”¾äº†ã€‚ä½†å®ƒçš„å¼•ç”¨å´è¢«è¿”å›
        &s
    }
    
    // å†æ¯”å¦‚:
    //
    let r;
    {
        let x = 3;
        r = &x; //`x` does not live long enough,  r æ‰€å¼•ç”¨çš„å€¼å·²ç»åœ¨ä½¿ç”¨ä¹‹å‰è¢«é‡Šæ”¾
    }
    println!("r = {}", r);
    //
    // å†æ¯”å¦‚:
    fn longer(s1: &str, s2: &str) -> &str {
        if s2.len() > s1.len() {
            s2
        } else {
            s1
        }
    }
    // //ä¸Šä¸ªå‡½æ•°é”™è¯¯, æ— æ³•ç¼–è¯‘, åŸå› æ˜¯è¿”å›å€¼å¼•ç”¨å¯èƒ½ä¼šè¿”å›è¿‡æœŸçš„å¼•ç”¨, ä¾‹å¦‚è¿™æ ·ä½¿ç”¨:
    let r;
    {
        let s1 = "rust";
        let s2 = "ecmascript";
        r = longer(s1, s2);
    }
    println!("{} is longer", r); // r è¢«ä½¿ç”¨çš„æ—¶å€™æºå€¼ s1 å’Œ s2 éƒ½å·²ç»å¤±æ•ˆäº†, éœ€è¦ä½¿ç”¨ç”Ÿå‘½å‘¨æœŸæ³¨é‡Š, ä¸ºè¿”å›å€¼å£°æ˜ä¸€ä¸ªæ³¨é‡Š, è´´åˆ° å‚æ•°ä¸Š







```




## è£¸æŒ‡é’ˆ

```rs
// åŸç”Ÿ æŒ‡é’ˆæ˜¯æŒ‡å½¢å¦‚* const T å’Œ*mut T è¿™æ ·çš„ç±»å‹ ã€‚
// å¯ä»¥é€šè¿‡ asæ“ä½œç¬¦éšæ„è½¬æ¢ä¸ºåŸç”ŸæŒ‡é’ˆï¼Œä¾‹å¦‚ &T as *constT å’Œ &mut T as *mutTã€‚


// åœºæ™¯:
// - åœ¨éœ€è¦çš„æ—¶å€™è·³è¿‡ Rust å®‰å…¨æ£€æŸ¥
// - ä¸ C è¯­è¨€â€œæ‰“äº¤é“"


// å†…ç½®å‡½æ•°
// â€¢ std::ptr::null å‡½æ•°å’Œ is_null æ–¹æ³• 
// â€¢ offsetæ–¹æ³•
// â€¢ read/writeæ–¹æ³•
// â€¢ replace/swap æ–¹æ³•



// è§£å¼•ç”¨
// 
fn main() {
    let mut s = "hello".to_string();
    // è½¬æ¢
    let r1 = &s as *const String;
    let r2 = &mut s as *mut String;
    assert_eq!(r1, r2);
    
    let address = 0x7fff1d72307d;// éšä¾¿æŒ‡å®šçš„åœ°å€
    let r3 = address as *const String;
    unsafe {
        println!("r1 is: {}", *r1);
       println!("r2 is: {}", *r2);
    //    error
       // Segmentation fault  
       assert_eq!(*r1, *r3)
   }
}


// åˆ›å»º
fn main() {
    // åˆ›å»ºç©ºæŒ‡é’ˆ
    let p: *const u8 = std::ptr::null();
    // åˆ¤æ–­æ˜¯å¦ä¸ºç©ºæŒ‡é’ˆ
    assert!(p.is_null());

    let s: &str = "hello";
    // è·å¾—ä¸å¯å˜åŸç”ŸæŒ‡é’ˆ (æŒ‡å‘å…·ä½“æ•°æ®/æ•°æ®å†…éƒ¨çš„å…ƒç´ )
    // æŒ‡é’ˆ ptr çš„ç±»å‹ä¸º*const u8ï¼Œ è¿™ æ˜¯å› ä¸ºå­—ç¬¦ä¸²æ˜¯ä»¥å­—èŠ‚ä¸ºå•ä½å­˜å‚¨çš„
    let ptr: *const u8 = s.as_ptr();
    assert!(!ptr.is_null());

    //å¯¹æ¯” é€šè¿‡ as_ptr()è·å–æŒ‡é’ˆ:
    // - é€šè¿‡ as_ptr å¾—åˆ°çš„æŒ‡é’ˆæ˜¯æŒ‡å‘å­˜æ”¾æ•°æ®å †/æ ˆ å†…å­˜çš„æŒ‡é’ˆï¼Œè€Œå¼•ç”¨åˆ™æ˜¯å¯¹å­—ç¬¦ä¸²æˆ–æ•°ç»„æœ¬èº«çš„å¼•ç”¨(æ¯”å‰è€…å•çº¯çš„æŒ‡é’ˆåŒ…å«æ›´å¤šæ•°æ®)ã€‚
    let mut x = "";
   let y = &mut x as *mut &str;
   unsafe {
       assert_eq!(y.read(), "hello");
   }
    
    let mut s = [1, 2, 3];
    // è·å¾—å¯å˜åŸç”ŸæŒ‡é’ˆ
    let ptr: *mut u32 = s.as_mut_ptr();
    assert!(!ptr.is_null());
}



// offset() å¯ä»¥æŒ‡å®šç›¸å¯¹äºæŒ‡é’ˆåœ°å€çš„åç§»å­—èŠ‚æ•°ï¼Œ
// 
// 
fn main() {
    let s: &str = "Rust";
    let ptr: *const u8 = s.as_ptr();
    // offsetæ–¹æ³•ä¸èƒ½ä¿è¯ä¼ å…¥çš„åç§»é‡åˆæ³•ï¼Œæ•…ä¸ºunsafe
    unsafe {
        println!("{:?}", *ptr.offset(1) as char); // u
        println!("{:?}", *ptr.offset(3) as char); // t
        println!("{:?}", *ptr.offset(255) as char); // Ã¿ æœ‰UBé£é™©
    }
}



// read/write  å¯ä»¥è¯»å–æˆ–å†™å…¥æŒ‡é’ˆç›¸åº” å†…å­˜ä¸­çš„ å†…å®¹
// 
fn main() {
    let x = "hello".to_string();
    let y: *const u8 = x.as_ptr();
    unsafe {
        assert_eq!(y.read() as char, 'h');
    }
    let x = [0, 1, 2, 3];
    // è¿™é‡Œçš„åŸç”ŸæŒ‡é’ˆç±» å‹æ˜¯å¸¦é•¿åº¦çš„ï¼Œ
    // å¦‚æœå°†ç±»å‹æ”¹ä¸º* const [u32;3] ï¼Œåˆ™é€šè¿‡ read æ–¹æ³•åªèƒ½è¯»å–åˆ°å‰ä¸‰ä¸ªå…ƒç´ 
    let y = x[0..].as_ptr() as *const [u32; 4];
    unsafe {
       assert_eq!(y.read(), [0,1,2,3]);
   }
   let x = vec![0, 1, 2, 3];
   let y = &x as *const Vec<i32>;
   unsafe {
        assert_eq!(y.read(), [0,1,2,3]);
   }
   let mut x = "";
   let y = &mut x as *mut &str;
   let z = "hello";
   unsafe {
       y.write(z);
       assert_eq!(y.read(), "hello");
   }
}




// replace/swap   æ›¿æ¢æŒ‡å®šä½ç½® çš„å†…å­˜ æ•°æ®
// 
fn main() {
   let mut v: Vec<i32> = vec![1, 2];
   let v_ptr : *mut i32 = v.as_mut_ptr();
   unsafe{
       let old_v = v_ptr.replace(5);
       assert_eq!(1, old_v);
       assert_eq!([5, 2], &v[..]);    
   }
   let mut v: Vec<i32> = vec![1, 2];
  let v_ptr  = &mut v as *mut Vec<i32>;
  unsafe{
      let old_v = v_ptr.replace(vec![3,4,5]);
      assert_eq!([1, 2], &old_v[..]);
      assert_eq!([3, 4, 5], &v[..]);   
  }
  let mut array = [0, 1, 2, 3];
  let x = array[0..].as_mut_ptr() as *mut [u32; 2];
  let y = array[1..].as_mut_ptr() as *mut [u32; 2];
  unsafe {
      assert_eq!([0, 1], x.read());
      assert_eq!([1, 2], y.read());
      x.swap(y);
      assert_eq!([1, 0, 1, 3], array);
  }
}
```

## æ™ºèƒ½æŒ‡é’ˆ

### æ™ºèƒ½æŒ‡é’ˆä»‹ç»


æ™ºèƒ½æŒ‡é’ˆå°±æ˜¯ä¸€ä¸ªç»“æ„ä½“ï¼Œå…¶è¡Œä¸ºç±»ä¼¼äºå¼•ç”¨, æŒ‡å‘ä¸€å—å†…å­˜çš„åœ°å€, æ™ºèƒ½æŒ‡é’ˆæ‹¥æœ‰èµ„æºçš„æ‰€æœ‰æƒï¼Œè€Œæ™®é€šå¼•ç”¨ åª æ˜¯å¯¹æ‰€æœ‰æƒ çš„å€Ÿç”¨ ã€‚

æ™ºèƒ½æŒ‡é’ˆåŒºåˆ«äºå¸¸è§„ç»“ æ„ä½“çš„ç‰¹æ€§åœ¨äºï¼Œå®ƒå®ç°äº† Deref å’Œ Drop è¿™ä¸¤ä¸ª trait, Deref æä¾›äº†è§£å¼•ç”¨èƒ½åŠ› ï¼Œ Drop æ ä¾›äº†è‡ªåŠ¨ææ„çš„èƒ½åŠ› ;

æ¯”å¦‚: String å’Œ Vec ç±»å‹ ä¹Ÿæ˜¯ä¸€ç§æ™ºèƒ½æŒ‡é’ˆ, å®ƒä»¬ä¹Ÿéƒ½å®ç°äº† Derefå’ŒDrop

```rs
let x =Box::new(â€helloâ€);
let y = x;
// error, å› ä¸ºæ™ºèƒ½æŒ‡é’ˆæ‹¥æœ‰åŸå§‹å€¼çš„æ‰€æœ‰æƒ, xå·²ç»è¢«è½¬ç§»äº†
// å¯¹äºbox<T>, è‹¥åŒ…å«çš„ Tæ˜¯ç§»åŠ¨è¯­ä¹‰, åˆ™box ä¹Ÿæ˜¯, è‹¥Tæ˜¯å¤åˆ¶è¯­ä¹‰, åˆ™box ä¹Ÿæ˜¯å¤åˆ¶è¯­ä¹‰
println1(â€(:?}â€, x);
```

### RAIIæœºåˆ¶ å®ç°å†…å­˜å›æ”¶

RAII: æ™ºèƒ½æŒ‡é’ˆåœ¨å †å†…å­˜ä¸Šå¼€è¾Ÿç©ºé—´å­˜å‚¨æ•°æ®, è‡ªèº«å­˜å‚¨åœ¨æ ˆä¸Š, åœ¨å‡½æ•°è°ƒç”¨ç»“æŸæ—¶, æŒ‡é’ˆå˜é‡è¢«æ¸…ç†, æŒ‡é’ˆæ‰§è¡Œè‡ªèº«çš„dropæ–¹æ³•, æ¥é‡Šæ”¾æ™º èƒ½æŒ‡é’ˆæ‰€ç®¡ç†çš„å †å†…å­˜ ç©ºé—´

RAII , æ™ºèƒ½æŒ‡é’ˆ, å‡èµ·æºäºç°ä»£ C++



### è‡ªå®šä¹‰æ™ºèƒ½æŒ‡é’ˆ


```rs
    

    // è‡ªå®šä¹‰æ™ºèƒ½æŒ‡é’ˆ
    //
    struct MyBox<T>(T);
    impl<T> MyBox<T> {
        fn new(x: T) -> MyBox<T> {
            MyBox(x)
        }
    }
    //å®ç° Deref trait å…è®¸æˆ‘ä»¬é‡è½½ è§£å¼•ç”¨è¿ç®—ç¬¦
    use std::ops::Deref;
    impl<T> Deref for MyBox<T> {
        type Target = T;

        fn deref(&self) -> &T {
            &self.0
        }
    }
    let x = 5;
    let y = MyBox::new(x);
    println!("y = {}", *y);




    // éšå¼è§£å¼•ç”¨ (è§£å¼•ç”¨å¤šæ€)
    fn hello(name: &str) {
        println!("Hello, {}!", name);
    }
    let m = MyBox::new(String::from("Rust"));
    hello(&m);
    //åœ¨ MyBox<T> ä¸Šå®ç°äº† Deref traitï¼ŒRust å¯ä»¥é€šè¿‡ deref è°ƒç”¨å°† &MyBox<String> å˜ä¸º &Stringã€‚
    //æ ‡å‡†åº“ä¸­æä¾›äº† String ä¸Šçš„ Deref å®ç°ï¼Œå…¶ä¼šè¿”å›å­—ç¬¦ä¸² sliceï¼Œè¿™å¯ä»¥åœ¨ Deref çš„ API æ–‡æ¡£ä¸­çœ‹åˆ°ã€‚
    //Rust å†æ¬¡è°ƒç”¨ deref å°† &String å˜ä¸º &strï¼Œè¿™å°±ç¬¦åˆ hello å‡½æ•°çš„å®šä¹‰äº†ã€‚


```



### Box æ— ç—›ä½¿ç”¨å †å†…å­˜


#### BoxåŸºæœ¬ä½¿ç”¨

ç±»ä¼¼ cpp çš„ unique_ptr;

é€šè¿‡ Boxï¼Œå¼€å‘è€…å¯ä»¥æ–¹ä¾¿æ— ç—›åœ°ä½¿ç”¨å †å†…å­˜ï¼Œ å¹¶ä¸”æ— é¡»æ‰‹å·¥é‡Šæ”¾å †å†…å­˜ï¼Œ å¯ä»¥ç¡®ä¿å†…å­˜å®‰å…¨

```rust
/// æ™ºèƒ½æŒ‡é’ˆ
// Rust ä¸­çš„å€¼é»˜è®¤è¢«åˆ†é…åˆ°stackå†…å­˜ã€‚ å¯ä»¥é€šè¿‡ Box <T>å°†å€¼è£…ç®±(åœ¨å †å†…å­˜ä¸­åˆ†é…)
/// å½“ç®±å­å®ä¾‹ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå®ƒçš„ææ„å‡½æ•°ä¼šè¢«è°ƒç”¨ï¼Œå†…éƒ¨çš„å¯¹è±¡ä¼šè¢« é”€æ¯ï¼Œå †ä¸Šåˆ†é…çš„å†…å­˜ä¹Ÿä¼šè¢«é‡Šæ”¾
// 
//  Box<T>æŒ‡é’ˆå¯¹æ‰€ç®¡ç†çš„å †å†…å­˜æœ‰å”¯ä¸€æ‹¥æœ‰æƒï¼Œ æ‰€ä»¥å¹¶ä¸å…±äº«

/// 
/// ä½¿ç”¨ * è¿ç®—ç¬¦è¿›è¡Œè§£å¼•ç”¨ï¼›è¿™ä¼šç§»é™¤æ‰ä¸€å±‚è£…ç®±
///
///æ ¸å¿ƒä½œç”¨å°±æ˜¯å¯ä»¥å®šä¹‰åŠ¨æ€å¤§å°çš„ç±»å‹, å®é™…å¤§å°è¦åˆ°è¿è¡ŒæœŸæ‰èƒ½ç¡®å®š, å¦‚ ç”¨åœ¨ é€’å½’ä¸­ and ç”¨åœ¨åŒ…è£… trait ä¸­ 
fn box_demo() {
    println!("-------------box_demo--------------");
    let b = Box::new(5);//ä½¿ç”¨ box åœ¨å †ä¸Šå‚¨å­˜ä¸€ä¸ª i32 å€¼
    println!("b = {}", b);//5
    println!("*b = {}", *b);//5

    // ä½¿ç”¨åœºæ™¯:
    // å®šä¹‰é€’å½’çš„ç»“æ„ä¸­ä½¿ç”¨, 
    // å°è¯•æ„é€ é“¾è¡¨
    enum List {
        Cons(i32, List),// error, æ— é™é€’å½’, ç¼–è¯‘å™¨æ£€æµ‹å‡ºäº†æ— é™å¤§å°
        Nil,
    }
    // æ­£ç¡®: (è¿™ç§æ–¹æ³•å­˜åœ¨é™åˆ¶, æ„é€ å‡ºçš„ é“¾è¡¨æ— æ³•å­˜åœ¨å¤šä¸ªå¼•ç”¨, ä½¿ç”¨ä¸€æ¬¡å°±å¤±æ•ˆäº†, æ²¡æ³•ç»™ç¬¬äºŒä¸ªä½¿ç”¨è€…ä½¿ç”¨äº†, è§£å†³: Rc)
    #[derive(Debug)]
    enum List {
        Cons(i32, Box<List>),
        Nil,
    }
    use List::Cons;
    use List::Nil;
    let l = Cons(
        1,
        Box::new(Cons(
            2,
            Box::new(Cons(
                3,
                Box::new(Nil),
            ))
        ))
    );
    println!("{:?}", l);//Cons(1, Cons(2, Cons(3, Nil)))

```
#### åŒ…è£…åŠ¨æ€å¤§å°ç±»å‹


```rs
    // åŠ¨æ€å¤§å°ç±»å‹
    // ç¼–è¯‘æœŸé—´æ— æ³•çŸ¥é“å¤§å°, åªæœ‰åˆ°è¿è¡Œæ—¶æ‰çŸ¥é“
    //
    // åŠ¨æ€å¤§å°ç±»å‹çš„å€¼å¿…é¡»é€šè¿‡æŒ‡é’ˆè®¿é—® , å¦‚ Box<str>, Rc<str>
    //
    //
    // å¦‚:
    // - str åœ¨ç¼–è¯‘æœŸæ— æ³•çŸ¥é“å¤§å°, &str çš„å¤§å°å¯ä»¥åœ¨ç¼–è¯‘æœŸçŸ¥é“ (&str å­˜å‚¨äº† str çš„åœ°å€ å’Œé•¿åº¦)
    // - trait , ä»»ä½• trait éƒ½æ˜¯åŠ¨æ€å¤§å°ç±»å‹, åº”è¯¥è¿™ä¹ˆä½¿ç”¨: Box<XXXTrait>
    //
    // Sized trait
    // å®ç°äº†è¿™ä¸ª trait çš„ç±»å‹, åœ¨ç¼–è¯‘æœŸå³å¯ç¡®å®šå¤§å°
    fn xxx_fn<T>(t: T) {} // T ä¸ºç¼–è¯‘æœŸçŸ¥é“å¤§å°çš„ç±»å‹
    // ç­‰ä»·:
    fn xxx_fn<T: Sized>(t: T) {}
    // æ”¾å®½é™åˆ¶
    fn xxx_fn<T: ?Sized>(t:T) {}// T å¯èƒ½æ˜¯ sized çš„, ä¹Ÿå¯èƒ½ä¸æ˜¯ sized çš„
}



```

### Rc å’Œ Weak å…±äº«å †å†…å­˜

æä¾›å¤šä¸ªæ‰€æœ‰æƒç»™å¤šä¸ªå¯¹è±¡

#### Rc å¼ºå¼•ç”¨

ç±»ä¼¼ cpp çš„ shared_ptr

éƒ½æ˜¯å¼•ç”¨è®¡æ•°æŒ‡é’ˆ, ç”¨äºè®°å½•å­˜å‚¨åœ¨å †ä¸Šçš„å€¼çš„å¼•ç”¨æ•°, å¯ ä»¥å…±äº«åŒ ä¸€å—å †å†…å­˜, å†…éƒ¨åŒ…å«çš„æ•°æ®æ˜¯ä¸å¯å˜çš„, åªèƒ½ç”¨äºå•çº¿ç¨‹ä¸­, å› ä¸ºå†…éƒ¨æ“ä½œä¸æ˜¯åŸå­æ€§çš„, rust ä¹Ÿä¸º å…¶å®ç°äº† !send trait , è¡¨ç¤ºæ— æ³•åœ¨çº¿ç¨‹é—´ç§»åŠ¨

å¯ä»¥ä½¿ç”¨å¤šçº¿ç¨‹ç‰ˆæœ¬: Arc


```rust
/// Rc<T> çš„ç±»å‹ã€‚å…¶åç§°ä¸º å¼•ç”¨è®¡æ•°ï¼ˆreference countingï¼‰
/// å…è®¸ "ä¸å¯å˜æ•°æ®" æœ‰å¤šä¸ªæ‰€æœ‰è€…, æ•°æ®æœ¬èº«æ— æ³•ä¿®æ”¹ (å°†å¤šä¸ªæ‰€æœ‰æƒå…±äº«ç»™å¤šä¸ªå˜é‡)
// 
// å†…éƒ¨ç»´æŠ¤ç€ä¸€ä¸ªå¼•ç”¨è®¡æ•°å™¨ï¼Œæ¯cloneä¸€æ¬¡(å…±äº«ä¸€æ¬¡)ï¼Œ è®¡æ•°å™¨åŠ 1ï¼Œ å½“å®ƒä»¬éƒ½ç¦»å¼€ä½œç”¨åŸŸè‚˜ï¼Œ è®¡ æ•°å™¨ä¼šè¢«æ¸…é›¶ï¼Œå¯¹åº”çš„å †å†…å­˜ä¹Ÿä¼šè¢«è‡ªåŠ¨é‡Šæ”¾ã€‚
// 
// å¸¸ç”¨æ–¹æ³•:
// 
// 
// 
// 
// 
///
let x =Rc::new(45)
let yl = x .clone() ; //å¢åŠ å¼ºå¼•ç”¨è®¡æ•°, å¹¶é å…‹éš†, åªæ˜¯å¢åŠ è®¡æ•°, ç„¶åè¿”å›ä¸€ä¸ªå¼•ç”¨ (å³å…±äº«æ‰€æœ‰æƒ)
let y2 = x.clone(); //å¢åŠ å¼ºå¼•ç”¨è®¡æ•°
priÎ·tln!(â€{:?}â€, Rc::strong_count(&x));//3
letw= Rc::downgrade(&x); //å¢åŠ å¼±å¼•ç”¨è®¡æ•°
println!(â€ {:?) â€, Rc : :weak_count(&x));
let y3 = &*x; //ä¸å¢åŠ è®¡æ•°

// 
// æ„é€ é“¾è¡¨
// é€šè¿‡ box æ„é€ é“¾è¡¨å­˜åœ¨é—®é¢˜: é“¾è¡¨åªèƒ½è¢«ä½¿ç”¨ä¸€æ¬¡, æ¼”ç¤º:
enum List {
    Cons(i32, Box<List>),
    Nil,
}
use List::{Cons, Nil};
let a = Cons(5,
                Box::new(Cons(10,
                            Box::new(Nil))));
let b = Cons(3, Box::new(a)); //a è¢«ç§»åŠ¨åˆ°äº† b å†…éƒ¨
let c = Cons(4, Box::new(a));//  error é”™è¯¯, value used here after move

// ä½¿ç”¨ Rc è§£å†³
enum List {
    Cons(i32, Rc<List>),
    Nil,
}
use List::{Cons, Nil};
use std::rc::Rc;
let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
//æ¯æ¬¡è°ƒç”¨ Rc::cloneï¼ŒRc<List> ä¸­æ•°æ®çš„å¼•ç”¨è®¡æ•°éƒ½ä¼šå¢åŠ ï¼ŒRc::strong_count(&a) è·å– a çš„è¢«å¼•ç”¨ä¸ªæ•°
// ç›´åˆ°æœ‰é›¶ä¸ªå¼•ç”¨ä¹‹å‰å…¶æ•°æ®éƒ½ä¸ä¼šè¢«æ¸…ç†
//
//ä¹Ÿå¯ä»¥è°ƒç”¨ a.clone() è€Œä¸æ˜¯ Rc::clone(&a), ä¸¤è€…æ„æ€æ˜¯ä¸€æ ·çš„, åªä¼šå¢åŠ å¼•ç”¨è®¡æ•°ï¼Œä¸ä¼šä½œæ·±åº¦å¤åˆ¶
//
// è¿™é‡Œ, b, c å…±äº« a çš„æ‰€æœ‰æƒ, a ä¸­çš„æ•°æ®ä¸å¯ä¿®æ”¹
let b = Cons(3, Rc::clone(&a));
let c = Cons(4, Rc::clone(&a));



// #### å¯¹å†…éƒ¨å€¼è¿›è¡Œä¿®æ”¹
///
///å¦‚æœä½ è¦ä¿®æ”¹ Rc é‡Œçš„å€¼ï¼ŒRust ä¼šç»™ä½ ä¸¤ä¸ªæ–¹æ³•ï¼Œä¸€ä¸ªæ˜¯ get_mut()ï¼Œä¸€ä¸ªæ˜¯ make_mut() ï¼Œè¿™ä¸¤ä¸ªæ–¹æ³•éƒ½æœ‰å‰¯ä½œç”¨æˆ–æ˜¯é™åˆ¶
/// - get_mut() éœ€è¦åšä¸€ä¸ªâ€œå”¯ä¸€å¼•ç”¨â€çš„æ£€æŸ¥ï¼Œä¹Ÿå°±æ˜¯æ²¡æœ‰ä»»ä½•çš„å…±äº«æ‰èƒ½ä¿®æ”¹
///- make_mut() åˆ™æ˜¯ä¼šæŠŠå½“å‰çš„å¼•ç”¨ç»™cloneå‡ºæ¥ï¼Œå†ä¹Ÿä¸å…±äº«äº†ï¼Œ æ˜¯ä¸€ä»½å…¨æ–°çš„
// æ›´å¥½çš„ä¿®æ”¹æ–¹æ³•:
/// RefCell<T> èƒ½å¤Ÿåœ¨å¯¹è±¡è¢«è®¤ä¸ºæ˜¯ä¸å¯å˜çš„æƒ…å†µä¸‹ä¿®æ”¹å†…éƒ¨å­—æ®µ; (å¹¶éç¼–è¯‘å™¨æ£€æŸ¥, äºŒæ˜¯è¿è¡ŒæœŸè¿›è¡Œæ£€æŸ¥, ä¸æ˜¯å¾ˆå¥½)
/// Cell<T>ï¼Œå®ƒç±»ä¼¼ RefCell<T> ä½†æœ‰ä¸€ç‚¹é™¤å¤–ï¼šå®ƒå¹¶éæä¾›å†…éƒ¨å€¼çš„å¼•ç”¨ï¼Œè€Œæ˜¯æŠŠå€¼æ‹·è´è¿›å’Œæ‹·è´å‡º Cell<T>ã€‚
///
/// 
//
//ä¿®æ”¹å¼•ç”¨çš„å˜é‡ - get_mut ä¼šè¿”å›ä¸€ä¸ªOptionå¯¹è±¡
//ä½†æ˜¯éœ€è¦æ³¨æ„ï¼Œä»…å½“ï¼ˆåªæœ‰ä¸€ä¸ªå¼ºå¼•ç”¨ && æ²¡æœ‰å¼±å¼•ç”¨ï¼‰ä¸ºçœŸæ‰èƒ½ä¿®æ”¹
if let Some(val) = Rc::get_mut(&mut strong) {
    *val = 555;
}
// æˆ–è€…:
//æ­¤å¤„å¯ä»¥ä¿®æ”¹ï¼Œä½†æ˜¯æ˜¯ä»¥ clone çš„æ–¹å¼ï¼Œä¹Ÿå°±æ˜¯è®©strongè¿™ä¸ªæŒ‡é’ˆç‹¬ç«‹å‡ºæ¥äº†ã€‚
*Rc::make_mut(&mut strong) = 555;


```





#### Weak å¼±å¼•ç”¨

ç±»ä¼¼ cpp çš„ weak_ptr

```rs



// å¼±å¼•ç”¨

/// å¼±å¼•ç”¨: Weak<T>
// Weak å…±äº«çš„æŒ‡é’ˆæ²¡æœ‰æ‰€æœ‰æƒ, ç§°ä¸ºå¼±å¼•ç”¨
/// - é€šè¿‡ Rc::downgrade ä¼ é€’ Rc å®ä¾‹çš„ reference, å¾—åˆ° Weak ç±»å‹çš„æŒ‡é’ˆ, åŒæ—¶å°† weak_count +1, ä¸æ˜¯ strong_count +1
/// - å³ä½¿ weak_count ä¸ä¸ºé›¶, ä¹Ÿå¯èƒ½ä½¿å¾— Rc å®ä¾‹è¢«æ¸…ç†, åªè¦ strong_count == 0 å°±è¡Œäº† (è§£å†³å¾ªç¯é“¾è¡¨é€ æˆçš„å†…å­˜æ³„æ¼)
/// - å¯ä»¥é€šè¿‡ Rc::upgrade è¿”å› Option<Rc<T>> å‡çº§æˆå¼ºå¼•ç”¨
///
/// è¿™ä¹ˆéº»çƒ¦ï¼Œæˆ‘ä»¬ä¸ºä»€ä¹ˆè¿˜è¦ Weak ? è¿™æ˜¯å› ä¸ºå¼ºå¼•ç”¨çš„ Rc ä¼šæœ‰å¾ªç¯å¼•ç”¨çš„é—®é¢˜â€¦â€¦

// åŸºæœ¬ä½¿ç”¨
use std::rc::Rc;
use std::rc::Weak;

let weak: Weak<i32>;
let strong: Rc<i32>;
{
    let five = Rc::new(5); //å±€éƒ¨å˜é‡
    strong = five.clone(); //è¿›è¡Œå¼ºå¼•ç”¨
    weak = Rc::downgrade(&five); //å¯¹å±€éƒ¨å˜é‡è¿›è¡Œå¼±å¼•ç”¨
}
//æ­¤æ—¶ï¼Œfiveå·²ææ„ï¼Œæ‰€ä»¥ Rc::strong_count(&strong)=1ï¼Œ Rc::weak_count(&strong)=1

//å¦‚æœè°ƒç”¨ drop(strong)ï¼Œé‚£ä¸ªæ•´ä¸ªå†…å­˜å°±é‡Šæ”¾äº†
//drop(strong);

//å¦‚æœè¦è®¿é—®å¼±å¼•ç”¨çš„å€¼ï¼Œéœ€è¦æŠŠå¼±å¼•ç”¨ upgrade æˆå¼ºå¼•ç”¨ï¼Œæ‰èƒ½å®‰å…¨çš„ä½¿ç”¨
//è¿™ä¸ªå‡çº§å¯èƒ½ä¼šä¸æˆåŠŸï¼Œå› ä¸ºå†…å­˜å¯èƒ½å·²ç»è¢«åˆ«äººæ¸…ç©ºäº†
match  weak_five.upgrade() {
    Some(r) => println!("{}", r),
    None => println!("None"),

}

// è§£å†³å¾ªç¯å¼•ç”¨çš„å†…å­˜æ³„æ¼é—®é¢˜
use std::{
    cell::RefCell,
    rc::{Rc, Weak},
};
fn main() {
    struct Node {
        head: Option<Weak<RefCell<Node>>>,
        next: Option<Rc<RefCell<Node>>>,
    }
    impl Drop for Node {
        fn drop(&mut self) {
            println!("dropping")
        }
    }

    let one = Rc::new(RefCell::new(Node {
        head: None,
        next: None,
    }));
    let two = Rc::new(RefCell::new(Node {
        head: None,
        next: None,
    }));
    let three = Rc::new(RefCell::new(Node {
        head: None,
        next: None,
    }));
    one.borrow_mut().next = Some(two.clone());
    two.borrow_mut().next = Some(three.clone());
    three.borrow_mut().head = Some(Rc::downgrade(&one));// å¼±å¼•ç”¨, å³ä½¿è®¡æ•°æ²¡æœ‰å½’é›¶, ä»ç„¶å¯å›æ”¶å†…å­˜
}



    

```


### RefCell å’Œ Cell æä¾›å†…éƒ¨å¯å˜æ€§

å˜é‡æœ‰å”¯ä¸€æ‰€æœ‰æƒ, ç±»ä¼¼ box

/// éœ€è¦æ³¨æ„çš„æ˜¯ Cell å’Œ RefCell ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚åœ¨å¤šçº¿ç¨‹ä¸‹ï¼Œéœ€è¦ä½¿ç”¨Mutexè¿›è¡Œäº’æ–¥ã€‚


#### Cell

```rust
// Cell<T>
// 
// 
// æä¾›äº†ä¸€ç§å†…éƒ¨å¯å˜æ€§, å¦‚, æŸä¸ª struct æ˜¯ä¸å¯å˜çš„, ä½†æ˜¯ å†…éƒ¨æŸä¸ªå­—æ®µéœ€è¦å¯å˜

    #[derive(Debug)]
    struct P {
        x: i32,
        y: Cell<i32>,// è¿™é‡Œå®šä¹‰çš„æ˜¯ Cellçš„ä¸å¯å˜ç±»å‹, ä½†æ˜¯ å†…éƒ¨çš„æ•°ç»„ç¡®å®å¯ä»¥ä¿®æ”¹çš„, åˆæ³•çš„é¿å¼€çš„å€Ÿç”¨æ£€æŸ¥
    }
    let p = P { x: 0, y: Cell::new(11)};
    println!("{:?}", p);
    p.y.set(1); // set() å¯¹å†…éƒ¨æ•°æ®çš„ç±»å‹æ²¡æœ‰è¦æ±‚
    println!("{}", p.y.get());// å†…éƒ¨çš„æ•°æ®å¿…é¡»æ˜¯ copy trait æ‰èƒ½ä½¿ç”¨ get(), è¿™é‡Œå®é™…æ˜¯è·å–æ‹·è´, è‹¥æ˜¯é copyç±»å‹, æä¾› get_mut() è·å–å†…éƒ¨æ•°æ®çš„å¯å˜å¼•ç”¨
    println!("{:?}", p);

```

#### RefCell


```rs

/// RefCell<T>
/// å®ƒç±»ä¼¼ Cell<T>,  ä½†æœ‰ä¸€ç‚¹é™¤å¤–ï¼šæä¾›å†…éƒ¨å€¼çš„å¼•ç”¨, è€Œä¸æ˜¯æ‹·è´äº†, å› æ­¤å¯¹äºå†…éƒ¨æ•°æ®çš„ç±»å‹æ²¡æœ‰ copy trait è¦æ±‚
// è™½ç„¶æ²¡æœ‰åˆ†é…ç©ºé—´ï¼Œ ä½†å®ƒæ˜¯æœ‰è¿è¡Œæ—¶å¼€é”€çš„ï¼Œå› ä¸ºå®ƒè‡ªå·±ç»´æŠ¤ç€ä¸€ä¸ªè¿è¡Œ æ—¶å€Ÿç”¨æ£€æŸ¥å™¨, æ¯”å¦‚è·å–å¤šä¸ªå¯å˜å¼•ç”¨, ä¼šPanic
///
// ä¸»è¦ä¸¤ä¸ªæ–¹æ³•:
// borrow_mut() è·å–å¯å˜å¼•ç”¨
// borrow(), è·å–ä¸å¯å˜å¼•ç”¨
let v = RefCell::new(vec![1]);
println!("{:?}", v.borrow());//1
v.borrow_mut().push(1);
println!("{:?}", v.borrow());//1, 1


let x = RefCell::new(vec![1, 2, 3, 4]);
println!("{:?}", *x.borrow()); //[1, 2, 3, 4]
{
    let mut my_ref = x.borrow_mut();
    my_ref.push(1);
}
// è‹¥ä¸Šé¢çš„å¯å˜å€Ÿç”¨ä¸å¦å¼€ä¸€ä¸ª ä½œç”¨åŸŸ, è¿™é‡ŒæŠ¥é”™: å¯å˜å€Ÿç”¨å, ä¸å…è®¸å†æ¬¡ä¸å¯å˜å€Ÿç”¨äº†
// å¦å¼€ä¸€ä¸ªä½œç”¨åŸŸçš„æ•ˆæœ: my_ref è¿™ä¸ªå¯å˜å€Ÿç”¨åˆ°è¿™é‡Œçš„æ—¶å€™å·²ç»è¢«é‡Šæ”¾äº†
println!("{:?}", *x.borrow()); //[1, 2, 3, 4, 1]



// RefCell<T> çš„ä¸€ä¸ªå¸¸è§ç”¨æ³•æ˜¯ä¸ Rc<T> ç»“åˆæ„é€ é“¾è¡¨, rc å…è®¸å¤šé‡å¼•ç”¨, æŠ±åœ¨å¤–å±‚, refcel è·å–å¯å˜å¼•ç”¨
//
//ä»–ä»¬æä¾›äº† set()/get() ä»¥åŠ borrow()/borrow_mut() çš„æ–¹æ³•
//
#[derive(Debug)]
enum List1 {
    Cons(Rc<RefCell<i32>>, Rc<List1>),
    Nil,
}
use List1::{Cons, Nil};
let value = Rc::new(RefCell::new(5));
let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));
let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(&a));
let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(&a));
*value.borrow_mut() += 10;
println!("a after = {:?}", a);
println!("b after = {:?}", b);
println!("c after = {:?}", c);






// å®ä¾‹:
// å®šä¹‰ä¸€ä¸ª trait, å®šä¹‰å‘é€æ–¹æ³• send, è¿™é‡Œ self æ˜¯ä¸å¯å˜çš„
// åç»­ä¼šé€šè¿‡ è¿™ä¸ªä¸å¯å˜ self å¾—åˆ°å¯å˜çš„æˆå‘˜å˜é‡
    trait MsgSender {
        fn send(&self, msg: &str); // è¿™ä¸ª trait å·²ç»å›ºå®š, &self ä¸å…è®¸æ”¹æˆ &mut self
    }
    // ç›‘æ§å™¨
    struct LimitTracker<'a, S: MsgSender> {
        sender: &'a S,
        max: usize, // æœ€å¤§é™é‡é˜ˆå€¼
        value: usize, // å·²ç»ä½¿ç”¨äº†å¤šå°‘
    }
    impl<'a, T> LimitTracker<'a, T>
    where
        T: MsgSender,
    {
        fn new(sender: &'a T, max: usize) -> Self {
            LimitTracker {
                sender,
                max,
                value: 0,
            }
        }

        fn set_value(&mut self, value: usize) {
            self.value = value;

            let percent = self.value as f64 / self.max as f64;
            if percent >= 1.0 {
                self.sender.send(">= 1.0");
            } else if percent >= 0.8 {
                self.sender.send(">= 0.8");
            }
        }
    }

    use std::cell::RefCell;
    //æ¶ˆæ¯å‘é€æ¨¡æ‹Ÿå™¨
    struct MsgSenderMock {
        // ä¸ºä»€ä¹ˆè¦åŒ…è£…?
        //åé¢éœ€è¦é€šè¿‡ ä¸å¯å˜çš„ &self æ‹¿åˆ°å¯å˜çš„ msg_send (ä¸å¯å˜ &self æ˜¯åœ¨ trait ä¸­å®šä¹‰çš„, sendæ–¹æ³•è·å–çš„æ˜¯ selfä¸å¯å˜å¼•ç”¨)
        //å¦‚æœä¸åŒ…è£…ä¸€ä¸‹, åˆ™è¿™é‡Œæ— æ³•ä¿®æ”¹ msg_send æ¥è®°å½•å‘é€çš„æ¶ˆæ¯
        msg_send: RefCell<Vec<String>>,// è®°å½•å‘é€çš„ä¿¡æ¯, å‘é€çš„æ¶ˆæ¯ä¼šå­˜å‚¨åˆ°è¿™é‡Œ
    }
    impl MsgSenderMock {
        fn new() -> Self {
            MsgSenderMock {
                msg_send: RefCell::new(vec![]),
            }
        }
    }
    impl MsgSender for MsgSenderMock {
        fn send(&self, msg: &str) {
            // æ”¹ä¸º refcellå, é€šè¿‡ borrow_mut å¾—åˆ°å¯å˜å¼•ç”¨, ç±»å‹ Ref, ç±»ä¼¼æ™®é€šå¼•ç”¨
            self.msg_send.borrow_mut().push(msg.to_string());
        }
    }
    // æµ‹è¯•
    let mock_sender = MsgSenderMock::new();
    let mut tracker = LimitTracker::new(&mock_sender, 10);
    tracker.set_value(8);
    println!("{}", mock_sender.msg_send.borrow()[0]); // è·å–ä¸å¯å˜å¼•ç”¨
```


### Rc Box RefCell Cell å‡ ç§æŒ‡é’ˆçš„åŒºåˆ«å¯¹æ¯”


```rs

/// åŒºåˆ«:
/// - Rc<T> å…è®¸ç›¸åŒæ•°æ®æœ‰å¤šä¸ªæ‰€æœ‰è€…ï¼›Box<T> å’Œ RefCell<T> åªèƒ½å…è®¸æœ‰å•ä¸€æ‰€æœ‰è€…ã€‚
/// - Box<T> åœ¨ç¼–è¯‘æ—¶æ‰§è¡Œå€Ÿç”¨æ£€æŸ¥(æ£€æŸ¥ å¯å˜/ä¸å¯å˜)ï¼›Rc<T>ä¹Ÿå…è®¸åœ¨ç¼–è¯‘æ—¶æ‰§è¡Œå€Ÿç”¨æ£€æŸ¥(ä½†æ˜¯ä»…ä»…æ£€æŸ¥ ä¸å¯å˜)ï¼›RefCell<T> å…è®¸åœ¨è¿è¡Œæ—¶æ‰§è¡Œå€Ÿç”¨æ£€æŸ¥(ä¸å¯å˜æˆ–å¯å˜)ã€‚
/// -  box å€Ÿç”¨è§„åˆ™æ£€æŸ¥åœ¨ç¼–è¯‘æœŸ, refCell å€Ÿç”¨è§„åˆ™æ£€æŸ¥åœ¨è¿è¡ŒæœŸ
///

// - Cell<T>ä½¿ç”¨ set/get æ–¹æ³•ç›´æ¥æ“ä½œåŒ…è£¹çš„å€¼ (åº•å±‚æ˜¯å°†å†…éƒ¨å€¼æ‹·è´å‡º, ä¿®æ”¹ååœ¨æ‹·è´è¿›å», é€‚åˆäºå®ç°Copyçš„ç±»å‹å³å¤åˆ¶è¯­ä¹‰ç±»å‹)ï¼Œ 
//      RefCell<T>é€šè¿‡ borrow/borrow_mut è¿”å› åŒ…è£…è¿‡çš„å¼•ç”¨ Ref<T>å’Œ RefMut<T>æ¥æ“ä½œåŒ…è£¹çš„å€¼ (é€‚åˆæ²¡æœ‰å®ç°Copyçš„ç±»å‹, å³ç§»åŠ¨è¯­ä¹‰ç±»å‹ã€‚)
// - Cel<T>æ— è¿è¡Œ æ—¶å¼€é”€ï¼Œå¹¶ä¸”æ°¸è¿œä¸ ä¼šåœ¨è¿è¡Œ æ—¶å¼•å‘ panic é”™ è¯¯ã€‚ 
//       RefCell<T>éœ€è¦åœ¨è¿è¡Œæ—¶æ‰§è¡Œå€Ÿç”¨æ£€æŸ¥ï¼Œæ‰€ä»¥æœ‰è¿è¡Œæ—¶å¼€é”€ï¼Œä¸€æ—¦å‘ç°è¿åå€Ÿç”¨è§„åˆ™çš„æƒ…å†µï¼Œåˆ™ä¼šå¼•å‘çº¿ç¨‹ panic 
///



```

### Pin å’Œ Unpin

```rs
// ä½¿ç”¨ Pin<T> åˆ™ä»£è¡¨å°†æ•°æ®çš„å†…å­˜ä½ç½®ç‰¢ç‰¢åœ°â€œé’‰â€åœ¨åŸåœ°ï¼Œä¸è®©å®ƒç§»åŠ¨ ã€‚ 
// Unpin åˆ™æ­£å¥½å’Œ Pin ç›¸å¯¹åº”ï¼Œ ä»£è¡¨è¢«â€œé’‰â€ä½çš„æ•°æ®ï¼Œå¯ä»¥å®‰å…¨åœ°ç§»åŠ¨ã€‚å¤§å¤šæ•°ç±»å‹éƒ½è‡ªåŠ¨å®ç°äº† Unpinã€‚

```


### Cow å†™æ—¶å¤åˆ¶

å†™æ—¶å¤åˆ¶( Copy on Write)æŠ€æœ¯æ˜¯ä¸€ç§ç¨‹åºä¸­çš„ä¼˜åŒ–ç­–ç•¥, ç¿»è¯‘æˆäººè¯å°±æ˜¯ æ‹–å»¶åˆ°éœ€è¦å¯¹æ•°æ®è¿›è¡Œå†™æ“ä½œæ—¶æ‰å¤åˆ¶ä¸€ä»½æ‹·è´, æ¯”å¦‚ Linux ä¸­çˆ¶è¿›ç¨‹åˆ›å»ºäºè¿›ç¨‹æ—¶ ï¼Œ å¹¶ä¸æ˜¯ç«‹åˆ»è®©å­è¿›ç¨‹å¤åˆ¶ä¸€ä»½è¿›ç¨‹ç©ºé—´ï¼Œè€Œæ˜¯å…ˆè®©å­è¿›ç¨‹å…±äº«çˆ¶è¿› ç¨‹çš„è¿›ç¨‹ç©ºé—´ ï¼Œ åªæœ‰ç­‰åˆ°å­è¿›ç¨‹çœŸæ­£éœ€è¦å†™å…¥çš„æ—¶å€™æ‰å¤åˆ¶è¿›ç¨‹ç©ºé—´ã€‚

```rs
// æ˜¯ä¸€ä¸ªæšä¸¾ä½“çš„æ™ºèƒ½æŒ‡é’ˆ
// Borrowedï¼Œ ç”¨äºåŒ…è£¹å¼•ç”¨ã€‚è¡¨ç¤ºæ˜¯å¯¹æ•°æ®çš„å€Ÿç”¨
// Ownedï¼Œ ç”¨äºåŒ…è£¹æ‰€æœ‰è€…ã€‚è¡¨ç¤ºæ˜¯å¯¹æ•°æ®çš„æ‹¥æœ‰
// 
// ä»¥ä¸å¯å˜çš„æ–¹å¼è®¿é—®å€Ÿç”¨å†…å®¹ï¼Œä»¥åŠåœ¨éœ€è¦å¯å˜å€Ÿç”¨æˆ–æ‰€æœ‰æƒ çš„æ—¶å€™å†å…‹éš†ä¸€ä»½æ•°æ®
//æ—¨åœ¨å‡å°‘å¤åˆ¶æ“ä½œï¼Œæé«˜æ€§èƒ½ï¼Œ ä¸€èˆ¬ç”¨äºè¯»å¤šå†™å°‘çš„åœºæ™¯
// 
// - Cow<T>å®ç°äº† Derefï¼Œ è¿™æ„å‘³ç€å¯ä»¥ç›´æ¥è°ƒç”¨å…¶åŒ…å«æ•°æ®çš„ä¸å¯å˜ æ–¹æ³•ã€‚
// - to_mut æ–¹æ³•æ¥è·å–å¯å˜å€Ÿç”¨. 
//      è‹¥ T æ˜¯ å€Ÿç”¨, è¯¥æ–¹æ³•ä¼šäº§ç”Ÿå…‹éš†ï¼Œä½†ä»…å…‹éš†ä¸€æ¬¡ ï¼Œ å¦‚æœå¤šæ¬¡è°ƒç”¨ï¼Œåˆ™åªä¼šä½¿ç”¨ç¬¬ä¸€æ¬¡çš„å…‹éš†å¯¹è±¡
//      å¦‚æœ T æœ¬èº«æ‹¥æœ‰æ‰€æœ‰æƒï¼Œåˆ™æ­¤æ—¶è°ƒç”¨ to_mutä¸ä¼šå‘ç”Ÿå…‹éš†. æ‰€æœ‰æƒè½¬ç§»
// into_ownedæ–¹æ³•æ¥è·å–ä¸€ä¸ªæ‹¥æœ‰æ‰€æœ‰æƒçš„å¯¹è±¡
//      è‹¥ T æ˜¯å€Ÿç”¨, å‘ç”Ÿå…‹éš†ï¼Œäº•åˆ›å»ºæ–°çš„æ‰€æœ‰æƒå¯¹ è±¡
//      å¦‚æœ T æ˜¯æ‰€æœ‰æƒå¯¹è±¡ï¼Œ åˆ™ä¼šå°†æ‰€æœ‰æƒè½¬ç§»åˆ°æ–°çš„å…‹éš†å¯¹è±¡ã€‚


use std::borrow::Cow;
// æ±‚å…ƒç´ ç»å¯¹å€¼
fn abs_all(input: &mut Cow<[i32]>) {
    for i in 0..input.len() {
        let v = input[i];
        if v < 0 {
            // è·å–å¯å˜å¼•ç”¨
            //to_mut æ–¹æ³•ä¼šåœ¨ç¬¬ä¸€æ¬¡è°ƒç”¨æ—¶å…‹éš†ä¸€ä¸ªæ–°çš„å¯¹è±¡ï¼Œåœ¨åç»­çš„ for å¾ªç¯ä¸­ ç»§ç»­ç”¨æ–°çš„å…‹éš†å¯¹è±¡
            input.to_mut()[i] = -v;
        }
    }
}
// æ±‚å’Œ
fn abs_sum(ns: &[i32]) -> i32 {
    let mut lst = Cow::from(ns);
    abs_all(&mut lst);
    lst.iter().fold(0, |acc, &n| acc + n)
}
fn main() {
    let s1 = [1,2,3];
    let mut i1 = Cow::from(&s1[..]);
    // i1 ä¸­çš„å…ƒç´ éƒ½ä¸ºæ­£, ä¸ä¼šè¿›å…¥ifé€»è¾‘, ä¸æ¶‰åŠåˆ°å¯å˜éœ€æ±‚ï¼Œæ‰€ä»¥ä¸ä¼šå…‹éš†
    abs_all(&mut i1);
    println!("IN: {:?}", s1);//1,2,3
    println!("OUT: {:?}", i1);//1,2,3
    
    
    let s2 = [1,2,3, -45, 5];
    let mut i2 = Cow::from(&s2[..]);
    // è¿™é‡Œæœ‰å¯å˜éœ€æ±‚ï¼Œä¸”ç©¿è¿›cow çš„æ•°æ®æ˜¯ä¸ªå¼•ç”¨, æ²¡æœ‰æ‰€æœ‰æƒ, æ‰€ä»¥ä¼šå…‹éš†, i2 å®é™…æ˜¯å…‹éš†å‡ºçš„æ–°å¯¹è±¡
    abs_all(&mut i2);
    println!("IN: {:?}", s2);//[1, 2, 3, -45, 5]
    println!("OUT: {:?}", i2);//[1, 2, 3, 45, 5]
    
    // è¿™é‡Œä¸ä¼šå…‹éš†ï¼Œå› ä¸ºæ•°æ®æœ¬èº«æ‹¥æœ‰æ‰€æœ‰æƒ
    let mut v1 = Cow::from(vec![1,2,-3,4]);//v1æ˜¯æœ¬èº«å°±æ˜¯å¯å˜çš„
    abs_all(&mut v1);
    println!("IN/OUT: {:?}", v1);//[1, 2, 3, 4]
}


// å¦ä¸€ä¸ªç”¨å¤„æ˜¯ç»Ÿä¸€å®ç°è§„èŒƒ
use std::borrow::Cow;
use std::thread;
#[derive(Debug)]
struct Token<'a> {
    raw: Cow<'a, str>,//è¯¥ç”¨&strç±»å‹è¿˜æ˜¯ Stringç±»å‹å‘¢?ä¸ºäº†å¯»æ±‚ç»Ÿä¸€ï¼Œè¿™é‡Œä½¿ç”¨äº† Cow<T>
}
impl<'a> Token<'a> {
    pub fn new<S>(raw: S) -> Token<'a>
    where
        S: Into<Cow<'a, str>>,
   {
        Token { raw: raw.into() }
   }
}
fn main() {
   let token = Token::new("abc123");
   let token = Token::new("api.example.io".to_string());
// è¿˜å¯ä»¥è·¨çº¿ç¨‹å®‰å…¨ä¼ é€’
   thread::spawn(move || {
       println!("token: {:?}", token);
   }).join().unwrap();

//    ä½¿ç”¨åŠ¨æ€å­—ç¬¦ä¸²åˆ‡ç‰‡ï¼Œåˆ™ä¼šå› ä¸ºç”Ÿå‘½å‘¨æœŸçš„é—®é¢˜è€Œæ— æ³•è·¨çº¿ç¨‹å®‰å…¨ä¼ é€’
    //error
    let raw = String::from("abc");
    let s = &raw[..];
    let token = Token::new(s);
    thread::spawn(move || {
        println!("token: {:?}", token);
    }).join().unwrap();
}
```



## å‡½æ•°

### å‡½æ•°åŸºæœ¬è¯­æ³•

```rust
/// å¦‚æœä¸æŒ‡å®šè¿”å›å€¼ç±»å‹, é»˜è®¤ è¿”å›ç±»å‹ä¸º () ç©ºå…ƒç»„
// åŒåå‡½æ•°åœ¨å­˜åœ¨äºå¤šä¸ªä½œç”¨åŸŸ(æ¯”å¦‚ main å¤–, main å†…, main å†…çš„æ–°ä½œç”¨åŸŸ åˆ†åˆ«æœ‰ä¸‰ä¸ªåŒåå‡½æ•°), ä¼šå‘ç”Ÿå±è”½

fn sum(aa: i8, bb: i8) -> i8 {
    // è¿”å›å€¼æ˜ç¡®æŒ‡å®šç±»å‹
    // è‹¥å¸¦ return, å°±æ˜¯è¯­å¥, éœ€è¦åˆ†å·
    // return aa +bb;

    // ä¸å¸¦ return, å°±æ˜¯è¡¨è¾¾å¼, æ²¡æœ‰åˆ†å·
    aa + bb
}
let sum = sum(3, 9);
println!("sum = {}", sum);

// å‡½æ•°å‚æ•°æ”¯æŒæ¨¡å¼åŒ¹é…
fn a(mut b: [i32; 2]) { // å‚æ•°ä¸ºæ•°ç»„å¯å˜ç±»å‹, ä¸æ˜¯å¼•ç”¨ç±»å‹ (mut æ— æ³•æ”¾åœ¨å†’å·åé¢)
}

```


### å‡½æ•°ä½“è¡¨è¾¾å¼

```rust
let x = 1;

// å‡½æ•°ä½“è¡¨è¾¾å¼
let b = {
    let x = 2;
    // å—æœ«å°¾æ˜¯è¡¨è¾¾å¼, ä¸æ˜¯è¯­å¥, æ²¡æœ‰åˆ†å·, æ²¡æœ‰ return
    x + 1
    // return x + 1;
};
println!("x = {}", x); //1
println!("b = {}", b); //3
```

### å‡½æ•°ä½œä¸ºå‚æ•°

```rust
//
    // å‡½æ•°ä½œä¸ºå‚æ•°ä¼ é€’
    //
    fn inc1(num: i32) -> i32 { num + 1}
    fn print_num(num: i32, func: fn(i32) ->i32) {
        println!("{}", func(num));
    }
    print_num(1, inc1);

// mut å‚æ•°
// è¿™é‡Œå½¢å¼å‚æ•°ç±»å‹å¹¶éå¼•ç”¨, æ‰€ä»¥ä¼ å…¥å®é™…å‚æ•°æ—¶, ä¼šè½¬ç§»æ‰€æœ‰æƒ, å®é™…å‚æ•°æ˜¯ä¸æ˜¯ mut éƒ½å¯ä»¥
fn modify (mut v: Vec<u32> ) - > Vec<u32>
// è¿™é‡Œå½¢å‚ä¸ºå¼•ç”¨, æ‰€ä»¥å®é™…å‚æ•°å¿…é¡»ä¸º & mut
fn modify(v: &mut [u32]) ;


// å‡½æ•°å‚æ•°æ”¯æŒæ¨¡å¼åŒ¹é…
// (å‡½æ•°ä¸­çš„å‚æ•°ç­‰ä»·äºä¸€ä¸ªéšå¼çš„ letç»‘å®šï¼Œè€Œ letç»‘å®šæœ¬èº«æ˜¯ä¸€ä¸ªæ¨¡å¼åŒ¹é…çš„è¡Œä¸º)
#[derive(Debug)]
struct S { i: i32 }
//è¡¨ç¤º å‚æ•°ä¸ºä¸å¯å˜å¼•ç”¨, ç›¸å¯¹çš„, ref mut è¡¨ç¤ºå‚æ•°ä¸ºå¯å˜å¼•ç”¨
fn f(ref _s: S) {
    println!("{:p}", _s); //0x7ffdd1364b80
}
fn main() {
    let s = S { i: 42 };
    f(s);
    // error, æ‰€æœ‰æƒè½¬ç§»
    println!("{:?}", s);
}

// åˆ©ç”¨äº†æ¨¡å¼åŒ¹é…æ¥è§£æ„å…ƒç»„
fn swap((x, y) : (&str, i32)) {}



```

### Result è¿”å›å€¼

```rust

// å³ä¾¿æ˜¯æ²¡æœ‰æ˜¾å¼è¿”å›å€¼çš„å‡½æ•°ï¼Œå…¶å® ä¹Ÿç›¸å½“äºè¿”å›äº†ä¸€ä¸ªå•å…ƒå€¼()ã€‚å¦‚æœéœ€è¦è¿”å›å¤šä¸ªå€¼ï¼Œäº¦å¯ä½¿ç”¨å…ƒç»„ç±»å‹



/// å‡½æ•°è¿”å›å€¼ Result<T, E> è§ error_handling
/// 
/// 
```

### ç¼–è¯‘æœŸå‡½æ•°æ‰§è¡Œ cfe

```rust


    // ç¼–è¯‘æ—¶å‡½æ•°æ‰§è¡Œ, ç®€ç§° cfe
    //å‡½æ•°ä¼šåœ¨ç¼–è¯‘æœŸè¢«æ‰§è¡Œ, è®¡ç®—å‡ºå¸¸é‡ç»“æœ
    const fn const_fn() -> u8 {2};
    let arr = [0u8, const_fn()];



```

### å‘æ•£å‡½æ•° 

æ„Ÿå¹å· æƒŠå¹å·

```rust


/// å‘æ•£å‡½æ•°: è¿”å›å€¼ç±»å‹ä¸º "!" (never type), æ ‡è¯†å‡½æ•°æ°¸è¿œä¸ä¼šè¿”å›å€¼, æ¯”å¦‚ å‡½æ•°åŒ…å«æ­»å¾ªç¯, æˆ–è€… panic
///     å‘æ•£å‡½æ•°å¯ä»¥ä½œä¸ºä»»ä½•ç±»å‹. åº”ç”¨:å¯ä»¥åœ¨æ­£å¸¸æœ‰è¿”å›å€¼å‡½æ•°ä¸­ panic, åœ¨if åˆ¤æ–­ä¸­ panic (å› ä¸º panic è¿”å›ç±»å‹ä¸º never type)
///     https://www.zhihu.com/question/54540714/answer/146231560
/// 

```

### æ³›å‹å‡½æ•°

```rs
//è°ƒç”¨æ—¶, ç¼–è¯‘å™¨æ¥è¿›è¡Œè‡ªåŠ¨æ¨æ–­
// æ— æ³•è‡ªåŠ¨æ¨æ–­, åˆ™éœ€è¦æ˜¾å¼æŒ‡å®š, å¦‚ä¸ºæ¥æ”¶çš„å˜é‡æŒ‡å®šç±»å‹, æˆ–è€…æ–¹æ³•è°ƒç”¨çš„æ—¶å€™, ä½¿ç”¨ turbofishæ“ä½œç¬¦
let a: i32 = square(37 , 41) ;
let a= square::<u32>(37, 41)
```


### é«˜é˜¶å‡½æ•°


#### å‡½æ•°æŒ‡é’ˆ


```rs
// å‡½æ•°æŒ‡é’ˆ
// 
// 
// å‡½æ•°å¯ä»¥ä½œä¸ºå‚æ•°è¿›è¡Œä¼ é€’
// å®ç°è¿™ä¸€åˆ‡çš„åŸºç¡€åœ¨äº Rustæ”¯æŒç±»ä¼¼ CIC++è¯­è¨€ä¸­çš„å‡½æ•°æŒ‡é’ˆ
fn math(op: fn(i32, i32) -> i32, a: i32, b: i32) -> i32
// 
fn hello(){
    println!("hello function pointer");
}
fn main(){
    // å¿…é¡»æ˜¾å¼æŒ‡å®šå‡½æ•°æŒ‡é’ˆç±»å‹ fn()
    let fn_ptr: fn() = hello;
    println!("{:p}", fn_ptr); // 0x562bacfb9f80
    // è‹¥æ²¡æŒ‡å®šå‡½æ•°æŒ‡é’ˆç±»å‹, å°±ä¸æ˜¯æŒ‡é’ˆ, other_fn çš„ç±»å‹å®é™…ä¸Šæ˜¯ fn() {hello}ï¼Œè¿™å…¶å®æ˜¯å‡½æ•° hello æœ¬èº«çš„ç±»å‹ï¼Œè€Œéå‡½æ•°æŒ‡é’ˆç±»å‹
    let other_fn = hello;
    // error
    println!("{:p}", other_fn);  // not function pointer
    
    hello();
   other_fn();
   fn_ptr();
   (fn_ptr)();
}

// å¯¹äºå‡½æ•°æŒ‡é’ˆç±»å‹ï¼Œå¯ä»¥ä½¿ç”¨ type å…³é”®å­—ä¸ºå…¶å®šä¹‰åˆ«å 
type MathOp = fn (i32 ï¼Œ i32) - > i32
fn math(op: MathOp, a: i32, b: i32) -> i32
fn math(op: &str) -> MathOp



```

#### ç¦æ­¢å‡½æ•°æ•è·å¤–éƒ¨ç¯å¢ƒä¸­å˜é‡

```rs
// error, // å› ä¸ºå‡½æ•°ä¸èƒ½æ•æ‰åŠ¨æ€ç¯å¢ƒä¸­çš„å˜é‡i, å˜é‡ ç»‘å®š i ä¼šéšç€å¸§çš„é‡Šæ”¾è€Œé‡Šæ”¾ï¼Œéœ€è¦é—­åŒ…æ‰å¯ä»¥æ•è·
fn counter(i: i32) -> fn(i32) -> i32 {
    fn inc(n: i32) -> i32 {
        n + i  // error[E0434]: can't capture dynamic environment in a fn item
    }
    inc
}
fn main() {
    let f = counter(2);
    assert_eq!(3, f(1));
}

// æ­£ç¡®, 
fn counter() -> fn(i32) -> i32 {
    fn inc(n: i32) -> i32 {
        n + 1
    }
    inc
}
fn main() {
    let f = counter();
    assert_eq!(2, f(1));
}

// è‹¥æœä¸€å®šè¦æ•è·ç¯å¢ƒå˜é‡, éœ€è¦é—­åŒ…
// 2015 edition:
fn counter(i: i32) -> Box<Fn(i32) -> i32> {//æ”¾åˆ°äº† Box<T>ä¸­ï¼Œ å› ä¸ºé—­åŒ…çš„å¤§ å°åœ¨ç¼–è¯‘æœŸæ˜¯æœªçŸ¥çš„
    Box::new(move |n: i32| n + i )
}
// or 2018:
// ä»¥å¤§å†™å­—æ¯ F å¼€å¤´çš„ Fn å¹¶ä¸æ˜¯å‡½æ•°æŒ‡é’ˆç±»å‹ Fn(i32)->i32ï¼Œ å®ƒæ˜¯ä¸€ä¸ªtrait
fn counter(i: i32) -> impl Fn(i32) -> i32 {//åŠ¨æ€å¤§å°ç±»å‹  impl Trait, è¿™æ ·å°±ä¸éœ€è¦ä½¿ç”¨ Box<T>äº†
    move |n: i32|{ n + i }
}


```

## é—­åŒ…

### é—­åŒ…åŸºæœ¬ä½¿ç”¨

```rust
///é—­åŒ… (åŒ¿åå‡½æ•°): æ˜¯ä¸€ä¸ªæŒæœ‰å¤–éƒ¨ç¯å¢ƒå˜é‡çš„å‡½æ•°ã€‚ å¤–éƒ¨ç¯å¢ƒæ˜¯æŒ‡é—­åŒ…å®šä¹‰æ—¶æ‰€åœ¨çš„è¯æ³•ä½œç”¨åŸŸ
/// 
/// å»¶è¿Ÿæ‰§è¡Œ ã€‚
// æ•è·ç¯å¢ƒå˜é‡ ã€‚é—­åŒ…ä¼šè·å–å…¶å®šä¹‰æ—¶æ‰€åœ¨ä½œç”¨åŸŸä¸­çš„è‡ªç”±å˜ é‡ ï¼Œä»¥ä¾›ä¹‹åè°ƒç”¨æ—¶ä½¿ç”¨
/// 
// ä¸¤ä¸ªå®šä¹‰ä¸€æ¨¡ä¸€æ ·çš„é—­åŒ… ä¹Ÿå¹¶ä¸ä¸€å®šå±äºåŒ ä¸€ç§ç±»å‹, æ— æ³•å°†å®ƒä»¬ä¿å­˜åˆ°ä¸€ä¸ªæ•°ç»„ä¸­ã€‚å› ä¸ºæ•°ç»„åªèƒ½ä¿ å­˜ç›¸åŒç±»å‹çš„å…ƒç´ 
/// 
fn closure_demo() {
    println!("------------------------ closure demo");
    
    let inc = |num: i32| -> i32 { ////è¿”å›å€¼ç±»å‹æ¨å¯¼: æ— è®ºåé¢æ˜¯å¦è¢«è°ƒç”¨, è¿”å›å€¼éƒ½å¯çœç•¥, ä½†æ˜¯æ— æ³•ä¸¤æ¬¡æ¨å¯¼ä¸åŒçš„å‚æ•°/è¿”å›å€¼ç±»å‹
        num + 1
    };
    // num çš„å‚æ•°ç±»å‹å¯ä»¥çœç•¥, è¿”å›å€¼ç±»å‹å¯ä»¥çœç•¥, èŠ±æ‹¬å·å¯ä»¥çœç•¥; 
    //è¿™æ˜¯å› ä¸ºåé¢ print_num å‡½æ•°ä¸­å·²ç»æœ‰ç±»å‹ä¿¡æ¯äº†, å•ç‹¬å®šä¹‰é—­åŒ…, æ²¡æœ‰åé¢çš„è°ƒç”¨ä¿¡æ¯, åˆ™å‚æ•°ç±»å‹ä¸èƒ½çœ
    let inc0 = |num| num+1

    fn inc1(num: i32) -> i32 { num + 1} 
    // å‡½æ•°ä½œä¸ºå‚æ•°ä¼ é€’
    fn print_num(num: i32, func: fn(i32) ->i32) {
        println!("{}", func(num));
    }
    print_num(1, inc1);
    print_num(1, inc);
    print_num(1, inc0)

```

### rust å®ç°é—­åŒ…çš„åŸç†

```rs
// åœ¨ Rust ä¸­ï¼Œé—­åŒ…æ˜¯ä¸€ç§è¯­æ³•ç³–, æ˜¯åœ¨åŸºæœ¬è¯­æ³•åŠŸèƒ½ä¹‹ä¸Šåˆæä¾›çš„ä¸€å±‚æ–¹ä¾¿å¼€å‘è€…ç¼–ç¨‹çš„è¯­æ³•
// 
// æœ€åˆé—­åŒ…æ˜¯é€šè¿‡  è£…ç®±( Boxed) é—­åŒ… å®ç°çš„, æ€§èƒ½å·®, LLVM éš¾ä»¥å¯¹å…¶è¿›è¡Œå†…è”å’Œä¼˜åŒ–ã€‚
// å¦‚: é—­åŒ… || {a+b} çš„å®ç°å¯ä»¥é€šè¿‡å‡½æ•°æŒ‡é’ˆ å’Œæ•è·å˜é‡æŒ‡é’ˆç»„åˆæ¥å®ç°ã€‚æŒ‡é’ˆæ”¾stackä¸Šï¼Œæ•è·å˜é‡æ”¾åˆ°å †ä¸Š



// éè£…ç®± CUnboxed) é—­åŒ… (ç°åœ¨çš„å®ç°æ–¹å¼): æ”¯æŒé—­åŒ…æŒ‰å€¼å’ŒæŒ‰å¼•ç”¨ç»‘å®šç¯å¢ƒå˜é‡ ; æ”¯æŒä¸‰ç§ä¸åŒçš„é—­åŒ…è®¿é—®ï¼Œ å¯¹åº” selfã€&selfå’Œ&mut selfä¸‰ç§æ–¹æ³•
// å°†å‡½æ•°è°ƒç”¨æŠ½è±¡ä¸ºä¸‰ç§, æ–°å¢ä¸‰ä¸ª trait è¡¨ç¤º
// 
// è¿™æ ·, æ–¹æ³•è°ƒç”¨ a(b, c, d)å˜ä¸ºä¸€ä¸‹ä¸‰ç§æ‰§è¡Œæ–¹å¼:
// 
// Fn::call(&a, (b, c, d))          - è°ƒç”¨ å‚æ•°ä¸º &selfï¼Œ è¿™æ„å‘³ç€å®ƒä¼šå¯¹æ–¹æ³•æ¥æ”¶è€…è¿›è¡Œä¸å¯å˜å€Ÿç”¨ ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œè¿™ç§æ–¹æ³•è°ƒç”¨å¯ä»¥è¢«è°ƒç”¨å¤šæ¬¡ã€‚
// FnMut::callmut(&muta, (b, c, d)) - è°ƒç”¨å‚æ•°ä¸º& mut selfï¼Œè¿™æ„å‘³ç€å®ƒä¼šå¯¹æ–¹æ³•æ¥æ”¶è€…è¿›è¡Œå¯å˜å€Ÿç”¨
// FnOnce::call once(a, (b, c, d)) - è°ƒç”¨å‚æ•°ä¸º selfï¼Œè¿™æ„å‘³ç€å®ƒä¼šè½¬ç§»æ–¹æ³•æ¥æ”¶è€…çš„æ‰€æœ‰æƒã€‚æ¢å¥è¯è¯´ï¼Œå°±æ˜¯è¿™ ç§æ–¹æ³•è°ƒç”¨åªèƒ½è¢«è°ƒç”¨ ä¸€æ¬¡
// 
// ç°åœ¨å®ç°é—­åŒ…å°±ç®€å•äº†, ç›´æ¥å®šä¹‰ä¸€ä¸ª struct è¡¨ç¤º é—­åŒ…, å†…éƒ¨ä½¿ç”¨ä¸€ä¸ªå­—æ®µè¡¨ç¤ºæ•è·çš„è‡ªç”±å˜é‡, åœ¨è°ƒç”¨çš„æ—¶å€™ä½¿ç”¨è¿™ä¸ªå˜é‡å³å¯
// å®é™…ä¸Š, é—­åŒ…è¡¨è¾¾å¼ä¼šç”±ç¼–è¯‘å™¨è‡ªåŠ¨ç¿»è¯‘ä¸ºç»“æ„ä½“å®ä¾‹ï¼Œå¹¶ä¸ºå…¶å®ç° Fnã€FnMutã€FnOnceä¸‰ä¸ª trait ä¸­çš„ ä¸€ä¸ª
// æ‰‹åŠ¨å®ç°å¦‚ä¸‹:
#![feature(unboxed_closures, fn_traits)]
struct Closure {
    env_var: u32,
}
impl FnOnce<()> for Closure {
    type Output = u32;
    // å°†å‡½æ•°å‚æ•°ä¸­çš„å…ƒ ç»„ç±»å‹åšåŠ¨æ€æ‰©å±•ï¼Œä»¥ä¾¿æ”¯æŒå¯å˜é•¿å‚æ•°ã€‚
    // å› ä¸ºåœ¨ Fnã€ FnMutã€ FnOnce è¿™ä¸‰ä¸ª trait é‡Œçš„æ–¹ æ³•è¦æ¥æ”¶é—­åŒ…çš„å‚æ•°ï¼Œè€Œç¼–è¯‘å™¨æœ¬èº«å¹¶ä¸å¯èƒ½çŸ¥é“å¼€å‘è€…ç»™é—­åŒ…è®¾å®šçš„å‚æ•°ä¸ªæ•°ï¼Œæ‰€ä»¥è¿™é‡Œ åªèƒ½ä¼ å…ƒç»„ï¼Œç„¶åç”± rust-callABIåœ¨åº•å±‚åšåŠ¨æ€æ‰©å±•
    // éœ€è¦ unboxed closuresç‰¹æ€§æ”¯æŒ
    extern "rust-call" fn call_once(self, args: ()) -> u32 {
        println!("call it FnOnce()");
        self.env_var + 2
    }
}
impl FnMut<()> for Closure {
    extern "rust-call" fn call_mut(&mut self, args: ()) -> u32 {
        println!("call it FnMut()");
        self.env_var + 2
    }
}
impl Fn<()> for Closure {
    extern "rust-call" fn call(&self, args: ()) -> u32 {
        println!("call it Fn()");
        self.env_var + 2
    }
}
let env_var = 1;
let mut c = Closure { env_var: env_var };
// ç»“æ„ä½“å®ä¾‹å¯ä»¥åƒå‡½æ•°é‚£æ ·è¢«è°ƒç”¨, å› ä¸º å®šä¹‰æ–¹æ³•æ—¶å€™, ä½¿ç”¨äº† extern å…³é”®å­—ï¼Œè¡¨ç¤ºä½¿ç”¨æŒ‡å®šçš„ ABI (Application Binary Interfaceï¼Œ ç¨‹ åºäºŒè¿›åˆ¶æ¥å£)
c();
c.call(());
c.call_mut(());
c.call_once(());
```


### æ•è·ç¯å¢ƒå˜é‡ and ä¸‰ç§é—­åŒ…ç±»å‹

```rust
/// é—­åŒ…ä¸­å¯ä»¥æ•è·å¤–éƒ¨ç¯å¢ƒä¸­çš„å˜é‡

    //æ•è·ç¯å¢ƒå˜é‡
    // æœ‰ä¸‰ç§æ–¹å¼, æ ¹æ®æ•è·å˜é‡æ–¹å¼ä¸åŒ, å°†é—­åŒ…å®šä¹‰ä¸ºä¸‰ç§ trait:
    // 
    // Fnï¼Œè¡¨ç¤ºé—­åŒ…ä»¥ä¸å¯å˜å€Ÿç”¨çš„æ–¹å¼æ¥æ•è·ç¯å¢ƒä¸­çš„è‡ªç”±å˜ é‡ ï¼ŒåŒæ—¶ä¹Ÿè¡¨ç¤º è¯¥é—­ åŒ…æ²¡æœ‰ æ”¹å˜ç¯å¢ƒçš„èƒ½åŠ› ï¼Œ å¹¶ä¸”å¯ä»¥å¤šæ¬¡è°ƒç”¨ã€‚é—­åŒ…æ¥æ”¶è€…æ˜¯ä¸å¯å˜å¼•ç”¨, å¯¹åº” &selfã€‚
    //                  ç­‰å·å³ä¾§é—­åŒ…è¡¨è¾¾å¼  æ²¡åŠ  move, å†…éƒ¨æ— å†™æ“ä½œ
    //              æœªæ•è·ä»»ä½•ç¯å¢ƒå˜é‡çš„é—­åŒ…ä¼šè‡ªåŠ¨å®ç° Fn
    //              æ•è·çš„è‡ªç”±å˜é‡è‹¥ä¸ºå¤åˆ¶è¯­ä¹‰ç±»å‹, åˆ™é—­åŒ…å®ç°äº† Fn (ä¸éœ€è¦å¯¹å¤–éƒ¨å˜é‡è¿›è¡Œå†™æ“ä½œ)
    //              ä½¿ç”¨ move å…³é”®å­—åˆ™è‡ªåŠ¨å®ç° Fn
    // FnMutï¼Œè¡¨ç¤ºé—­åŒ…ä»¥å¯å˜å€Ÿç”¨çš„æ–¹å¼æ¥æ•è·ç¯å¢ƒä¸­çš„è‡ªç”±å˜ é‡ ï¼ŒåŒæ—¶æ„å‘³ ç€è¯¥ é—­åŒ…æœ‰ æ”¹å˜ç¯å¢ƒçš„èƒ½åŠ› ï¼Œä¹Ÿå¯ä»¥ å¤šæ¬¡ è°ƒç”¨ ã€‚ é—­åŒ…æ¥æ”¶è€…æ˜¯å¯å˜å¼•ç”¨, å¯¹åº”&mut selfã€‚
    //                      æ²¡åŠ  move, å†…éƒ¨æœ‰å†™æ“ä½œ
    //                     ä¿®æ”¹ç¯å¢ƒå˜é‡ä»¥è‡ªåŠ¨å®ç° FnMut
    // FnOnceï¼Œ è¡¨ç¤ºé—­åŒ…é€šè¿‡è½¬ç§»æ‰€æœ‰æƒæ¥æ•è·ç¯å¢ƒä¸­çš„è‡ªç”±å˜é‡ï¼ŒåŒæ—¶æ„å‘³ç€è¯¥é—­åŒ…æ²¡ æœ‰æ”¹å˜ç¯å¢ƒçš„èƒ½åŠ›ï¼Œåªèƒ½è°ƒç”¨ä¸€æ¬¡ï¼Œå› ä¸ºè¯¥é—­åŒ…ä¼šæ¶ˆè€—è‡ªèº«ã€‚é—­åŒ…æ¥æ”¶è€…æ˜¯å€¼, å¹¶éå¼•ç”¨, å¯¹åº” selfã€‚
    //                      åŠ äº† move
    //              ç”±äºæ‰€æœ‰æ‰€æœ‰é—­åŒ…éƒ½å¯ä»¥è‡³å°‘è°ƒç”¨ä¸€æ¬¡, æ‰€ä»¥æ¶‰åŠåˆ°æ•è·ç¯å¢ƒå˜é‡ çš„æ‰€æœ‰é—­åŒ…éƒ½å®ç°äº† FnOnce 
    //
    // 
    // ä¸‰ç§ trait åŒ…å«å…³ç³»: fn å±äº(ç»§æ‰¿äº) fnmut å±äº(ç»§æ‰¿äº) fnonce;
    // ï¼Œå¦‚æœè¦å®ç° Fnï¼Œ å°±å¿…é¡»å®ç° FnMutå’Œ FnOnce;å¦‚æœè¦å®ç° FnMut, å°±å¿…é¡»å®ç° FnOnce; å¦‚æœåªéœ€è¦å®ç° FnOnceï¼Œ å°±ä¸éœ€è¦å®ç° FnMut å’Œ Fn
    // 
    // 
    // 
    // é—­åŒ…æ•è·å…¶ç¯å¢ƒå˜é‡çš„æ–¹å¼:
    // 
    // å¯¹äºå¤åˆ¶è¯­ä¹‰ç±»å‹ ï¼Œè‹¥ è¡¨è¾¾å¼åŠ äº† move , ä»¥ copy çš„å½¢å¼è¿›è¡Œæ•è·
    //                  è‹¥æœªåŠ  move, ä»¥ å¼•ç”¨/å¯å˜å¼•ç”¨ çš„å½¢å¼è¿›è¡Œæ•è·
    // 
    // å¯¹äºç§»åŠ¨è¯­ä¹‰ç±»å‹ ï¼Œè½¬ç§»æ‰€æœ‰æƒæ¥è¿›è¡Œæ•è· (æ— è®ºåŠ æ²¡åŠ  move)
    //              ç§»åŠ¨è¯­ä¹‰ç±»å‹è‡ªåŠ¨å®ç°äº† FnOnce
    // 
    // å¯¹äºå¯å˜ç»‘å®šï¼Œå¹¶ä¸”åœ¨é—­åŒ…ä¸­åŒ…å«å¯¹å…¶è¿›è¡Œä¿®æ”¹çš„æ“ ä½œï¼Œåˆ™ä»¥å¯ å˜å¼•ç”¨ (&mut T) æ¥è¿›è¡Œæ•è· ã€‚
    // 
    // 
    // 
    let mut i = 1;
    // ä¿®æ”¹äº† è‡ªç”±å˜é‡, æ²¡åŠ  move, é—­åŒ…ä¸º FnMut, éœ€è¦å£°æ˜ä¸º å¯å˜
    let mut func =  || {
        i+=1;
    };
    func();
    println!("{}", i);//2

    let mut i = 1;
    let mut plus_one = move || {// move å¯é€‰, æ¶‰åŠåˆ°å¤šçº¿ç¨‹å¹¶å‘, ä¸€å®šè¦åŠ  move, i æ‰€æœ‰æƒç§»åŠ¨åˆ°é—­åŒ…, å¯¹äºåŸºæœ¬ç±»å‹, ç›¸å½“äºå¤åˆ¶äº†ä¸€ä»½, åœ¨é—­åŒ…å†…çš„æ“ä½œä¸å½±å“å¤–éƒ¨çš„ i
        i += 1;                // ä½†æ˜¯  , è‹¥æœ‰è¿”å›å€¼, å°±å˜ä¸ºå¤åˆ¶å¼•ç”¨äº†
    };
    plus_one(); 
    println!("i = {}", i); //1,  

    
    //
    // å¯¹äºå¤æ‚ç±»å‹çš„ æ•è·
    //
    let v = vec![1,2,3];
    let eq = move |x| x==v; // vçš„æ‰€æœ‰æƒç§»åŠ¨åˆ°äº†é—­åŒ…å†…éƒ¨, å¤–éƒ¨çš„ v å¤±æ•ˆäº†
    println!("eq? {}", eq(vec![1,2,3]));//true
    println!("v = {:?}", v);// é”™è¯¯, borrow of moved value: `v`





// æ›´å¤šç¤ºä¾‹å¯¹æ¯”

let mut i = 11;
// æ²¡æœ‰ move, é—­åŒ…å†…éƒ¨æ˜¯ å¼•ç”¨, 
let mut fu1 = || i += 1;
fu1();
println!("{}", i) //12

//-----------Moveçš„æƒ…å†µ----------- (å¯¹äºåŸºæœ¬ç±»å‹, å®ç°äº† copy trait, æ˜¯ copy, å¯¹äº ç¬¦åˆç±»å‹, è‹¥æ²¡æœ‰å®ç° copy trait, åˆ™æ‰€æœ‰æƒè½¬ç§»)
// å­˜åœ¨ move, é—­åŒ…å†…æ˜¯å¤åˆ¶
let mut fu1 = move || i += 1; // å±€éƒ¨å˜é‡è¢«ä¸¢å¼ƒ
fu1();
println!("{}", i);//11


// å­˜åœ¨è¿”å›å€¼çš„æƒ…å†µ
let mut fu = || {
    i += 1;
    i
};
fu();
println!("{}", i)//12
//-----------Moveçš„æƒ…å†µ-----------
let mut fu = move || {
    i += 1;
    i
};
fu();
println!("{}", i)//11




//å¯¹äºæ²¡æœ‰å®ç° Copy çš„ å¤åˆç±»å‹ï¼Œ
// åœ¨é—­åŒ…ä¸­å¯ä»¥è°ƒç”¨å…¶æ–¹æ³•ï¼Œæ˜¯â€œå€Ÿç”¨â€ï¼Œ
// å­˜åœ¨è¿”å›å€¼, è¿”å›å€¼äº†å°±å‘ç”Ÿæ‰€æœ‰æƒè½¬ç§», å› ä¸º è¿”å›å€¼æœ‰å¯èƒ½åœ¨åˆ«çš„åœ°æ–¹ä½¿ç”¨, ä¸ºäº†å®‰å…¨, æ‰€æœ‰æƒè½¬ç§»äº†
//
//
let s = String::from("coolshell");
let take_str = || s; // ç§»åŠ¨
println!("{}", s); //ERROR
println!("{}",  take_str()); // OK

let mut s1 = String::from("hello");
let mut change_s1 = || s1.push('!');// æ²¡æœ‰è¿”å›å€¼, ä¸ä¼šç§»èµ°, åªä¼šå¯å˜å€Ÿç”¨
println!("{}", s1);// error, å•ç‹¬å‡ºç°æ²¡é”™, ä½†æ˜¯å’Œä¸‹é¢å‡½æ•°è°ƒç”¨ä¸€èµ·å‡ºç°å‡ºé”™äº†, å¯å˜å€Ÿç”¨å, æ²¡æ³•è¿›è¡Œä¸å¯å˜å€Ÿç”¨äº†
change_s1();
println!("{}", s1);// hello!



struct Person {
    name: String,
    age: u8,
}
let p = Person{name: "xiaoyu".to_string(), age: 11};
let age = |p: Person| p.age; // å­˜åœ¨è¿”å›å€¼, æ‰€æœ‰æƒç§»åŠ¨
println!("{}", age(p));
let name = |p: Person| p.name;
println!("{}", name(p));// name(p)ç¼–è¯‘é”™è¯¯, p ä¸¢å¤±æ‰€æœ‰æƒ

// æ”¹ä¸º å¼•ç”¨ç‰ˆæœ¬
//
// å¯¹äº åŸºæœ¬ç±»å‹ çš„å±æ€§, å­˜åœ¨ copy trait, è¿”å›çš„æ˜¯ copy
let age = |p: &Person| p.age;
// ç°åœ¨å¯ä»¥é‡å¤ä½¿ç”¨äº†
println!("{}", age(&p));
println!("{}", age(&p));

// é”™è¯¯, å› ä¸ºname ä¸º string ç±»å‹, æ²¡æœ‰ copy trait
// å‡½æ•°ç»“æŸ, p.name è¢«é‡Šæ”¾, å‡ºé”™, è‹¥å­˜åœ¨ copy trait, ä¼šè¿”å› å¤åˆ¶, æ²¡æœ‰ copy trait, åªèƒ½é€šè¿‡è¿”å›å¼•ç”¨è§£å†³
let name = |p: &People| p.name;
// è§£å†³: ç”Ÿå‘½å‘¨æœŸ, å»¶ç¼“ p.name  è¢«é‡Šæ”¾çš„æ—¶é—´
let name: for <'a> fn(&'a Person) -> &'a String = |p: &Person| & p.name;// é—­åŒ…è¿”å›å€¼å¿…é¡»ä¸ºå¼•ç”¨, ä¸èƒ½æŠŠ name move èµ°
//or ; å‚æ•°ç±»å‹çœç•¥äº†
let name: for<'a> fn(&'a People) -> &'a String = |p| &p.name;



```


### é—­åŒ…ä½œä¸ºè¿”å›å€¼ or å‚æ•°


#### é€ƒé€¸é—­åŒ… éé€ƒé€¸é—­åŒ…


```rust

// Box<Fn()>æ˜¯ä¸€ä¸ª traitå¯¹è±¡, 
// traitå¯¹è±¡æ˜¯åŠ¨æ€åˆ†å‘çš„ï¼Œåœ¨è¿è¡Œæ—¶é€šè¿‡æŸ¥æ‰¾è™šè¡¨( vtableã€•æ¥ç¡®å®šè°ƒç”¨å“ªä¸ªé—­åŒ…
fn boxed_closure(c: &mut Vec<Box<Fn()>>){
    let s = "second";
    c.push(Box::new(|| println!("first")));
    // éœ€è¦å°† s copy ä¸€ä»½, åœ¨æ–¹æ³•å¤–ä½¿ç”¨
    c.push(Box::new(move || println!("{}", s)));//é€ƒé€¸é—­åŒ… (escapeclosure): åœ¨å‡½æ•°æ ˆå¸§ç»“æŸåæ‰ä½¿ç”¨çš„é—­åŒ…, å¦‚æœæ˜¯è·Ÿéšå‡½æ•°ä¸€èµ·è°ƒç”¨çš„é—­åŒ…ï¼Œ åˆ™ æ˜¯éé€ƒé€¸é—­åŒ… (non-escape closure)ã€‚
    c.push(Box::new(|| println!("third")));
}
fn main(){
    let mut c: Vec<Box<Fn()>> = vec![];
    boxed_closure(&mut c);
    for f in c {
        f(); // first / second / third
    }
}


```

#### é—­åŒ…ä½œä¸ºå‚æ•°

```rs
// å®ç° vec.any æ¡ä»¶åŒ¹é…

// é€šè¿‡æ³›å‹, å®ç°é™æ€åˆ†å‘
use std::ops::Fn;
trait Any {
    fn any<F>(&self,  f: F) -> bool where
        Self: Sized,//å½“Anyè¢«ä½œä¸º trait å¯¹è±¡ä½¿ç”¨æ—¶ï¼Œè¯¥æ–¹æ³•ä¸èƒ½è¢«åŠ¨æ€è°ƒç”¨, åªèƒ½é™æ€åˆ†å‘ï¼Œè¿™å±äºä¸€ç§ä¼˜åŒ–ç­–ç•¥
        F: Fn(u32) -> bool;
}
impl Any for Vec<u32> {
    fn any<F>(&self, f: F) -> bool where
    Self: Sized,
   F: Fn(u32) -> bool
   {
       for &x in self {
           if f(x) {
               return true;
           }
       }
       false
   }
}
fn main(){
    let  v = vec![1,2,3];
    let b = v.any(|x| x == 3);
    println!("{:?}", b);
}


// é€šè¿‡å°†é—­åŒ…ä½œä¸º trait å¯¹è±¡çš„æ–¹å¼, å®ç°åŠ¨æ€åˆ†å‘
// ä»£ç æ›´åŠ ç®€ç»ƒ, åŠ¨æ€åˆ†å‘æ¯”é™æ€åˆ†å‘çš„æ€§èƒ½ ä½ ä¸€äº›, ä½†å®Œå…¨å¯ä»¥æ¥å—
trait Any {
  fn any(&self,  f: &(Fn(u32) -> bool)) -> bool;// &(Fn(u32) -> bool) å³ä¸º trait object
}
impl Any for Vec<u32> {
    fn any(&self, f: &(Fn(u32) -> bool)) -> bool {
        for &x in self.iter() {
            if f(x) {
                return true;
            }
       }
      false
   }
}
fn main(){
   let  v = vec![1,2,3];
   let b = v.any(&|x| x == 3);
   println!("{:?}", b);
}

```

#### é—­åŒ…ä½œä¸ºè¿”å›å€¼


```rs
// ä½œä¸ºè¿”å›å€¼, å¿…é¡»ä½¿ç”¨ traitå¯¹è±¡
fn square() -> Box<Fn(i32) -> i32> {
    Box::new(|i| i*i )
}

// error
// å¯¹äºç¼–è¯‘æœŸæ— æ³•ç¡®å®šå¤§å°çš„å€¼ï¼Œä¸èƒ½ç§»åŠ¨å…¶æ‰€æœ‰æƒ
// å¦‚æœè¦è°ƒç”¨é—­åŒ… Box<Fn0nce(i32)->i32>ï¼Œ å°±å¿…é¡»å…ˆæŠŠ Fn0nce(i32)->i32 ä» Box<T>ä¸­ç§»å‡º æ¥ã€‚è€Œæ­¤æ—¶ Box<T>ä¸­çš„ Tæ— æ³•åœ¨ç¼–è¯‘æœŸç¡®å®šå¤§å°ï¼Œä¸èƒ½ç§»åŠ¨æ‰€æœ‰æƒï¼Œæ‰€ä»¥å°±æŠ¥é”™
fn square() -> Box<FnOnce(i32) -> i32> {
    Box::new( |i| {i*i })
}
// æ­£ç¡®
// ä½¿ç”¨ impl trait çš„æ–¹å¼
fn square() -> impl FnOnce(i32) -> i32 {
    |i| {i*i }
}



//è¿”å›çš„é—­åŒ…è¿˜å¿…é¡»ä½¿ç”¨ move å…³é”®å­—
//          å®ƒè¡¨æ˜é—­åŒ…å†…æ‰€æœ‰çš„æ•è·éƒ½æ˜¯é€šè¿‡å€¼è¿›è¡Œçš„(æ˜¯ä¸€ä»½æ‹·è´, æ˜¯å®‰å…¨ç‹¬ç«‹çš„)ã€‚
//          å› ä¸ºè‹¥æœæ²¡æœ‰ move, é—­åŒ…æ˜¯æŒ‰å¼•ç”¨æ•è·å˜é‡ï¼Œå‡½æ•°ç»“æŸ, é—­åŒ…å°†å¼•ç”¨è¿”å›, ä½†æ˜¯å¼•ç”¨æŒ‡å‘çš„æ•°æ®å°†è¢«é‡Šæ”¾, åœ¨é—­åŒ…ä¸­ç•™ä¸‹æ— æ•ˆçš„å¼•ç”¨
//
fn create_fn() -> impl Fn() {
    let text = "Fn".to_owned();
    move || println!("This is a: {}", text)
}
fn create_fnmut() -> impl FnMut() {
    let text = "FnMut".to_owned();

    move || println!("This is a: {}", text)
}
let fn_plain = create_fn();
let mut fn_mut = create_fnmut();
fn_plain();
fn_mut();


```


#### é—­åŒ…å‚æ•°ä¸­çš„ç”Ÿå‘½å‘¨æœŸ

```rs
trait DoSomething<T> {
    fn do_sth(&self, value: T);
}
// ä¸º&usizeç±»å‹å®ç°äº†è¯¥ trait
impl<'a, T: Debug> DoSomething<T> for &'a usize {
    fn do_sth(&self, value: T) {
        println!("{:?}", value);
    }
}
// æ³›å‹ trait ä½œä¸º trait objectæ—¶éœ€è¦æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸå‚æ•°
// error
// è¿™é‡Œç”Ÿå‘½å‘¨æœŸå‚æ•°è®©ç¼–è¯‘å™¨è¯¯è§£: æŠŠ foo çš„ç”Ÿå‘½å‘¨æœŸå’Œå†…éƒ¨ s çš„ç”Ÿå‘½å‘¨æœŸå…³è”èµ·æ¥, å³åœ¨ foo()è°ƒç”¨çš„ ç”Ÿå‘½å‘¨æœŸå†…, s å¿…é¡»å§‹ç»ˆæœ‰æ•ˆ
//ç„¶è€Œ b å†…éƒ¨çš„ &usizeå¼•ç”¨ æœ¬æ¥åº”è¯¥å’Œ foo å‡½æ•°æ²¡æœ‰ä»»ä½•å…³ç³»
fn foo<'a>(b: Box<DoSomething<&'a usize>>) {
    let s: usize = 10;
    // s åœ¨ foo å‡½æ•°è°ƒç”¨ç»“æŸåå°±ä¼šè¢«ææ„ï¼Œä»è€Œ&så°±ä¼šå˜ æˆæ‚¬å‚æŒ‡é’ˆ
    b.do_sth(&s) // error[E0597]: `s` does not live long enough
}
// æ­£ç¡®
// é«˜é˜¶ç”Ÿå‘½å‘¨æœŸ (Higher-Ranked Lifetime)è¯­æ³•: for<'f> , è¡¨ç¤ºæ­¤ç”Ÿå‘½å‘¨æœŸå‚æ•°åªé’ˆå¯¹å…¶åé¢æ‰€è·Ÿ ç€ çš„â€œå¯¹è±¡"
// è¿™é‡Œåœ¨ box å†…éƒ¨å£°æ˜ä¸€ä¸ªå‘¨æœŸæ³¨é‡Š, æ ‡æ³¨ &usize, å’Œ å¤–å±‚çš„bar å‡½æ•°æ— å…³
fn bar(b: Box<for<'f> DoSomething<&'f usize>>) {
    let s: usize = 10;
    b.do_sth(&s);
}
fn main(){
    let x  = Box::new(&2usize);
    foo(x); // ç›¸å½“äº let _a = foo(x);
    bar(x);
}

// æ¨¡æ‹Ÿé—­åŒ…çš„è¡Œä¸º
struct Pick<F> {
    data: (u32, u32),// å­˜å‚¨é—­åŒ…å‚æ•° 
    func: F, // å­˜å‚¨é€»è¾‘è¡Œä¸º
}
impl<F> Pick<F>
    // traité™å®šä¸­ä½¿ç”¨äº† å¼•ç”¨ç±»å‹, ç¼–è¯‘å™¨è‡ªåŠ¨ä¸ºå…¶è¡¥é½äº†ç”Ÿå‘½å‘¨æœŸå‚æ•°
    where F: Fn(&(u32, u32)) -> &u32
    // æ˜¾å¼æŒ‡å®šå‘¨æœŸå‚æ•°:
    where F: for<'f> Fn(&'f (u32, u32)) -> &'f u32, // 
{
    // ç”Ÿå‘½å‘¨æœŸå‚æ•°å¯çœç•¥    
    fn call(&self) -> &u32 {
        (self.func)(&self.data)
    }

    // è‹¥è¦æ·»åŠ å‘¨æœŸå‚æ•°, è¿™ç§æ˜¯é”™è¯¯çš„:  
    fn call<'a>(&â€™a self)ä¸€ã€‰&â€™a u32, //ä¸èƒ½è®© callæ–¹æ³•è‡ªèº«çš„ç”Ÿå‘½å‘¨æœŸå’Œ self.funcæ–¹æ³•çš„ç”Ÿå‘½å‘¨æœŸç›¸å…³è”, å› ä¸ºé—­åŒ… çš„æ•è·å¼•ç”¨æ˜¯ä»å¤–éƒ¨ç¯å¢ƒè·å–çš„ï¼Œå’Œ call æ–¹æ³•æ²¡æœ‰å…³ç³»

    
}
fn max(data: &(u32, u32)) -> &u32 {
    if data.0 > data.1{
        &data.0
    }else{
        &data.1
    }

}
fn main() {
   let elm = Pick { data: (3, 1), func: max };
   println!("{}", elm.call());
}

```

### è¿­ä»£å™¨


#### ä»€ä¹ˆæ˜¯è¿­ä»£å™¨

é—­åŒ…æœ€å¸¸è§çš„åº”ç”¨åœºæ™¯æ˜¯ï¼Œ åœ¨éå†é›†åˆå®¹å™¨ä¸­çš„å…ƒç´ çš„åŒæ—¶ï¼ŒæŒ‰é—­åŒ…å†… æŒ‡å®šçš„é€»è¾‘è¿›è¡Œæ“ä½œ, å³è¿­ä»£å™¨


```rs

/// è¿­ä»£å™¨
/// 
/// è¿­ä»£å™¨æ˜¯æƒ°æ€§çš„, è°ƒç”¨æ–¹æ³•ä½¿ç”¨è¿­ä»£å™¨å‰, ä¸ä¼šæœ‰ä»»ä½•æ•ˆæœ
/// 
/// æ¯ä¸ªè¿­ä»£å™¨éƒ½å®ç° Iterator trait
/// 
/// trait Iterator {
///     // è¿™é‡Œä¸ºä»€ä¹ˆä¸ä½¿ç”¨ æ³›å‹å‘¢? è‹¥ç”¨æ³›å‹è¯­æ³•, ä¼šé€ æˆè¿™æ ·çš„ç»“æœ: ä½¿ç”¨è€…å¯ä»¥é€šè¿‡æ³›å‹, ä¸ºä¸€ä¸ª struct å®ç°å¤šç§ Iterator trait
///     // è°ƒç”¨æ—¶, ç¼–è¯‘å™¨æ— æ³•çŸ¥é“ä½¿ç”¨å“ªä¸ª trait å®ç°
///     type Item;// å…³è”å…ƒç´ ç±»å‹
///     // éœ€è¦å®ç°çš„æ–¹æ³• (è¦åŒ…å«ä¸¤ä¸ªè¦ç‚¹: 1. åˆ°è¾¾æŸä¸ªæ¡ä»¶è¿”å› none; 2. è¿”å› cur; 3. è®¡ç®—ä¸‹ä¸€æ­¥çš„å€¼, èµ‹ç»™ cur)
///     fn next(&mut self) -> Option<Self::Item>
/// }
/// 
/// for ç»“æ„ä¼šä½¿ç”¨ .into_iterator() æ–¹æ³•å°†ä¸€äº›é›†åˆç±»å‹ è½¬æ¢ä¸ºè¿­ä»£å™¨
// 
// 
// å¤–éƒ¨è¿­ä»£å™¨ (External Iterator): åœ¨å®¹å™¨å¤–éƒ¨, å¯ä»¥æ§åˆ¶æ•´ä¸ªè¿­ä»£è¿‡ç¨‹ (å¦‚æ‰‹åŠ¨è°ƒç”¨ next() è·å–ä¸‹ä¸€ä¸ªå…ƒç´ )
// å†…éƒ¨è¿­ä»£å™¨ (internal Iterator):é€šè¿‡è¿­ä»£å™¨è‡ªèº«æ¥æ§åˆ¶è¿­ä»£ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œå¤–éƒ¨æ— æ³•å¹²é¢„, ä¸€æ—¦å¼€å§‹, å¿…é¡»å…¨éƒ¨è¿­ä»£å®Œæ¯•æ‰èƒ½ç»“æŸ
// 
// å¤–éƒ¨è¿­ä»£å™¨
fn main() {
    let v = vec![1, 2, 3, 4, 5];
    // forå¾ªç¯æ˜¯ä¸€ä¸ªå…¸å‹çš„å¤–éƒ¨è¿­ä»£å™¨
    // å…¶å®æ˜¯ä¸€ä¸ªè¯­æ³•ç³–, åº•å±‚å®ç°æ˜¯ into_iteræ–¹æ³•å£°æ˜äº†ä¸€ä¸ªå¯å˜è¿­ä»£å™¨ iterator
    for i in v {
        println!("{}", i);
    }
}
// ç­‰ä»·äº
fn main() {
    let v = vec![1, 2, 3, 4, 5];
    {  // ç­‰ä»·äºforå¾ªç¯çš„scope
        let mut _iterator = v.into_iter();
        loop {
            match _iterator.next() {
                Some(i) => {
                    println!("{}", i);
                }
               None => break,
           }
       }
   }
}


struct Stepper {
    cur: i32,
    step: i32,
    max: i32,
}

impl Iterator for Stepper {
    type Item = i32;

    fn next(&mut self) -> Option<Self::Item> {
        if self.cur > self.max {
            return None;
        }
        let resp = self.cur;
        self.cur += self.step;
        Some(resp)
    }
}

let stepper = Stepper {cur: 0, step: 1, max: 9};
stepper.into_iter().for_each(|it| println!("{}", it)); 


// è‡ªå®šä¹‰å†…éƒ¨è¿­ä»£å™¨
trait InIterator<T: Copy> {
    fn each<F: Fn(T) -> T>(&mut self, f: F);
}
impl<T: Copy> InIterator<T> for Vec<T> {
    fn each<F: Fn(T) -> T>(&mut self, f: F) {
        let mut i = 0;
        while i < self.len() {
            self[i] = f(self[i]);
            i += 1;
        }
    }
}
fn main(){
    let mut v = vec![1,2,3];
    v.each(|i| i * 3);
    assert_eq!([3, 6, 9], &v[..3]);
}

```



#### Iterator trait


```rust

/// 
fn iter_demo() {

// 
// è·å–è¿­ä»£å™¨æ—¶, æ ¹æ®å¯¹æºå®¹å™¨çš„å¤„ç†, å¯ä»¥åˆ†ä¸ºå‡ ç±»è¿­ä»£å™¨:
// 
// - Intolterï¼Œè½¬ç§»æ‰€æœ‰æƒï¼Œå¯¹åº” selfã€‚
// - Iterï¼Œ è·å¾—ä¸å¯å˜å€Ÿç”¨ ï¼Œ å¯¹åº”&selfã€‚
// - IterMutï¼Œè·å¾—å¯å˜å€Ÿç”¨ï¼Œå¯¹åº”& mut selfã€‚
// 
// Iterå’Œ IterMutè¿­ä»£å™¨çš„å…¸å‹åº”ç”¨å°±æ˜¯ slice 
// ç‰¹æ®Šçš„: Drain è¿­ä»£å™¨, Stringç±»å‹å’Œ HashMap ç‰¹æœ‰, å¯ä»¥è¿­ä»£åˆ é™¤æŒ‡å®šèŒƒå›´å†…çš„å€¼


// ç›¸åº”çš„å°±æœ‰å¤šä¸ªè·å–è¿­ä»£å™¨çš„æ–¹æ³•:
// 
// iter() è¿­ä»£å‡ºå¼•ç”¨, è¿­ä»£å‡ºçš„ç±»å‹ä¸º &T
// iter_mut() è¿­ä»£å‡ºå¯å˜å¼•ç”¨, ç±»å‹ä¸º  &mut T
// into_iter() è¿­ä»£å‡ºå€¼, ä¸æ˜¯å¼•ç”¨, åŸå§‹æ•°æ®æºçš„å…ƒç´ æ‰€æœ‰æƒå˜æ›´ (æ¨è)
// 
//size_hint() (usize, Option<usize>)ï¼Œæ­¤å…ƒç»„è¡¨ç¤ºè¿­ä»£å™¨å‰©ä½™é•¿åº¦çš„è¾¹ç•Œä¿¡æ¯, å…ƒç´  1: ä¸‹é™, å…ƒç´  2: ä¸Šé™, é»˜è®¤è¿”å› (0, None)
//       ç”¨æ¥å’Œå®¹å™¨åˆä½œæ—¶, ç²¾ç¡®çš„æ‹“å±•å®¹å™¨å®¹é‡, ä»è€Œé¿å…ä¸å¿…è¦çš„å®¹é‡æ£€æŸ¥ï¼Œæé«˜æ€§èƒ½
//          å¯¹äºæ•°ç»„, ä¸Šä¸‹é™æ˜¯ç›¸åŒçš„, ä»£è¡¨è¿­ä»£å™¨å½“å‰æŒ‡é’ˆåˆ°æœ«å°¾æŒ‡é’ˆçš„è·ç¦»
// 


    let mut v = vec![1,2,3];
    for ele in v.iter() { //ç­‰åŒäº
        println!("{}", ele);
    }

    // è¿­ä»£å‡ºçš„ç±»å‹ä¸º &i32
    let mut it = v.iter();
    for _ in 0..3 {//`for` éå† `Iterator` ç›´åˆ°è¿”å› `None`ï¼Œæ¯ä¸ª `Some` å€¼éƒ½è¢«è§£åŒ…ï¼ˆunwrapï¼‰ï¼Œç„¶åç»‘å®šç»™ä¸€ä¸ªå˜é‡, è¿™é‡Œæ˜¯ "_"
        println!("{}", it.next().unwrap());// éœ€è¦ it å¯å˜, è§£å¼•ç”¨å¯çœç•¥
    }

    // è¿­ä»£å‡ºå¯å˜å¼•ç”¨
    //
    let mut it_mut = v.iter_mut();// éœ€è¦ v ä¸º å¯å˜
    let ele_first = it_mut.next().unwrap();
    *ele_first = 100; // éœ€è¦å†™æ“ä½œ, å…ˆè§£å¼•ç”¨
    println!("v = {:?}", v); // [100,2,3]

    // è¿­ä»£å™¨çš„ä¸Šä¸‹é™, è¡¨ç¤º
    // 
    let a : [i32; 3]= [1, 2, 3];
    let mut iter = a.iter();
    assert_eq!((3, Some(3)), iter.size_hint());
    iter.next();//çš„å‰©ä½™é•¿åº¦å°±ä¼šå‡å°‘ï¼Œ ç›´åˆ°å‡ä¸º 0ä¸ºæ­¢
    assert_eq!((2, Some(2)), iter.size_hint());
    // ä½¿ç”¨è¿­ä»£å™¨è¿½åŠ å­—ç¬¦ä¸²
    let mut message = "Hello".to_string(); 
    message . extend (&[' ', 'R', 'u', 's', 't']) ; // è¿™ä¸ªæ–¹æ³•é‡Œé¢å°±ç”¨åˆ°äº† size_hint ç”¨äº String æ‰©å®¹
    assert_eq ! (â€ Hello Rustâ€ ,& message );


    // Intolterator trait
    
    let arr = [1, 2, 3];
    // å¹¶æ²¡æœ‰ä¸º[T]ç±»å‹å®ç° IntoIteratorï¼Œéœ€è¦è°ƒç”¨ iter() ç”Ÿæˆè¿­ä»£å™¨
    for i in arr.iter() {
        println!("{}", *i);
    }
    // ä¸º&â€™a [T]å’Œ&â€™a mut [T]ç±»å‹å®ç° äº† Intoiterator
    for i in &arr {
        println!("{}", *i);
    }


    // 
    // æ±‚å’Œ
    let total: i32 = v.iter().sum();
    println!("total = {}", total);

    // `take(n)` æ–¹æ³•æå– `Iterator` çš„å‰ `n` é¡¹ã€‚
    //

    // `skip(n)` æ–¹æ³•ç§»é™¤å‰ `n` é¡¹ï¼Œä»è€Œç¼©çŸ­äº† `Iterator` 
    //

    
```

#### è¿­ä»£å™¨é€‚é…å™¨ æ”¶é›†å™¨ å‡½æ•°å¼é£æ ¼

```rs

    // 
    // è¿­ä»£å™¨çš„é€‚é…å™¨, é€‚é…å™¨éƒ½ä¼šè¿”å›æ–°çš„é›†åˆ
    // 
    // â€¢ Mapï¼Œé€šè¿‡å¯¹åŸå§‹æ³¨ä»£å™¨ä¸­çš„æ¯ä¸ªå…ƒç´ è°ƒç”¨æŒ‡å®š é—­åŒ…æ¥äº§ç”Ÿä¸€ä¸ªæ–°çš„è¿­ä»£å™¨ã€‚
    // â€¢ Chainï¼Œé€šè¿‡è¿æ¥ä¸¤ä¸ªè¿­ä»£å™¨æ¥åˆ›å»ºä¸€ä¸ªæ–°çš„è¿­ä»£å™¨ã€‚
    // â€¢ Clonedï¼Œé€šè¿‡æ‹·è´åŸå§‹è¿­ä»£å™¨ä¸­å…¨éƒ¨å…ƒç´ æ¥åˆ›å»ºæ–°çš„è¿­ä»£å™¨ã€‚
    // â€¢ Cycleï¼Œåˆ›å»ºä¸€ä¸ªæ°¸è¿œå¾ªç¯è¿­ä»£çš„è¿­ä»£å™¨ï¼Œå½“å®Œæ¯•å ï¼Œå†è¿”å›ç¬¬ä¸€ä¸ªå…ƒç´ å¼€å§‹æ³•ä»£ã€‚
    // â€¢ Enumerateï¼Œåˆ›å»ºä¸€ä¸ªåŒ…å«è®¡æ•°çš„è¿­ä»£å™¨ï¼Œå®ƒä¼šè¿”å› ä¸€ä¸ªå…ƒç»„(i,val)ï¼Œ å…¶ä¸­ i æ˜¯ usize ç±»å‹ ï¼Œä¸ºè¿­ä»£çš„ å½“å‰ç´¢ å¼•ï¼Œ val æ˜¯è¿­ä»£å™¨è¿”å› çš„å€¼ ã€‚
    // â€¢ Filterï¼Œåˆ›å»ºä¸€ä¸ªåŸºäºè°“è¯åˆ¤æ–­å¼( predicateï¼Œäº§ç”Ÿå¸ƒå°”å€¼çš„è¡¨è¾¾å¼)è¿‡æ»¤å…ƒç´ çš„è¿­ä»£å™¨ ã€‚
    // â€¢ FlatMapï¼Œåˆ›å»ºä¸€ä¸ªç±»ä¼¼ Map çš„ç»“æ„çš„æ³•ä»£å™¨ï¼Œä½†æ˜¯å…¶ä¸­ä¸ä¼šå«æœ‰ä»»ä½•åµŒå¥—ã€‚
    // â€¢ FilterMapï¼Œç›¸å½“äº Filterå’Œ Mapä¸¤ä¸ªæ³•ä»£å™¨ä¾æ¬¡ä½¿ç”¨åçš„æ•ˆæœã€‚
    // â€¢ Fuseï¼Œåˆ›å»ºä¸€ä¸ªå¯ ä»¥å¿«é€Ÿç»“æŸéå† çš„è¿­ä»£å™¨ã€‚åœ¨éå†è¿­ä»£å™¨æ—¶ï¼Œåª è¦è¿”å›è¿‡ä¸€æ¬¡ None,é‚£ä¹ˆä¹‹åæ‰€æœ‰çš„éå†ç»“æœéƒ½ä¸º Noneã€‚è¯¥è¿­ä»£å™¨é€‚é…å™¨å¯ä»¥ç”¨äºä¼˜åŒ–ã€‚
    // â€¢ Revï¼Œåˆ› å»ºä¸€ ä¸ªå¯ä»¥åå‘éå†çš„è¿­ä»£å™¨ 
    //
    // 
    
    // map, 
    // Mapæ˜¯ä¸€ä¸ªæ³›å‹ç»“æ„ä½“ï¼Œå®ƒåªæœ‰ä¸¤ä¸ªæˆå‘˜å­—æ®µï¼Œä¸€ä¸ªæ˜¯iterï¼Œ ä¸€ä¸ªfï¼Œ åˆ†åˆ«å­˜ å‚¨çš„æ˜¯è¿­ä»£å™¨å’Œä¼ å…¥çš„é—­åŒ…
    // å®ç°äº† Iterator trait
    let a = [1, 2, 3];
    let mut iter =a.into_iter() .map(|x| 2 * x);

    let arr1 = [1, 2, 3, 4, 5];
    let c1 = arr1.iter().map(|x| 2 * x).collect::<Vec<i32>>();
    assert_eq!(&c1[..], [2, 4, 6, 8, 10]);
    let arr2 = ["1", "2", "3", "h"];
    let c2 = arr2.iter().filter_map(|x| x.parse().ok()).collect::<Vec<i32>>();
    assert_eq!(&c2[..], [1,2,3]);
    let arr3 = ['a', 'b', 'c'];
   for (idx, val) in arr3.iter().enumerate() {
       println!("idx: {:?}, val: {}", idx, val.to_uppercase());
   }
    
    let v = vec![1,2,3];
    let scaled : Vec<i32> = v.iter().map(|&x| x * 10).collect(); // è¿”å›æ–°çš„ vec, åŸå§‹ vec ä¸å—å½±å“, x ä¸åŠ &äº¦å¯
    println!("scaled = {:?}", scaled);
    let scaled1: Vec<_> = v.iter_mut().map(|&mut x| x* 10).collect(); //ç­‰æ•ˆ, è¿”å›æ–°çš„ vec, ä¸æ”¹å˜åŸå§‹ v
    println!("scaled1 = {:?}", scaled1);
    println!("v = {:?}",v);//ä¸å˜
    let plused: Vec<_> = scaled.into_iter().map(|x| x +1).collect();// è·å–scaled æ‰€æœ‰æƒ,  ç›´æ¥åœ¨åŸå§‹å€¼ä¸Šä¿®æ”¹
    println!("plused = {:?}", plused);

    // filter
    let filtered: Vec<_> = v.into_iter().filter(|&x| x > 3).collect();// ç›´æ¥åœ¨åŸå§‹ vec ä¸Šä¿®æ”¹, v æ‰€æœ‰æƒå¤±æ•ˆ // å­˜ç–‘, ä¸ºä»€ä¹ˆéœ€è¦ &x
    println!("filtered = {:?}", filtered); // [100]
    println!("v = {:?}", v); // é”™è¯¯, into_iter() ä½¿å¾— v å¤±å»å€¼å¾—æ‰€æœ‰æƒ
    

    // é€†åº
    let mut iter= a.iter().rev()
    iter.next();//ä»åå‘å¼€å§‹è¿­ä»£
    // or
    // é€šè¿‡ æ™®é€šè¿­ä»£å™¨çš„ next_back() æ–¹æ³•åå‘è¿­ä»£
    // next() å’Œ next_back() æœ‰å„è‡ªç‹¬ç«‹çš„æŒ‡é’ˆ, äº’ä¸å½±å“, ä½†æ˜¯å½“æŒ‡é’ˆç›¸é‡æ—¶, å°±è¿­ä»£ä¸å‡ºå€¼äº†, è¿”å› none




// æ”¶é›†å™¨
// 
    // any è°“è¯, åˆ¤æ–­
    // é—­åŒ…å‚æ•°ä¸º å¼•ç”¨
    let v = vec![1,2,3];
    let contain = v.iter().any(|&x| x == 2);
    println!("contains 2?  : {}", contain);
    let contain = v.into_iter().any(|x| x == 3);
    println!("contains 3?  : {}", contain);
    let a = [1, 2, 3];
    assert_eq!(a.iter().any(|&x| x != 2), true);// å­˜åœ¨ä¸ä¸º 2 çš„å…ƒç´ 
    let arr = [1, 2, 3];
    let result1 = arr.iter().any(|&x| x != 2);
    let result2 = arr.iter().any(|x| *x != 2);
    // error:
    // the trait bound `&{integer}: std::cmp::PartialEq<{integer}>` is not satisfied
    let result2 = arr.iter().any(|x| x != 2);
    assert_eq!(result1, true);
    assert_eq!(result2, true);

    // fold
    // é—­åŒ…å‚æ•°ä¸ºå¼•ç”¨
    let arr = vec![1, 2, 3];
    let sum1 = arr.iter().fold(0, |acc, x| acc + x);
    let sum2 = arr.iter().fold(0, |acc, x| acc + *x);
    let sum3 = arr.iter().fold(0, |acc, &x| acc + x);
    let sum4 = arr.into_iter().fold(0, |acc, x| acc + x);
    assert_eq!(sum1, 6);
    assert_eq!(sum2, 6);
    assert_eq!(sum3, 6);
   assert_eq!(sum4, 6);

    // find æŸ¥æ‰¾
    let v = vec![1,2,3];
    let find2 = v.iter().find(|&&x| x == 2).unwrap();
    println!("find2 = {}", find2);//2
    let find3 = v.into_iter().find(|&x| x == 3).unwrap();
    println!("find2 = {}, find3 = {}", find2, find3);// å‡ºé”™
    println!("find3 = {}", find3);






    // å‡½æ•°å¼é£æ ¼
    //
    let upper = 3;
    let sum: u32 =(0..).map(|n| n * n)             // æ‰€æœ‰è‡ªç„¶æ•°å–å¹³æ–¹
             .take_while(|&n| n < upper) // å–å°äºä¸Šé™çš„
             .filter(|&n| is_odd(n))     // å–å¥‡æ•°
             .fold(0, |sum, i| sum + i); // æœ€ååŠ èµ·æ¥
    println!("sum = {}", sum);

    // å¤„ç†è¿­ä»£ä¸­çš„é”™è¯¯
    //
    //
    let strings = vec!["tofu", "93", "18"];
    let possible_numbers: Vec<_> = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .filter_map(Result::ok) // è¿‡æ»¤å‡ºæˆåŠŸçš„result
        .collect();
    println!("Results: {:?}", possible_numbers);
    // 
    // å¦å¤–çš„å¤„ç†æ–¹å¼:
    //Result å®ç°äº† FromIter, Vec<Result<T, E>>å¯ä»¥è½¬ä¸º Result<Vec<T>, E>, ä¸€æ—¦æ‰¾åˆ°ä¸€ä¸ª Result::Err ï¼Œéå†å°±è¢«ç»ˆæ­¢
    let strings = vec!["tofu", "93", "18"];
    let numbers: Result<Vec<_>, _> = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .collect();
    println!("Results: {:?}", numbers);
    //
    //åˆ†ç»„æ”¶é›†
    //
    let strings = vec!["tofu", "93", "18"];
    let (numbers, errors): (Vec<_>, Vec<_>) = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .partition(Result::is_ok);
    let numbers: Vec<_> = numbers.into_iter().map(Result::unwrap).collect();
    let errors: Vec<_> = errors.into_iter().map(Result::unwrap_err).collect();
    println!("Numbers: {:?}", numbers);
    println!("Errors: {:?}", errors);
}
```


#### è‡ªå®šä¹‰è¿­ä»£å™¨



```rs

    //
    // è‡ªå®šä¹‰ iterator
    //
    struct Counter {
        count: u32,
        max: u32,
    }
    impl Counter {
        fn new(max: u32) -> Self {// new æ–¹æ³•ä¸èƒ½æ”¾åˆ°ä¸‹é¢çš„ iterator å®ç°ä¸­
            Counter {
                count: 0,
                max
            }
        }
    }
    impl Iterator for Counter {
        type Item = u32;
        fn next(&mut self) -> Option<Self::Item> {
            self.count += 1;
            if self.count <= self.max {
                Some(self.count)
            } else {
                None
            }
        }
    }
    let mut counter = Counter::new(5);
    loop {
        if let Some(count) = counter.next() {
            println!("count = {}", count);
        } else {
            break;
        }
    }



```


#### è‡ªå®šä¹‰é€‚é…å™¨ æ”¶é›†å™¨

```rs

// ç¬¬ä¸‰æ–¹åŒ…Itertools äº¦å¯å®ç°è‡ªå®šä¹‰é€‚é…å™¨


use std::iter::FromIterator;
#[derive(Debug)]
struct MyVec(Vec<i32>);
impl MyVec {
    fn new() -> MyVec {
        MyVec(Vec::new())
    }
    fn add(&mut self, elem: i32) {
        self.0.push(elem);
   }
}
// å®ç°FromIteratorå°±å¯ä»¥æ‹¥æœ‰Collectçš„èƒ½åŠ›
impl FromIterator<i32> for MyVec {
   fn from_iter<I: IntoIterator<Item = i32>>(iter: I) -> Self {
       let mut c = MyVec::new();
       for i in iter {
           c.add(i);
       }
       c
   }
}
fn main() {
   let iter = (0..5).into_iter();
//    ç›´æ¥è°ƒç”¨ MyVec::from_iteræ–¹æ³•å’Œä½¿ç”¨ collectæ–¹æ³•çš„æ•ˆæœæ˜¯ä¸€æ ·çš„ã€‚
   let c = MyVec::from_iter(iter);
   assert_eq!(c.0, vec![0, 1, 2, 3, 4]);
   let iter = (0..5).into_iter();
   let c: MyVec = iter.collect();
   assert_eq!(c.0, vec![0, 1, 2, 3, 4]);
   let iter = (0..5).into_iter();
   let c = iter.collect::<MyVec>();
   assert_eq!(c.0, vec![0, 1, 2, 3, 4]);
}


// è‡ªå®šä¹‰é€‚é…å™¨
// æŒ‰æŒ‡å®šæ­¥æ•°è¿­ä»£
#[derive(Clone, Debug)]
#[must_use = "iterator adaptors are lazy and do nothing unless consumed"]
pub struct Step<I> {
    iter: I,
    skip: usize,
}
impl<I> Iterator for Step<I>
    where I: Iterator,
{
    type Item = I::Item;
    fn next(&mut self) -> Option<I::Item> {
        let elt = self.iter.next();
        if self.skip > 0 {
            self.iter.nth(self.skip - 1);
        }
       elt
    }
}
// äº§ç”Ÿ Stepé€‚é…å™¨
pub fn step<I>(iter: I, step: usize) -> Step<I>
    where I: Iterator,
{
    assert!(step != 0);
    Step {
        iter: iter,
            skip: step - 1,
    }
}
// å®šä¹‰äº†ä¸€ä¸ªç»§æ‰¿è‡ª Iterator çš„å­ trait
pub trait IterExt: Iterator {
    fn step(self, n: usize) -> Step<Self>
        where Self: Sized,
    {
        step(self, n)
    }
}
impl<T: ?Sized> IterExt for T where T: Iterator {}
fn main() {
    let arr = [1,2,3,4,5,6];
    let sum = arr.iter().step(2).fold(0, |acc, x| acc + x);
    assert_eq!(9, sum); // [1, 3, 5]
}




```


## æ¡ä»¶å¾ªç¯

```rust


fn condition_loop() {
    let a = 1;
    let b;
    if a > 0 {
        b = 1
    } else if a < 0 {
        b = -1;
    } else {
        b = 0;
    }
    println!("b = {}", b);

    // if ç”¨åœ¨ let å¥å­ä¸­, è¿”å›å€¼ç±»å‹ç›¸åŒ
    let c = if a > 0 { true } else { false };
    println!("c = {}", c);

    // while å¾ªç¯
    // æ­»å¾ªç¯ä¸è¦ä½¿ç”¨ while true, å› ä¸ºè‹¥åœ¨ å¾ªç¯ä½“ä¸­ return xx; ç¼–è¯‘å™¨ä¼šè®¤ä¸ºæ— æ•ˆ, ç¼–è¯‘å™¨åªä¼šè®¤ä¸º while true ä¼šè¿”å›ç©ºå³ "()"
    let mut d = 3;
    while d > 0 {
        println!("d = {}", d);
        d -= 1;
    }

    // for å¾ªç¯
    let a = [3, 4, 5];
    let mut i = 0;
    for ele in a.iter() {
        println!("a[{}] = {}", i, ele);
        i += 1;
    }

    for i in 0..3 {// ä¸åŒ…æ‹¬å°¾å·´, 0..3 æ˜¯ä¸€ä¸ª Range ç±»å‹, æ˜¯ä¸€ä¸ª iterator
        println!("a[{}] = {}", i, a[i]);
    }

    //loop å¾ªç¯ æ­»å¾ªç¯
    let s = ['R', 'U', 'N', 'O', 'O', 'B'];
    let mut i = 0;
    loop {
        let ch = s[i];
        if ch == 'O' {
            break;
        }
        i += 1;
    }
    println!("O index = {}", i);

    // å¸¦è¿”å›å€¼çš„ loop å¾ªç¯, ç”¨break
    let mut i = 0;
    let location = loop {
        if s[i] == 'O' {
            break i;
        }
        i += 1;
    };
    println!("O index = {}", location);
}


```


## æ³›å‹


### å•æ€åŒ–


å•æ€åŒ–æ˜¯ç¼–è¯‘å™¨ è¿›è¡Œé™æ€åˆ†å‘ çš„ä¸€ç§ç­–ç•¥, ç¼–è¯‘å™¨è¦å°†ä¸€ä¸ªæ³›å‹å‡½æ•°ç”Ÿ æˆå¤šä¸ªå…·ä½“ç±»å‹å¯¹åº”çš„å‡½æ•°

å¥½å¤„æ˜¯æ€§èƒ½å¥½ ï¼Œ æ²¡æœ‰è¿è¡Œ æ—¶å¼€é”€;ç¼ºç‚¹æ˜¯å®¹æ˜“é€ æˆç¼–è¯‘åç”Ÿæˆçš„äºŒè¿›åˆ¶æ–‡ä»¶è†¨èƒ€ (å¦‚ æœå˜å¾—å¤ª å¤§ï¼Œå¯ä»¥æ ¹ æ®å…·ä½“çš„æƒ…å†µé‡æ„ä»£ç æ¥è§£å†³é—®é¢˜)


### å¤šé‡çº¦æŸ åŠ å·

trait Bound

åŒ…å« trait é™å®šçš„æ³›å‹å±äºé™æ€åˆ†å‘ï¼Œåœ¨ç¼–è¯‘æœŸé€šè¿‡å•æ€åŒ–åˆ†åˆ«ç”Ÿæˆå…·ä½“ç±»å‹çš„å®ä¾‹ï¼Œæ‰€ä»¥è°ƒç”¨ trait é™å®šä¸­çš„æ–¹æ³•ä¹Ÿéƒ½æ˜¯è¿è¡Œæ—¶é›¶æˆæœ¬çš„ï¼Œå› ä¸ºä¸éœ€è¦åœ¨è¿è¡Œæ—¶å†è¿›è¡Œæ–¹æ³•æŸ¥æ‰¾ ã€‚

```rust

/// æ³›å‹
/// 
/// 
fn generic() {

    fn largest<T: PartialOrd + Copy>(list: &[T]) -> T { // å¤šé‡çº¦æŸä½¿ç”¨ + å· (ä¸”çš„å…³ç³»)
        let mut largest = list[0];
        for &ele in list.iter() {
            if largest < ele {
                largest = ele;
            }
        }
        largest
    }

    use std::ops::Add;
    fn sum<T: Add<T, Output=T>>(a: T, b: T) -> T{
        a + b
    }




    // ç»“æ„ä½“ä¸­çš„æ³›å‹
    //
    #[derive(Debug)]
    struct Point<T> {
        x: T,
        y: T,
    }
    impl<T> Point<T> {
        fn x(&self) -> &T {
            &self.x
        }
    }

    //æœ‰æ¡ä»¶çš„å®ç°æ–¹æ³•
    //
    //
    struct A<T> {}
    // è¿™æ®µä»£ç å£°æ˜äº† A<T> ç±»å‹å¿…é¡»åœ¨ T å·²ç»å®ç° B å’Œ C ç‰¹æ€§çš„å‰æä¸‹æ‰èƒ½æœ‰æ•ˆå®ç°æ­¤ impl å—
    impl<T: B + C> A<T> {
        fn d(&self) {}
    }

    // ä½¿ç”¨ where é‡æ„ trait çº¦æŸ
    fn foo<T, K, R>(a: T, b: K, c: R) where T: A, K: B+C, R: D {. .}



```

### é»˜è®¤æ³›å‹å‚æ•° and å…³è”ç±»å‹


```rust


    // é»˜è®¤æ³›å‹å‚æ•°, å¦‚ stdä¸­çš„ Add trait:
    // (ä¸ºä»€ä¹ˆè¦ä½¿ç”¨å…³è”ç±»å‹çš„æ–¹å¼è€Œä¸åœ¨æ³›å‹ä¸­æŒ‡å®šä¸¤ä¸ªå‚æ•°å‘¢?
    //      ä½¿ç”¨å•æ³›å‹å‚æ•°æ›´çµæ´», å¯ä¼ å¯ä¸ä¼ , ä½¿å¾—ä»£ç æ›´ç²¾ç®€)
    //
    // sometype è¡¨ç¤ºç¬¦å·å³è¾¹çš„ç±»å‹
    trait Add<SomeType=Self> {// Self è¡¨ç¤ºä¸ºæ³›å‹å‚æ•°æŒ‡å®šé»˜è®¤å€¼ Self (Selfæ˜¯æ¯ä¸ªtraitéƒ½å¸¦æœ‰çš„éšå¼ç±»å‹å‚æ•°, ä»£è¡¨å®ç°å½“å‰ trait çš„å…·ä½“ç±»å‹); è‹¥å®ç° add æ–¹æ³•æ²¡æœ‰æŒ‡å®šå…·ä½“æ³›å‹, åˆ™é»˜è®¤ä¸º Self
        type Output; // å…³è”ç±»å‹
        fn add(self, xx: SomeType) -> Self::Output ;
    }

    // string ä¹Ÿå®ç°äº† Add trait
    let s  = "hello".to_string();
    let ns = s + "world";

```

### ç©ºçº¦æŸ


```rs



    // ç©ºçº¦æŸ
    struct Cardinal;
    struct BlueJay;
    struct Turkey;
    trait Red {}
    trait Blue {}
    impl Red for Cardinal {}
    impl Blue for BlueJay {}
    // è¿™äº›å‡½æ•°åªå¯¹å®ç°äº†ç›¸åº”çš„ trait çš„ç±»å‹æœ‰æ•ˆã€‚
    fn red<T: Red>(_: &T)   -> &'static str { "red" }
    fn blue<T: Blue>(_: &T) -> &'static str { "blue" }
    let cardinal = Cardinal;
    let blue_jay = BlueJay;
    let _turkey   = Turkey;
    // ç”±äºçº¦æŸï¼Œ`red()` ä¸èƒ½ä½œç”¨äº blue_jay ï¼ˆè“æ¾é¸Ÿï¼‰ï¼Œåè¿‡æ¥ä¹Ÿä¸€æ ·ã€‚
    println!("A cardinal is {}", red(&cardinal));
    println!("A blue jay is {}", blue(&blue_jay));
    println!("A turkey is {}", red(&_turkey));// é”™è¯¯


```


### turbofish æ“ä½œç¬¦ and è¿”å›å€¼è‡ªåŠ¨æ¨å¯¼



```rs

    // turbofishæ“ä½œç¬¦ ç±»å‹æ¨å¯¼
    // 
    // å½“ Rust æ— æ³•ä»ä¸Šä¸‹æ–‡ä¸­è‡ªåŠ¨æ¨å¯¼å‡ºç±»å‹çš„æ—¶å€™, å¯ä»¥æ‰‹åŠ¨æŒ‡å®šç±»å‹
    let x = "1";
    println!(â€{:?}â€, x.parse() .unwrap()) //error, parse() æ˜¯ä¸ªæ³›å‹æ–¹æ³•
    // æ‰‹åŠ¨æŒ‡å®šç±»å‹ rust ä¼šè‡ªåŠ¨ç±»å‹æ¨å¯¼
    let intx:i32= x.parse().unwrap();
    // æˆ–è€…, é€šè¿‡ turbofish æ“ä½œç¬¦
    // è¯­æ³•: ::<T>
    assert_eq!( x.parse::<i32>().unwrap(), 1)




}


```


## trait

### trait åŸºæœ¬ä½¿ç”¨

```rust

///ç‰¹æ€§ï¼ˆtraitï¼‰æ¦‚å¿µæ¥è¿‘äº Java ä¸­çš„æ¥å£ï¼ˆInterfaceï¼‰
/// 
fn trait_demo() {
    trait Descriptive {
        fn describe(&self) -> String;

        // é»˜è®¤ trait, ç±»ä¼¼ java æ¥å£é»˜è®¤å®ç°
        fn fn1(&self) -> String {
            String::from("default impl trait")
        }
    }

    struct Person {
        name: String,
        age: u8
    }
    // user.show ç­‰ä»·äº User: :show(&user)è¿™æ ·çš„ å‡½æ•°è°ƒç”¨
    impl Descriptive for Person {
        fn describe(&self) -> String {
            format!("{} {}", self.name, self.age)
        }
    }
    let p = Person {
        name: String::from("xiaoyu"),
        age: 11
    };
    println!("{}", p.describe());
    println!("{}", p.fn1());


```


### å­¤å„¿è§„åˆ™ 

orphan rule: è¦ä¸º struct b å®ç°æŸä¸ª trait a, åˆ™ a, b è‡³å°‘æœ‰ä¸€ä¸ªå¿…é¡»åœ¨å½“å‰ crate ä¸­å®šä¹‰ (ä¸èƒ½a, b éƒ½æ˜¯åœ¨åˆ«å¤„å®šä¹‰çš„æ¯”å¦‚éƒ½æ˜¯åœ¨ std ä¸­å®šä¹‰çš„)

ç›®çš„: é˜²æ­¢å¯¹åˆ«äºº crate ä¸­çš„ç±»å‹è¡Œä¸ºè¿›è¡Œç ´åæ€§æ”¹å†™

```rs
// å¦‚ è¦ä¸º u32 ç±»å‹å®ç°  add, ä½¿å¾—å¯ä»¥åŠ ä¸Š u64 ç±»å‹æ•°å­—
// ç›´æ¥å®ç° æ ‡å‡†åº“ä¸­çš„ Add ä¸è¡Œ, å› ä¸º u32 å’Œ Add éƒ½åœ¨å…¶ä»– crate ä¸­

// éœ€è¦è‡ªå·±å®šä¹‰ åœ¨å½“å‰ crate : ËšAdd trait
// å½“ç„¶ï¼Œé™¤äº†åœ¨æœ¬åœ°å®šä¹‰ Addtraitè¿™ä¸ªæ–¹æ³•ï¼Œè¿˜å¯ä»¥åœ¨æœ¬åœ°åˆ›å»ºä¸€ä¸ªæ–°çš„ç±»å‹ï¼Œç„¶åä¸ºæ­¤ æ–°ç±»å‹å®ç°Add


// å±€é™æ€§
// å¯¹äºä¸€äº›æœ¬åœ°ç±»å‹ï¼Œ å¦‚æœå°†å…¶æ”¾åˆ°ä¸€äº›å®¹å™¨ä¸­ï¼Œæ¯”å¦‚Rc<T>æˆ–Option<T>ï¼Œ é‚£ä¹ˆè¿™äº›æœ¬åœ°ç±»å‹å°±ä¼šå˜æˆè¿œç¨‹ç±»å‹ (å› ä¸ºè¿™äº›å®¹å™¨ç±»å‹éƒ½æ˜¯åœ¨æ ‡å‡†åº“ä¸­å®šä¹‰çš„ ï¼Œ è€Œéæœ¬åœ°ã€‚)
// rust ä½¿ç”¨ #[fundamental]çš„å±æ€§æ ‡è¯†ï¼Œæ¥ä¸ºç‰¹å®šçš„trait è§„é¿å­¤å„¿é™åˆ¶
//  Box<T>ï¼Œè¿˜æœ‰ Fnã€ FnMutã€ FnOnceã€ Sized ç­‰éƒ½ä¸Šäº†#[fundamental]å±æ€§
```

### ç‰¹åŒ– Specialization

```rs
// é—®é¢˜: é‡å è§„åˆ™ï¼šä¸èƒ½ä¸ºé‡å çš„ç±»å‹å®ç°åŒä¸€ä¸ªtrait 
impl<T> AnyTrait for T
impl<T> AnyTrait for T where T: Copy // Copy å’Œä¸Šé¢çš„ T é‡å äº†
impl<T> AnyTrait for String

// è§£å†³: ç‰¹åŒ– (ç±»ä¼¼ java ä¸­çš„æ–¹æ³•é‡å†™/è¦†ç›–)
#![feature(specialization)]
struct Diver<T> {
    inner: T,
}
trait Swimmer {
    // å¸¦æœ‰é»˜è®¤å®ç°çš„ æ–¹æ³•
    fn swim(&self) {
        println!("swimming")
    }
}
// å…ˆä¸º Diver<T>å®ç°è¯¥ trait
impl<T> Swimmer for Diver<T> {}

// ä¸ºDiver<&â€™staticstr>å®ç°äº† è¯¥ trait (ä¹Ÿå°±æ˜¯ ç‰¹æ®Šç±»å‹, ç‰¹æ®Šå¤„ç†)
impl Swimmer for Diver<&'static str> {
    fn swim(&self) {
        println!("drowning, help!")
    }
}

let x = Diver::<&'static str> { inner: "Bob" };
x.swim();
let y = Diver::<String> { inner: String::from("Alice") };
y.swim();

```


### trait ä½œä¸ºå‚æ•° éœ€è¦ impl å‰ç¼€

```rust


    //
    // ç‰¹æ€§åšå‚æ•°
    //
    fn print(p: impl Descriptive) {
        println!("{}", p.describe())
    }
    //
    // å†™æ³•2: (é£æ ¼ç±»ä¼¼æ³›å‹çš„è¯­æ³•ç³–)
    fn output<T: Descriptive>(object: T) {
       println!("{}", object.describe());
    }
    fn output_two<T: Descriptive>(arg1: T, arg2: T) {
        println!("{}", arg1.describe());
        println!("{}", arg2.describe());
    }


    //
    //
    //ç‰¹æ€§ä½œç±»å‹è¡¨ç¤ºæ—¶å¦‚æœæ¶‰åŠå¤šä¸ªç‰¹æ€§ï¼Œå¯ä»¥ç”¨ + ç¬¦å·
    fn notify(item: impl Summary + Display)
    fn notify<T: Summary + Display>(item: T)
    //
    //å¤æ‚çš„å®ç°å…³ç³»å¯ä»¥ä½¿ç”¨ where å…³é”®å­—ç®€åŒ–
    //å¦‚: 
    fn some_function<T: Display + Clone, U: Clone + Debug>(t: T, u: U)
    //å¯ä»¥ç®€åŒ–æˆï¼š
    fn some_function<T, U>(t: T, u: U) -> i32
        where T: Display + Clone,
            U: Clone + Debug
    //
    // å–æœ€å¤§å€¼
    //
    trait Comparable {
        fn compare(&self, object: &Self) -> i8;
    }
    fn max<T: Comparable>(array: &[T]) -> &T {
        let mut max_index = 0;
        let mut i = 1;
        while i < array.len() {
            if array[i].compare(&array[max_index]) > 0 {
                max_index = i;
            }
            i += 1;
        }
        &array[max_index]
    }
    impl Comparable for f64 {
        fn compare(&self, object: &f64) -> i8 {
            if &self > &object { 1 }
            else if &self == &object { 0 }
            else { -1 }
        }
    }
    let arr = [1.0, 3.0, 5.0, 4.0, 2.0];
    println!("maximum of arr is {}", max(&arr));



```

### trait ä½œä¸º è¿”å›å€¼ è¿”å›åŠ¨æ€ç±»å‹


```rust

     //ç‰¹æ€§åšè¿”å›å€¼
    //
    //
    fn person() -> impl Descriptive {
        Person {
            name: String::from("Cali"),
            age: 24
        }
    }

    // åœ¨åŒä¸€ä¸ªå‡½æ•°ä¸­æ‰€æœ‰å¯èƒ½çš„è¿”å›å€¼ç±»å‹å¿…é¡»å®Œå…¨ä¸€æ ·
    //å¦‚æœå¸Œæœ›è¿”å›ä¸åŒçš„struct, ä½¿ç”¨  Box<dyn Animal> ä½œä¸ºè¿”å›å€¼ ----- å¤šæ€
// 
    // é”™è¯¯, å› ä¸º A, B è™½ç„¶éƒ½å®ç°äº† Descriptive, ä½†æ˜¯ A B æ˜¯ä¸åŒçš„ç±»å‹
    fn some_function(bool bl) -> impl Descriptive {
        if bl {
            return A {};
        } else {
            return B {};
        }
    }
    //
    // é‚£ä¹ˆå¦‚ä½•è¿”å›ä¸åŒçš„ struct?
    //ä½¿ç”¨ Box<dyn xxx>, box æ˜¯ä¸€ç§æ•°æ®ç»“æ„, æ•ˆæœç±»ä¼¼å¼•ç”¨,
    //
    fn random_animal(random_number: f64) -> Box<dyn Animal> {// è¿”å›ç±»å‹å†…å­˜å¤§å°ç¡®å®šäº†, ç¼–è¯‘å¯ä»¥é€šè¿‡
        if random_number < 0.5 {
            Box::new(Sheep {})
        } else {
            Box::new(Cow {})
        }
    }


```

### æ´¾ç”Ÿ trait å’Œ è‡ªåŠ¨æ¨å¯¼ traitå®ç°


```rust

    

    // æ¨å¯¼ æ´¾ç”Ÿ trait
    // ä¸‹é¢ä»¥ä¸‹æ˜¯å¯ä»¥è‡ªåŠ¨æ¨å¯¼çš„ trait
   /*
    Eq, PartialEq, Ord, PartialOrd (æ¯”è¾ƒç±»çš„ trait)
    Clone, ç”¨æ¥ä» &T åˆ›å»ºå‰¯æœ¬ Tã€‚å½“å¤„ç†èµ„æºæ—¶ï¼Œé»˜è®¤çš„è¡Œä¸ºæ˜¯åœ¨èµ‹å€¼æˆ–å‡½æ•°è°ƒç”¨çš„åŒæ—¶å°†å®ƒä»¬è½¬ç§»ã€‚ä½†æ˜¯æˆ‘ä»¬æœ‰æ—¶å€™ä¹Ÿéœ€è¦ æŠŠèµ„æºå¤åˆ¶ä¸€ä»½ã€‚
    Copyï¼Œä½¿ç±»å‹å…·æœ‰ â€œå¤åˆ¶è¯­ä¹‰â€ï¼ˆcopy semanticsï¼‰è€Œé â€œç§»åŠ¨è¯­ä¹‰â€ï¼ˆmove semanticsï¼‰ã€‚
    Hashï¼Œä» &T è®¡ç®—å“ˆå¸Œå€¼ï¼ˆhashï¼‰ã€‚
    Default, åˆ›å»ºæ•°æ®ç±»å‹çš„ä¸€ä¸ªç©ºå®ä¾‹ã€‚
    Debugï¼Œä½¿ç”¨ {:?} formatter æ¥æ ¼å¼åŒ–ä¸€ä¸ªå€¼
   */

    #[derive(Debug, Clone, Copy)]
    struct Nil;

    // `Centimeters`ï¼Œå¯ä»¥æ¯”è¾ƒçš„å…ƒç»„ç»“æ„ä½“
    #[derive(PartialEq, PartialOrd)]
    struct Centimeters(f64);

    // `Inches`ï¼Œå¯ä»¥æ‰“å°çš„å…ƒç»„ç»“æ„ä½“
    #[derive(Debug)]
    struct Inches(i32);
    impl Inches {
        fn to_centimeters(&self) -> Centimeters {
            let &Inches(inches) = self;

            Centimeters(inches as f64 * 2.54)
        }
    }
    let foot = Inches(12);
    println!("One foot equals {:?}", foot);
    let meter = Centimeters(100.0);
    let cmp =
        if foot.to_centimeters() < meter {
            "smaller"
        } else {
            "bigger"
        };
    println!("One foot is {} than one meter.", cmp);


    // `Seconds`ï¼Œä¸å¸¦é™„åŠ å±æ€§çš„å…ƒç»„ç»“æ„ä½“
    struct Seconds(i32);
    let _one_second = Seconds(1);
    // æŠ¥é”™ï¼š`Seconds` ä¸èƒ½æ‰“å°ï¼›å®ƒæ²¡æœ‰å®ç° `Debug` trait
    println!("One second looks like: {:?}", _one_second);
    // æŠ¥é”™ï¼š`Seconds`ä¸èƒ½æ¯”è¾ƒï¼›å®ƒæ²¡æœ‰å®ç° `PartialEq` trait
    let _this_is_true = (_one_second == _one_second);

```

### è¿ç®—ç¬¦é‡è½½

æ“ä½œç¬¦é‡è½½

```rust


    //
    //
    // å¾ˆå¤šè¿ç®—ç¬¦å¯ä»¥é€šè¿‡ trait æ¥é‡è½½
    //è¿™äº›è¿ç®—ç¬¦å¯ä»¥æ ¹æ®å®ƒä»¬çš„ è¾“å…¥å‚æ•°æ¥å®Œæˆä¸åŒçš„ä»»åŠ¡ã€‚è¿™ä¹‹æ‰€ä»¥å¯è¡Œï¼Œ
    //æ˜¯å› ä¸ºè¿ç®—ç¬¦å°±æ˜¯æ–¹æ³•è°ƒç”¨çš„è¯­æ³•ç³–ã€‚ä¾‹ å¦‚ï¼Œa + b ä¸­çš„ + è¿ç®—ç¬¦ä¼šè°ƒç”¨ add æ–¹æ³•ï¼ˆä¹Ÿå°±æ˜¯ a.add(b)ï¼‰ã€‚è¿™ä¸ª add æ–¹ æ³•æ˜¯ Add trait çš„ä¸€éƒ¨åˆ†
    // 
    // Add trait  é‡è½½ + è¿ç®—ç¬¦
    //
    /// Deref trait é‡è½½è§£å¼•ç”¨ç¬¦å·, å°±æ˜¯ "*" å·

    //
    //åœ¨ std::ops ä¸‹æœ‰å…¨éƒ¨é‡è½½çš„ trait
    // åœ¨std::cmp ä¸‹åˆ™æ˜¯æ¯”è¾ƒæ“ä½œçš„æ“ä½œç¬¦
    //
    //
    // ä¾‹å­: å¯¹è±¡æ’åº
    //
    // æœ‰å››ä¸ªTrait : Ordã€PartialOrd ã€Eq å’Œ PartialEq  ã€‚
    //
    use std::cmp::{Ord, PartialOrd, PartialEq, Ordering};
    #[derive(Debug)]
    struct Employee {
        name : String,
        salary : i32,
    }
    impl Ord for Employee {
        fn cmp(&self, rhs: &Self) -> Ordering {
            self.salary.cmp(&rhs.salary)
        }
    }
    impl PartialOrd for Employee {
        fn partial_cmp(&self, rhs: &Self) -> Option<Ordering> {
            Some(self.cmp(rhs))
        }
    }
    impl Eq for Employee {
    }
    impl PartialEq for Employee {
        fn eq(&self, rhs: &Self) -> bool {
            self.salary == rhs.salary
        }
    }

    //ä½¿ç”¨
    let mut v = vec![
        Employee {name : String::from("Bob"),     salary: 2048},
        Employee {name : String::from("Alice"),   salary: 3208},
        Employee {name : String::from("Tom"),     salary: 2359},
        Employee {name : String::from("Jack"),    salary: 4865},
        Employee {name : String::from("Marray"),  salary: 3743},
        Employee {name : String::from("Hao"),     salary: 2964},
        Employee {name : String::from("Chen"),    salary: 4197},
    ];
    //ç”¨for-loopæ‰¾å‡ºè–ªæ°´æœ€å¤šçš„äºº
    let mut e = &v[0];
    for i in 0..v.len() {
        if *e < v[i] { 
            e = &v[i]; 
        }
    }
    println!("max = {:?}", e);
    //ä½¿ç”¨æ ‡å‡†çš„æ–¹æ³•
    println!("min = {:?}", v.iter().min().unwrap());
    println!("max = {:?}", v.iter().max().unwrap());
    //ä½¿ç”¨æ ‡å‡†çš„æ’åºæ–¹æ³•
    v.sort();
    println!("{:?}", v);

```





### trait ç»§æ‰¿

```rust
    // 
    //
    trait Person1 {
        fn name(&self) -> String;
    }
    // Student is a supertrait of Person.
    // Implementing Student requires you to also impl Person.
    trait Student: Person1 {
        fn university(&self) -> String;
    }
    trait Programmer {
        fn fav_language(&self) -> String;
    }
    trait CompSciStudent: Programmer + Student {
        fn git_username(&self) -> String;
    }
    fn comp_sci_student_greeting(student: &dyn CompSciStudent) -> String {
        format!(
            "My name is {} and I attend {}. My Git username is {}",
            student.name(),
            student.university(),
            student.git_username()
        )
    }
    //
    //
    // è±å½¢ç»§æ‰¿é—®é¢˜: æŸä¸ª struct å®ç°ä¸¤ä¸ª trait, éœ€è¦å®ç°ä¸¤ä¸ªåŒåæ–¹æ³•
    //
    // å®Œå…¨é™å®šè¯­æ³•
    <Descriptive as Person>::xxx_fn() //ç±»ä¼¼äºå¼ºåˆ¶è½¬æ¢
    //
    // çœ‹ä¾‹å­
    trait UsernameWidget {
        fn get(&self) -> String;
    }
    trait AgeWidget {
        fn get(&self) -> u8;
    }
    struct Form {
        username: String,
        age: u8,
    }
    impl UsernameWidget for Form {
        fn get(&self) -> String {
            self.username.clone()
        }
    }
    impl AgeWidget for Form {
        fn get(&self) -> u8 {
            self.age
        }
    }
    let form = Form{
        username: "rustacean".to_owned(),
        age: 28,
    };
    // error, "multiple `get` found". Because, after all, there are multiple methods named `get`.
    println!("{}", form.get());
    //ok
    let username = <Form as UsernameWidget>::get(&form);
    assert_eq!("rustacean".to_owned(), username);
    let age = <Form as AgeWidget>::get(&form);
    assert_eq!(28, age);
    

}

```

### é™æ€åˆ†å‘ åŠ¨æ€åˆ†å‘


imp! Traitä»£è¡¨é™ æ€åˆ†å‘ ï¼Œ dyn Trait ä»£è¡¨åŠ¨æ€åˆ†å‘ ã€‚


```rs
      trait Fly {
        fn can_fly(&self) -> bool;
    }
    struct Duck;
    struct Pig;
    impl Fly for Duck {
        fn can_fly(&self) -> bool {
            true
        }
    }
    impl Fly for Pig {
        fn can_fly(&self) -> bool {
            false
        }
    }
    // ä½¿ç”¨æ³›å‹, å®šä¹‰é™æ€åˆ†å‘çš„å‡½æ•°
    // ç¼–è¯‘é˜¶æ®µ, æ³›å‹å·²ç»è¢«å±•å¼€ ä¸ºå…·ä½“ç±»å‹çš„ä»£ç , æ²¡æœ‰æŠ½è±¡å¼€é”€
    // å¯ä»¥ä½¿ç”¨ impl trait æ”¹å†™
    fn fly_static<T: Fly>(t: &T) -> bool {
        t.can_fly()
    }
    // ä½¿ç”¨ dyn å®šä¹‰åŠ¨æ€åˆ†å‘çš„å‡½æ•°
    // è¿è¡ŒæœŸå†³å®šåˆ°åº•æ˜¯ä»€ä¹ˆç±»å‹, æœ‰é¢å¤–å¼€é”€
    fn fly_dyn(t: &dyn Fly) -> bool { // æŠ½è±¡ç±»å‹æ˜¯ trait object, æ˜¯æœ‰è¦æ±‚çš„
        t.can_fly()
    }

    let pig = Pig;
    let duck = Duck;
    println!("{}", fly_static::<Pig>(&pig));
    println!("{}", fly_dyn(&duck));
```


### æŠ½è±¡ç±»å‹


#### traitå¯¹è±¡



```rs
// AbstractType ExistentialType
// ç›¸å¯¹äºå…·ä½“ç±»å‹è€Œè¨€ï¼ŒæŠ½è±¡ç±»å‹æ— æ³•ç›´æ¥å®ä¾‹åŒ–ï¼Œ ä½†æ˜¯å®ƒçš„æ¯ä¸ªå®ä¾‹éƒ½ æ˜¯å…·ä½“ç±»å‹çš„å®ä¾‹
// ç¼–è¯‘å™¨å¯èƒ½æ— æ³•ç¡®å®šå…¶ç¡®åˆ‡çš„åŠŸèƒ½å’Œæ‰€å çš„ç©ºé—´å¤§ å° ã€‚ æ‰€ä»¥ Rust ç›®å‰æœ‰ä¸¤ç§æ–¹æ³•æ¥å¤„ç†æŠ½è±¡ç±»å‹: trait å¯¹è±¡å’Œ impl Trait

// æ–¹å¼ 1: trait å¯¹è±¡
#[derive(Debug)]
struct Foo;
trait Bar {
    fn baz(&self);
}
impl Bar for Foo {
    fn baz(&self) { println!("{:?}", self) }
}
fn static_dispatch<T>(t: &T) where T:Bar {
    t.baz();
}
// åŠ¨æ€åˆ†å‘, æœ‰æ€§èƒ½å¼€é”€
fn dynamic_dispatch(t: &Bar) { // è¿™é‡Œå‚æ•°æ˜¯ä¸€ä¸ª trait object, æ— æ³•ç¡®å®šå¤§å°, å¿…é¡»ä½¿ç”¨ å¼•ç”¨ & or box
    t.baz();
}
let foo = Foo;
static_dispatch(&foo);
dynamic_dispatch(&foo);

// ä¸ºä»€ä¹ˆ å°† traitå¯¹è±¡ç§°ä¸ºåŠ¨æ€ åˆ†å‘?
// 
// std ä¸­  ä¸º trait object å®šä¹‰äº†ä¸€ä¸ª struct
// åŒ…å«è¿ä¸ªæŒ‡é’ˆ:
// 1. data ptr
//          æŒ‡å‘ ç±»å‹æ•°æ®
// 2. vtable ptr
//          æŒ‡å‘ virtual table (cpp ä¸­çš„æ¦‚å¿µ), å°±æ˜¯ä¸€ä¸ªç»“æ„ä½“, åŒ…å« ææ„å‡½æ•°, å¤§å°, æ–¹æ³•...
// 
// åœ¨ç¼–è¯‘æœŸ ï¼Œ ç¼–è¯‘å™¨åªçŸ¥é“ TraitObject åŒ…å«æŒ‡ é’ˆ çš„ä¿¡æ¯ ï¼Œ å¹¶ä¸”æŒ‡é’ˆçš„å¤§ å° ä¹Ÿæ˜¯ç¡®å®šçš„ ï¼Œå¹¶ ä¸çŸ¥é“ è¦ è°ƒç”¨å“ªä¸ª æ–¹æ³•
//åœ¨è¿è¡ŒæœŸ ï¼Œ å½“æœ‰ trait_object.method()æ–¹æ³•è¢«è°ƒ ç”¨æ—¶ï¼Œ TraitObject ä¼š æ ¹æ®è™šè¡¨æŒ‡é’ˆä»è™šè¡¨ä¸­æŸ¥å‡ºæ­£ç¡®çš„æŒ‡é’ˆï¼Œç„¶åå†è¿›è¡ŒåŠ¨æ€è°ƒç”¨ 

```

#### traitå¯¹è±¡å®‰å…¨é—®é¢˜ Sized trait

å¯¹è±¡å®‰å…¨çš„æœ¬è´¨å°±æ˜¯ä¸º äº†è®© trait å¯¹è±¡å¯ä»¥å®‰å…¨åœ°è°ƒç”¨ç›¸åº”çš„æ–¹æ³•

```rs
// å¹¶ä¸æ˜¯æ¯ä¸ª traitéƒ½å¯ä»¥ä½œä¸º traitå¯¹è±¡è¢«ä½¿ç”¨
//æ¯ä¸ª trait, Selfé»˜è®¤æœ‰ä¸€ä¸ªéšå¼çš„ trait é™å®š ?Sized, å½¢å¦‚<Self: ?Sized> , ?Sized trait åŒ…æ‹¬äº†æ‰€æœ‰çš„åŠ¨æ€å¤§å°ç±»å‹å’Œæ‰€æœ‰å¯ç¡®å®šå¤§å° çš„ç±»å‹ã€‚
// Rust ä¸­å¤§éƒ¨åˆ†ç±»å‹éƒ½é»˜è®¤æ˜¯å¯ç¡®å®šå¤§å°çš„ç±»å‹ï¼Œä¹Ÿå°±æ˜¯<T: Sized>ï¼Œè¿™ä¹Ÿæ˜¯æ³›å‹ä»£ ç å¯ä»¥æ­£å¸¸ç¼–è¯‘çš„åŸå›  
// 
// å½“ traitå¯¹è±¡åœ¨è¿è¡ŒæœŸè¿›è¡ŒåŠ¨æ€åˆ†å‘ï¼Œä¹Ÿå¿…é¡»ç¡®å®šå¤§å°ï¼Œå¦åˆ™æ— æ³•ä¸ºå…¶æ­£ç¡®åˆ†é…å†…å­˜ç©º é—´ ã€‚æ‰€ ä»¥å¿…é¡»åŒæ—¶æ»¡è¶³ä»¥ä¸‹ä¸¤æ¡è§„åˆ™çš„ trait æ‰å¯ä»¥ä½œä¸º trait å¯¹è±¡ä½¿ç”¨
//  traitå¯¹è±¡ èƒ½å¤Ÿç¼–è¯‘é€šè¿‡çš„è¦æ±‚æ˜¯, trait å¿…é¡»æ˜¯å¯¹è±¡å®‰å…¨çš„, æ»¡è¶³:
// 1.  trait çš„ Selfç±»å‹å‚æ•°ä¸èƒ½è¢«é™å®šä¸º Sized, å¿…é¡»æ˜¯ é»˜è®¤çš„ ?Sized (å› ä¸º trait objec åœ¨ç¼–è¯‘æœŸæ— æ³•ç¡®å®šå…·ä½“ç±»å‹, å¤§å°æœªçŸ¥)
// 2.  trait ä¸­æ‰€æœ‰çš„æ–¹ æ³•éƒ½å¿…é¡»æ˜¯å¯¹è±¡å®‰å…¨çš„, æ»¡è¶³ä¸‰ç‚¹ä¹‹ä¸€
//          - æ–¹æ³•å— Self: Sized çº¦æŸ
//          - trait ä¸­ ä¸èƒ½åŒ…å«å…³è”å¸¸ é‡( Associated Constant, å…¶å®šä¹‰æ–¹æ³•å’Œå…³è”ç±»å‹å·®ä¸å¤šï¼Œ åªä¸è¿‡éœ€è¦ä½¿ç”¨ constå…³é”®å­—)
//          - æ–¹æ³•æ»¡è¶³æ²¡æœ‰é¢å¤– Selfç±»å‹å‚æ•°çš„éæ³›å‹æˆå‘˜æ–¹æ³•(åˆ†è§£å¼€æ¥å°±æ˜¯ä¸‰ç‚¹)
    //          - å¿…é¡»ä¸åŒ…å«ä»»ä½•æ³›å‹å‚æ•° (å› ä¸ºå¦‚æœåŒ…å«æ³›å‹ ï¼Œtrait å¯¹ è±¡åœ¨ è™šè¡¨Vtableä¸­æŸ¥æ‰¾æ–¹æ³•æ—¶å°†ä¸ç¡®å®šè¯¥è°ƒç”¨å“ªä¸ªæ–¹æ³•)
    //          - ç¬¬ä¸€ä¸ªå‚æ•°å¿…é¡»ä¸º Self ç±»å‹æˆ–å¯ä»¥è§£å¼•ç”¨ä¸º Self çš„ç±»å‹ (æ¯”å¦‚ selfã€ &selfã€&mutselfå’Œ self: Box<Selt>)
    //          - Selfä¸èƒ½å‡ºç°åœ¨é™¤ç¬¬ä¸€ä¸ªå‚æ•°ä¹‹å¤–çš„åœ°æ–¹ï¼Œ åŒ…æ‹¬è¿”å›å€¼ä¸­ (å› ä¸ºå¦‚æœå‡ºç° Self,é‚£å°±æ„å‘³ç€ Selfå’Œ selfã€ &selfæˆ–&mutselfçš„ç±»å‹èƒ½å¤Ÿç›¸åŒ¹é…ã€‚ ä½†æ˜¯å¯¹äº traitå¯¹è±¡æ¥è¯´ï¼Œ æ ¹æœ¬æ— æ³•åšåˆ°ä¿è¯ç±»å‹åŒ¹é…)
// 
// è¿™ä¸ªtrait å°±æ— æ³•ä½œä¸º trait objectåœ¨åŠ¨æ€åˆ†å‘ä¸­ä½¿ç”¨, ä¸æ˜¯å¯¹è±¡å®‰å…¨çš„
trait Foo: Sized {...}//è¡¨ç¤ºè¦ä¸ºæŸç±»å‹å®ç° Fooï¼Œå¿…é¡»å…ˆå®ç° Sized, Foo ä¸­ çš„éšå¼ Selfè¢«è®¾å®šä¸ºæ˜¯ Sized çš„




// æ ‡å‡†çš„å¯¹è±¡å®‰å…¨çš„ trait
trait Bar {
    fn bax(self, x: u32);
     fn bay (&self) ;
     fn baz (&mut self) ;
}

// å…¸å‹çš„å¯¹è±¡ä¸å®‰å…¨çš„ trait
// 
// å¯¹è±¡ä¸å®‰å…¨çš„ trait
trait Foo {
    fn bad<T>(&self, x: T);
    fn new() -> Self;
}

//å¯¹è±¡å®‰å…¨çš„ trait ï¼Œ å°†ä¸å®‰å…¨ çš„æ–¹æ³•æ‹† åˆ† å‡º å»
trait Foo {
    fn bad<T>(&self, x: T);
}
trait Bar:Foo {
    fn new() -> Self;
}

//å¯¹è±¡å®‰å…¨çš„traitï¼Œä½¿ç”¨whereå­å¥
// åªä¸è¿‡åœ¨ traitFooä½œä¸º traitå¯¹è±¡ä¸”æœ‰?Sizedé™å®šæ—¶ï¼Œ ä¸å…è®¸è°ƒç”¨è¯¥ newæ–¹æ³•
trait Foo {
    fn bad<T>(&self, x: T);
    fn new() -> Self where Self: Sized;
}
```

#### impl trait


å¯ ä»¥é™æ€åˆ†å‘çš„æŠ½è±¡ç±»å‹ impl Trait, å¯ä»¥ç”¨æ¥æ›¿ä»£æ³›å‹çº¦æŸ, å¯ä»¥ä½¿ç”¨åŠ å· (impl Fly+Debug)


ç›®å‰ impl Trait åªå¯ä»¥åœ¨è¾“å…¥çš„å‚æ•¬å’Œè¿”å›å€¼è¿™ä¸¤ä¸ªä½ç½®ä½¿ç”¨

```rs
// â€™static æ˜¯ä¸€ç§ç”Ÿå‘½å‘¨æœŸå‚æ•° ï¼Œ å®ƒé™å®šäº† impl Fly+Debug æŠ½è±¡ç±» å‹ä¸å¯èƒ½æ˜¯å¼•ç”¨ç±»å‹
fn dyn_can_fly( s : impl Fly+Debug+ â€™static) -> Box<dyn Fly> {}
```

### traitçš„ç±»å‹è½¬æ¢

éšå¼ç±»å‹è½¬æ¢ (Implicit Type Conversion)å’Œæ˜¾å¼ç±»å‹è½¬ æ¢ (ExplicitType Conversion)

```rs
// éšå¼ç±»å‹è½¬æ¢åŸºæœ¬ä¸Šåªæœ‰ è‡ªåŠ¨è§£ å¼•ç”¨
// å¼•ç”¨ä½¿ç”¨&æ“ä½œç¬¦ï¼Œ è€Œè§£å¼•ç”¨ä½¿ç”¨*æ“ä½œç¬¦ã€‚å¯ä»¥é€šè¿‡å®ç°Deref traitæ¥è‡ªå®š

// as æ“ä½œç¬¦ æœ€å¸¸ç”¨çš„åœºæ™¯å°±æ˜¯è½¬æ¢ Rust ä¸­çš„åŸºæœ¬æ•°æ®ç±»å‹
let a: i64 = 11 as i64
// çŸ­(å¤§å°)ç±»å‹è½¬æ¢ä¸ºé•¿(å¤§å°)ç±»å‹çš„æ—¶å€™æ˜¯æ²¡æœ‰é—®é¢˜çš„ï¼Œ ä½† æ˜¯å¦‚æœåè¿‡æ¥ï¼Œåˆ™ä¼šè¢« æˆªæ–­å¤„ç†
// å½“ä»æœ‰ç¬¦å·ç±»å‹ å‘æ— ç¬¦å·ç±»å‹è½¬æ¢ çš„æ—¶å€™ï¼Œ æœ€å¥½ä½¿ç”¨æ ‡å‡†åº“ä¸­æä¾›çš„ä¸“é—¨çš„æ–¹æ³•ï¼Œè€Œä¸è¦ç›´æ¥ä½¿ç”¨ asæ“ä½œç¬¦

// ç±»å‹å’Œå­ç±»å‹ç›¸äº’è½¬æ¢
// ç”Ÿå‘½å‘¨æœŸæ ‡è®°å¯çœ‹ä½œå­ç±»å‹ã€‚ æ¯”å¦‚&â€™static strç±»å‹æ˜¯&â€™a strç±»å‹çš„å­ç±» å‹; 
//â€™a å’Œ 'static éƒ½æ˜¯ç”Ÿå‘½å‘¨æœŸæ ‡è®°ï¼Œå…¶ä¸­â€™a æ˜¯æ³›å‹æ ‡è®°ï¼Œ æ˜¯ &strçš„é€šç”¨å½¢å¼ï¼Œ è€Œâ€™staticåˆ™æ˜¯ç‰¹æŒ‡é™æ€ç”Ÿå‘½å‘¨æœŸçš„&strå­—ç¬¦ä¸²


```

### From trait Into trait

```rust
// å®šä¹‰äº std::convert æ¨¡å—ä¸­çš„ä¸¤ä¸ª traitã€‚ å®ƒä»¬å®šä¹‰äº† from å’Œ into ä¸¤ä¸ªæ–¹ æ³•ï¼Œè¿™ä¸¤ä¸ªæ–¹æ³•äº’ä¸ºåæ“ä½œ

let s = String: :from(â€helloâ€);

struct Person {
    name, String,
}
impl Person {
    //å…è®¸ä¼ å…¥çš„å‚æ•°æ˜¯&strç±»å‹æˆ– String ç±»å‹ ï¼Œæ–¹ä¾¿è¿›è¡Œå¼€å‘ (&strå’Œ Stringç±»å‹éƒ½å®ç°äº† Into, å½“å‚æ•°æ˜¯&strç±»å‹æ—¶ï¼Œä¼šé€šè¿‡ intoè½¬æ¢ä¸º String)
    fn new<T: Into<String>>(name: T) -> Self {
        Person {name: name.into()}
    }
}

// å¦‚æœç±»å‹ Uå®ç°äº† From<T>ï¼Œåˆ™ Tç±»å‹å®ä¾‹è°ƒç”¨ intoæ–¹ æ³•å°±å¯ä»¥è½¬æ¢ä¸ºç±»å‹ U (rust è‡ªåŠ¨å¸®æˆ‘ä»¬å®ç°äº† Into)
// impl<T, U> Into<U> for T where U: From<T> {}
// æ‰€ä»¥ ï¼Œ ä¸€èˆ¬æƒ…å†µä¸‹ ï¼Œ åªéœ€è¦å®ç° From å³å¯ ï¼Œ é™¤é From ä¸å®¹æ˜“å®ç°ï¼Œæ‰éœ€è¦è€ƒè™‘å® ç° Into
let a = "hello";
let b:String = a.into();//String ç±»å‹å®ç°äº† From<&str>ï¼Œæ‰€ä»¥å¯ä»¥ä½¿ç”¨ into æ–¹æ³•å°† &str è½¬æ¢ä¸º String



// TryFrom å’Œ TryInto ä¸¤ç§ traitï¼Œæ˜¯ From å’Œ Into çš„é”™è¯¯å¤„ç†ç‰ˆæœ¬

```


### DerefMutå’Œ Deref




ç”¨äºè‡ªå®šä¹‰è§£é™¤å¼•ç”¨è¿ç®—ç¬¦(*)çš„è¡Œä¸º

```rust
  let a = 11;  
  let b = Box::new(a);  
  print!("Value of *b is {}",*b); //11, box å¯ä»¥åƒæ™®é€šå¼•ç”¨ä¸€æ ·è§£å¼•ç”¨

// æ„é€ è‡ªå·±çš„ box
#[derive(Debug)]
struct MyBox<T>(T);
impl<T> MyBox<T> {
    pub fn new(v: T) -> Self {
        return MyBox(v);
    }
}
use std::ops::Deref;
impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

let b = MyBox::new(32);
println!("{:?}", b);
println!("b inner = {}", *b); //32
println!("b inner2 = {}", *b.deref());// 32, deref() è¿”å›å†…éƒ¨æ•°æ®çš„å¼•ç”¨

//è‡ªåŠ¨è§£åŒ… , deref çš„å¼ºåˆ¶æ•ˆæœ
fn prin(v: &i32) {
    println!("{}", v);
}
prin(&b) // è‡ªåŠ¨å°† &MyBox åŒ…è£…è§£é™¤, æˆä¸º &i32


```


```rs
// å¦‚æœä¸€ä¸ªç±»å‹ T å®ç°äº† Deref<Target=U>ï¼Œ åˆ™è¯¥ç±»å‹ T çš„å¼•ç”¨ (æˆ–æ™ºèƒ½æŒ‡é’ˆ)åœ¨åº”ç”¨çš„æ—¶å€™ä¼šè¢« è‡ªåŠ¨è½¬æ¢ä¸ºç±»å‹ U
// Stringç±»å‹å®ç°äº† Deref
let a = "hello".to string();
let b = " world".to string();
let c = aÃ· &b;//&bï¼Œå®ƒåº”è¯¥æ˜¯ä¸€ä¸ª&Stingç±»å‹ï¼Œè€Œ Stringç±»å‹å®ç°çš„ addæ–¹æ³•çš„å³å€¼å‚æ•°å¿…é¡»æ˜¯&strç±»å‹, ä½†ç°åœ¨å®ƒæ˜¯å¯ ä»¥æ­£å¸¸è¿è¡Œçš„ã€‚åŸå› å°±æ˜¯ String ç±»å‹å® ç°äº† Deref<Target=str>
println!(â€{:?)â€™â€, c); // "hello world"

// æ ‡å‡†åº“ä¸­å¸¸ç”¨çš„å…¶ä»–ç±»å‹éƒ½å®ç°äº† Derefï¼Œ æ¯”å¦‚ Vec<T>
fn foo(s : &[i32]){}
let v= vec![1,2,3)
foo(&v);//æ‰€ä»¥&Vec<T> ä¼šè¢«è‡ªåŠ¨è½¬æ¢ä¸º &[T]ç±»å‹ï¼Œ

// Box<T>ã€ Rc<T>ã€ Arc<T>
let x = Re::new("hello");
println1 (â€{:?}â€, x.chars());

// å½“æŸç±»å‹å’Œå…¶è§£å¼•ç”¨ç›®æ ‡ç±»å‹ä¸­åŒ…å«äº†ç›¸åŒçš„æ–¹æ³•æ—¶ï¼Œç¼–è¯‘å™¨ä¸çŸ¥é“è¯¥ç”¨å“ªä¸€ä¸ªäº†,æ­¤æ—¶å°±éœ€è¦æ‰‹åŠ¨è§£å¼•ç”¨
//  cloneæ–¹æ³•åœ¨Rcå’Œ&strç±»å‹ä¸­éƒ½è¢«å®ç°äº†ï¼Œæ‰€ä»¥è°ƒç”¨æ—¶ä¼šç›´æ¥è°ƒç”¨ Re çš„ clone æ–¹æ³•ï¼Œå¦‚æœæƒ³è°ƒç”¨ Re é‡Œé¢ &str ç±»å‹çš„ clone æ–¹æ³•ï¼Œåˆ™éœ€è¦ä½¿ç”¨â€œè§£ å¼•ç”¨â€æ“ä½œ ç¬¦ æ‰‹åŠ¨è§£å¼•ç”¨
let x= Re::new(â€helloâ€),
let y=x.clone(); //Rc<&str>çš„ clone æ–¹æ³•
let z = (*x) .clone() ; // &str çš„ clone æ–¹æ³•

// match å¼•ç”¨æ—¶ä¹Ÿéœ€è¦æ‰‹åŠ¨è§£å¼•ç”¨
// 
let x = "hello". to_string (); 
match &x {//æ‰‹åŠ¨è§£å¼•ç”¨æŠŠ& String ç±»å‹è½¬æ¢æˆ& str
        // match x.deref()ï¼Œ
        //match x.as_ref()
        //match x.borrow()
        //match &*x ä½¿ç”¨â€œè§£å¼•ç”¨ â€æ“ä½œç¬¦ï¼Œå°† Stringè½¬æ¢ä¸º strï¼Œç„¶åå†ç”¨â€œå¼•ç”¨â€æ“ä½œç¬¦è½¬ä¸º& str
        //match&x[..]ï¼Œè¿™æ˜¯å› ä¸ºStringç±»å‹çš„indexæ“ä½œå¯ä»¥è¿”å›&ç”±ç±»å‹
    "hello" => {println! ("xxx")}
}
// DerefMutå’Œ Derefç±»ä¼¼ï¼Œ åªä¸è¿‡å®ƒæ˜¯è¿”å›å¯å˜å¼•ç”¨çš„ã€‚ Derefä¸­åŒ…å«å…³è”ç±»å‹ Target, å®ƒè¡¨ç¤ºè§£å¼•ç”¨ä¹‹åçš„ç›®æ ‡ç±»å‹

```

### AsRef trait AsMut trait

 å¯ä»¥å°†å€¼åˆ†åˆ«è½¬æ¢ä¸ºä¸å¯å˜å¼•ç”¨å’Œ å¯å˜å¼•ç”¨

 AsRefå’Œæ ‡å‡†åº“çš„å¦å¤–ä¸€ä¸ª Borrow traitåŠŸèƒ½æœ‰äº›ç±»ä¼¼ï¼Œä½†æ˜¯ AsRefæ¯”è¾ƒè½»é‡çº§ï¼Œ å®ƒåªæ˜¯ç®€å•åœ°å°†å€¼è½¬æ¢ä¸ºå¼•ç”¨ï¼Œè€Œ Borrow trait å¯ä»¥ç”¨æ¥å°†æŸä¸ªå¤åˆç±»å‹æŠ½è±¡ä¸ºæ‹¥æœ‰å€Ÿç”¨è¯­ä¹‰ çš„ç±»å‹

### Borrow trait

### Debug trait

```rs
// å®ç°äº†æœ€å¸¸ç”¨ çš„ Debug traitï¼Œ å°±å¯ ä»¥æ‹¥æœ‰åœ¨ println!å®è¯­å¥ä¸­ ä½¿ç”¨{ :?}æ ¼å¼è¿›è¡Œæ‰“å°çš„è¡Œä¸ºï¼Œ
// ä¹Ÿå¯ä»¥ä½¿ç”¨ #[derive(Debug)Iå±æ€§å¸®åŠ©å¼€å‘è€…è‡ªåŠ¨å®ç° Debug trai
use std::fmt::*;
struct A {
    a: i32, 
}
impl Debug for A {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Point [")?;
        write!(f, "a = {}", self.a)?;
        write!(f, "b = {}", self.b)?;
        write!(f, "]")?;
        Ok(())
    }
}


```



### Drop trait èµ„æºé‡Šæ”¾


```rust
// ç”¨äºåœ¨å˜é‡è¶…å‡ºèŒƒå›´æ—¶ä»å †å†…å­˜ä¸­é‡Šæ”¾ç©ºé—´ (rust ä¼šéšå¼è°ƒç”¨ drop()), å¦‚é‡Šæ”¾ Box <T>æŒ‡å‘çš„å †ä¸Šçš„ç©ºé—´, 
// å¦‚ é‡Šæ”¾æ–‡ä»¶æˆ–ç½‘ç»œè¿æ¥ç­‰èµ„æº
// 
// æœ‰æ—¶ï¼Œæœ‰å¿…è¦åœ¨èŒƒå›´ç»“æŸä¹‹å‰åˆ é™¤è¯¥å€¼ã€‚å¦‚æœæƒ³æå‰åˆ é™¤è¯¥å€¼ï¼Œé‚£ä¹ˆä½¿ç”¨std::mem::dropå‡½æ•°æ¥åˆ é™¤

    //
    //
    // é‡Šæ”¾èµ„æº Drop trait
    /*
    Drop trait åªæœ‰ä¸€ä¸ªæ–¹æ³•ï¼šdropï¼Œå½“å¯¹è±¡ç¦»å¼€ä½œç”¨åŸŸæ—¶ç³»ç»Ÿä¼šè¿›è¡Œèµ„æºé‡Šæ”¾, åŒæ—¶ä¼šè‡ªåŠ¨è°ƒç”¨è¯¥ æ–¹æ³•, ç”¨äºé‡Šæ”¾ç±»ä¼¼äºæ–‡ä»¶æˆ–ç½‘ç»œè¿æ¥çš„èµ„æºã€‚, è¿™ä¸ªæ–¹æ³•ä¸å…è®¸æ‰‹åŠ¨è°ƒç”¨, ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨è°ƒç”¨, ç”¨äºé‡Šæ”¾ç±»ä¼¼äºæ–‡ä»¶æˆ–ç½‘ç»œè¿æ¥çš„èµ„æº, æˆ–è€…é‡Šæ”¾ box æ‰€æŒ‡å‘çš„å †ç©ºé—´

    ä¹Ÿå¯ä»¥ drop(a) æ‰‹åŠ¨è°ƒç”¨é‡Šæ”¾, ä½¿ç”¨ std::mem::drop(xxx)

    Boxï¼ŒVecï¼ŒStringï¼ŒFileï¼Œä»¥åŠ Process æ˜¯ä¸€äº›å®ç°äº† Drop trait æ¥é‡Šæ”¾ èµ„æºçš„ç±»å‹ã€‚
    */


// ææ„é¡ºåº
// 
// - æœ¬åœ°å˜é‡éµå¾ªå…ˆå£°æ˜çš„å˜é‡åææ„çš„è§„åˆ™ (è¿™ä¹Ÿç¼˜äºæ¡”ç»“æ„å…ˆè¿›å å‡ºçš„ç‰¹æ€§)
// - å…ƒç»„æ•´ä½“æ¥è¯´ä¹Ÿå±äºæœ¬åœ°å˜é‡, æ‰€ä»¥ææ„é¡ºåºå’Œå±€éƒ¨å˜é‡çš„ææ„é¡ºåºä¸€è‡´
//         ä½†å†…éƒ¨å…ƒç´ æ˜¯æŒ‰å…ƒç´ çš„å‡ºç°é¡ºåºä¾æ¬¡è¿›è¡Œææ„çš„
// - ç»“æ„ä½“å’Œæšä¸¾ä½“ å†…éƒ¨å…ƒç´ æŒ‰ç…§å®šä¹‰æ—¶çš„æ¬¡åºææ„ (ç±»ä¼¼å…ƒç»„çš„ææ„)
// - é—­åŒ…æ•è·å˜ é‡ çš„ææ„é¡ºåºå’Œé—­åŒ…å†…è¯¥å˜é‡çš„æ’åˆ—é¡ºåº ä¸€è‡´, ä¸æ•è·å˜ é‡å£° æ˜çš„é¡ºåºæ˜¯æ²¡æœ‰å…³ç³»çš„
// 
struct PrintDrop(&'static str);
    impl Drop for PrintDrop {
        fn drop(&mut self) {
            println!("Dropping {}", self.0)
    }
}
// é¡ºåº: y, x
let x = PrintDrop("x");
let y = PrintDrop("y");

// é¡ºåº: x, y, z, a,b,c
let tup1 = (PrintDrop("a"), PrintDrop("b"), PrintDrop("c"));
let tup2 = (PrintDrop("x"), PrintDrop("y"), PrintDrop("z"));

// é¡ºåº: y,x, a,b,c
let tup1 = (PrintDrop("a"), PrintDrop("b"), PrintDrop("c"));
let tup2 = (PrintDrop("x"), PrintDrop("y"), panic!());//çº¿ç¨‹çš„å´©æ„¤è§¦å‘äº† tup2 çš„æå‰ææ„, è¿™ ç§æå‰ææ„çš„é¡ºåºæ­£å¥½å’Œå±€éƒ¨å˜é‡çš„ææ„é¡ºåºä¸€è‡´: å…ˆå£°æ˜çš„å…ƒç´ åææ„ã€‚





// å±è”½ è§„é¿ drop æ£€æŸ¥(è·³è¿‡ å†…å­˜è‡ªåŠ¨é‡Šæ”¾)
// 
// 
struct A;
struct B;
struct Foo {
    a: A,
    b: B
}
impl Foo {
    fn take(self) -> (A, B) {
        // error[E0509]: cannot move out of type `Foo`, which implements the `Drop` trait
        // å› ä¸º drop æ–¹æ³•ä¸­å¯èƒ½è¿˜éœ€è¦ç”¨åˆ°è¿™ä¸¤ä¸ªå­—æ®µ, æ‰€ä»¥ä¸èƒ½å°†ä»–ä»¬çš„æ‰€æœ‰æƒç§»åŠ¨åˆ°å¤–éƒ¨
        (self.a, self.b)
   }

    // æ­£ç¡®:
   // é‡æ–°å®ç°take
    fn take(mut self) -> (A, B) {
        // é€šè¿‡std::mem::uninitialized()è¿›è¡Œä¼ªåˆå§‹åŒ–
        // ç”¨äºè·³è¿‡Rustçš„å†…å­˜åˆå§‹åŒ–æ£€æŸ¥
        // å¦‚æœæ­¤æ—¶å¯¹aæˆ–bè¿›è¡Œè¯»å†™ï¼Œåˆ™æœ‰UB(å¼•å‘æœªå®šä¹‰è¡Œä¸º)é£é™©ï¼Œä¸€èˆ¬åªç”¨äº FFIå’Œ Cè¯­è¨€äº¤äº”
        let a = std::mem::replace(
             &mut self.a, unsafe { std::mem::uninitialized() }
        );
        let b = std::mem::replace(
            &mut self.b, unsafe { std::mem::uninitialized() }
       );
       // é€šè¿‡forgeté¿å…è°ƒç”¨ç»“æ„ä½“å®ä¾‹çš„drop
    //    è¿™æ ·, ææ„å‡½æ•°å°±ä¸ä¼šè¢«è‡ªåŠ¨è°ƒç”¨, éœ€è¦æˆ‘ä»¬åœ¨æŸä¸ªåœ°æ–¹æ‰‹åŠ¨é‡Šæ”¾å†…å­˜
       std::mem::forget(self);
       (a, b)
   }
}
// è‹¥ä¸å®ç° Drop åˆ™ä¸Šé¢ä»£ç ä¸ä¼šæŠ¥é”™
impl Drop for Foo {
    fn drop(&mut self) {
        // do something
    }
}



// å¦å¤–çš„æ‰‹åŠ¨é‡Šæ”¾å†…å­˜çš„æ–¹å¼ 
// ManuallyDrop<T>æ˜¯ä¸€ä¸ªè”åˆä½“ï¼ŒRustä¸ä¼šä¸ºè”åˆä½“è‡ªåŠ¨å®ç°Dropã€‚ å› ä¸ºè”åˆä½“æ˜¯æ‰€æœ‰å­—æ®µå…±ç”¨å†…å­˜ï¼Œä¸èƒ½éšä¾¿è¢«ææ„ï¼Œå¦åˆ™ä¼šå¼•èµ·æœªå®šä¹‰è¡Œä¸º
// (std::mem::forget<T>å‡½æ•°çš„å®ç°å°±æ˜¯ç”¨äº†ManuallyDrop::newæ–¹æ³•)
// 
use std::mem::ManuallyDrop;
struct Peach;
struct Banana;
struct Melon;
struct FruitBox {
    peach: ManuallyDrop<Peach>,
    melon: Melon,
    banana: ManuallyDrop<Banana>,
}
impl Drop for FruitBox {
   fn drop(&mut self) {
       unsafe {
           ManuallyDrop::drop(&mut self.peach);// æ‰‹åŠ¨é‡Šæ”¾
           ManuallyDrop::drop(&mut self.banana);
       }
   }
}

```

### Clone trait


å®ç° clone, colon_from æ–¹æ³•

å¦‚æœä¸€ä¸ªç±»å‹æ˜¯ Copyçš„ï¼Œ å®ƒçš„cloneæ–¹æ³•ä»…éœ€è¦è¿”å›*selfå³å¯ 

```rs

    #[derive(Debug)]
    struct Person {
        name: String,
        age: i32,
    }

    #[test]
    fn it_works() {
        let mut p1 = Person {
            name: "aa".to_string(),
            age: 11,
        };
        let p2 = Person {
            name: "bb".to_string(),
            age: 22,
        };
        p1 = p2;
        println!("p1 = {:?}", p1);
        println!("p1 = {:?}", p2); // error, p2æ‰€æœ‰æƒè¢«è½¬ç§»äº†
    }



    // å¯ä»¥è¿™æ ·ä¿®æ”¹ä¿®æ”¹
    
    #[derive(Debug, Clone)] // åŠ ä¸Š clone trait
    struct Person {
        name: String,
        age: i32,
    }
    #[test]
    fn it_works() {
        let mut p1 = Person {
            name: "aa".to_string(),
            age: 11,
        };
        let p2 = Person {
            name: "bb".to_string(),
            age: 22,
        };
        p1 = p2.clone(); // æ˜¾å¼è°ƒç”¨ clone(), è‹¥å¸Œæœ›rust ç¢°åˆ° ç­‰å·äº†å°±è‡ªåŠ¨éšå¼è°ƒç”¨ clone() , éœ€è¦ç»™ç»“æ„ä½“åŠ ä¸Š derive(Clone, Copy), æ³¨æ„copy trait æ— æ³•å•ç‹¬ä½¿ç”¨, å¿…é¡»åœ¨ Clone trait å­˜åœ¨çš„æƒ…å†µä¸‹æ‰èƒ½ä½¿ç”¨
        println!("p1 = {:?}", p1);
        println!("p1 = {:?}", p2);
    }


```


### æ ‡ç­¾ trait

å³ å†…éƒ¨æ²¡æœ‰ä»»ä½•å†…å®¹çš„ trait, åªæ˜¯ä½œä¸ºä¸€ä¸ªæ ‡ç­¾, èµ·åˆ°æ ‡è¯†ä½œç”¨

#### Send trait å’Œ Sync trait


```rs
// å¯ä»¥å®‰å…¨åœ°è·¨çº¿ç¨‹ä¼ é€’å’Œè®¿ é—® çš„ç±»å‹ç”¨ Send å’Œ Sync æ ‡è®°ï¼Œå¦åˆ™ç”¨! Send å’Œ!Sync æ ‡è®° , è¿™æ ·ç¼–è¯‘å™¨åœ¨ç¼–è¯‘æ—¶å°±èƒ½æ£€å‡ºæ•°æ®ç«äº‰çš„éšæ‚£ï¼Œ è€Œä¸éœ€è¦ç­‰åˆ°è¿è¡Œæ—¶å†æ’æŸ¥

// å®ç°äº† Send çš„ç±»å‹ ï¼Œå¯ä»¥å®‰å…¨åœ°åœ¨çº¿ç¨‹é—´ä¼ é€’æ‰€æœ‰æƒ, å³å¯ä»¥è·¨çº¿ç¨‹ç§»åŠ¨
// å®ç°äº† Sync çš„ç±»å‹ ï¼Œå¯ä»¥è·¨çº¿ç¨‹å®‰å…¨åœ°ä¼ é€’ä¸å¯å˜å¼•ç”¨ , å³å¯ä»¥è·¨çº¿ç¨‹å…±äº«ã€‚
// 

// ä¹‹æ‰€ä»¥å¯ä»¥æ­£å¸¸åœ°moveå˜é‡ï¼Œä¹Ÿæ˜¯å› ä¸ºæ•°ç»„xä¸­çš„å…ƒç´ å‡ä¸ºåŸç”Ÿæ•°æ®ç±»å‹ï¼Œ é»˜è®¤éƒ½å®ç°äº† Send å’Œ Sync æ ‡ç­¾ traitï¼Œæ‰€ä»¥å®ƒä»¬è·¨çº¿ç¨‹ä¼ é€’å’Œè®¿é—®éƒ½å¾ˆå®‰å…¨
let mut x=vec![1, 2, 3, 4] ;
thread::spawn(move || x.push(1));

// error
//Rc æ²¡æœ‰å® ç° Send å’Œ Syncï¼Œæ‰€ä»¥ä¸èƒ½åœ¨çº¿ç¨‹ä¹‹é—´ä¼ é€’å˜ é‡ x
// å› ä¸º Rcæ˜¯ç”¨äºå¼•ç”¨è®¡æ•°çš„æ™ºèƒ½æŒ‡é’ˆï¼Œ å¦‚æœæŠŠ Rcç±»å‹çš„å˜é‡ xä¼ é€’åˆ°å¦ä¸€ä¸ªçº¿ç¨‹ä¸­ï¼Œä¼š å¯¼è‡´ä¸åŒçº¿ç¨‹çš„ Rc å˜é‡å¼•ç”¨åŒä¸€å—æ•°æ®ï¼Œ Re å†… éƒ¨å®ç°å¹¶æ²¡æœ‰åšä»»ä½•çº¿ç¨‹åŒæ­¥çš„å¤„ç†
let x = Rc::new(vec! [1, 2, 3, 4]);//
thread::spawn( move || x[1]);


// å¯¹äºè‡ªå®šä¹‰çš„æ•°æ®ç±»å‹ï¼Œå¦‚æœå…¶æˆå‘˜ç±»å‹å…¨éƒ¨å®ç° Send å’Œ Syncï¼Œæ­¤ç±»å‹æ‰ä¼šè¢«è‡ª åŠ¨å®ç° Send å’Œ Sync
```

#### Copy trait

åŒºåˆ†å€¼è¯­ä¹‰å’Œå¼•ç”¨è¯­ä¹‰

```rs
// Copy traitï¼Œç”¨æ¥æ ‡è¯† å¯ ä»¥æŒ‰ä½ å¤åˆ¶å…¶å€¼ çš„ç±»å‹
// Copy å‘Šè¯‰ç¼–è¯‘å™¨è¿™ä¸ªç±»å‹é»˜è®¤é‡‡ç”¨ copy è¯­ä¹‰ï¼Œè€Œä¸æ˜¯ move è¯­ä¹‰; åœ¨æ‰§è¡Œå˜é‡ç»‘å®šã€å‡½æ•°å‚æ•°ä¼ é€’ã€å‡½æ•°è¿”å›ç­‰åœºæ™¯ä¸‹, æ‰§è¡Œçš„æ˜¯å†…å­˜æ‹·è´æ“ä½œ

// å¼•ç”¨ç±»å‹æ— æ³•å®ç° copy trait, è™½ç„¶å¼•ç”¨è¯­ä¹‰ç±»å‹ä¸èƒ½å®ç° Copyï¼Œ ä½†å¯ä»¥å®ç° Clone çš„ clone æ–¹æ³•ï¼Œ ä»¥ å®ç°æ·±å¤åˆ¶

// Copy traitç»§æ‰¿è‡ª Clone trait, è¦å®ç° Copy trait çš„ç±»å‹ï¼Œå¿…é¡»å®ç° Clone trait ä¸­å®šä¹‰çš„æ–¹æ³•
//  Rust æä¾›äº†æ›´æ–¹ä¾¿çš„ derive å±æ€§ä¾›æˆ‘ä»¬å®Œæˆè¿™é¡¹é‡å¤çš„å·¥ä½œ
#[derive (Copy , Clone)]
struct xxx {}
// æŸä¸ªç±»å‹æ ‡æ³¨ä¸º Copyå, å°±ä¸èƒ½éšä¾¿å®ç° Clone çš„ clone æ–¹æ³•äº†, è°ƒç”¨ t.clone() æ—¶, æ‰§è¡Œçš„æ“ä½œå¿…é¡»ç­‰åŒäºâ€œç®€å•å†…å­˜æ‹·è´â€;
// æ‰€ä»¥ ä¸€èˆ¬ä½¿ç”¨ #[derive(Copy, Clone)] è¿™ç§æ–¹å¼ï¼Œè¿™ç§æƒ…å†µä¸‹å®ƒä»¬ä¿©æœ€å¥½ä¸€èµ·å‡ºç°ï¼Œé¿å…æ‰‹å·¥å®ç° Clone å¯¼è‡´é”™è¯¯



// Rust ä¸ºå¾ˆå¤šåŸºæœ¬æ•°æ®ç±»å‹å®ç°äº† Copy traitï¼Œæ¯”å¦‚å¸¸ç”¨çš„æ•°å­—ç±»å‹ã€å­—ç¬¦( Char)ã€å¸ƒå°” ç±»å‹ã€å•å…ƒå€¼ã€ä¸å¯å˜å¼•ç”¨ç­‰
// æ£€æµ‹å“ªäº›ç±»å‹å®ç° äº† Copy trait:
fn test copy<T: Copy>(t : T) { //å¦‚æœå®ç°äº†Copy traitçš„ç±»å‹ï¼Œ åˆ™å¯ä»¥æ­£å¸¸ç¼–è¯‘: å¦‚æœæ²¡æœ‰å®ç°ï¼Œåˆ™ä¼šæŠ¥é”™ã€‚
    println(â€hhhâ€);
}




// å¹¶éæ‰€æœ‰ç±»å‹éƒ½å¯ä»¥ å®ç° Copy traitã€‚ 
// å¯¹äºè‡ªå®šä¹‰ç±»å‹æ¥è¯´ï¼Œå¿…é¡»è®©æ‰€æœ‰çš„æˆå‘˜éƒ½å®ç° äº† Copy traitï¼Œ è¿™ä¸ªç±»å‹æ‰æœ‰èµ„æ ¼ å®ç° Copy traitã€‚
// å¦‚æœæ˜¯æ•°ç»„ç±»å‹ ï¼Œ ä¸”å…¶å†…éƒ¨å…ƒç´ éƒ½æ˜¯ Copy ç±»å‹ï¼Œ åˆ™æ•°ç»„æœ¬èº«å°±æ˜¯ Copy ç±»å‹;
// å¦‚æœæ˜¯å…ƒç»„ç±»å‹ï¼Œä¸”å…¶å†…éƒ¨å…ƒç´ éƒ½æ˜¯ Copy ç±»å‹ï¼Œ åˆ™è¯¥å…ƒ ç»„ä¼šè‡ªåŠ¨å®ç°Copy


```


#### Sized trait  å’Œ Unsized trait å’Œ åŠ¨æ€ç±»å‹



```rust

// sized trait ç”¨æ¥æ ‡è¯†ç¼–è¯‘æœŸå¯ç¡®å®šå¤§å°çš„ç±»å‹
// Unsize traitï¼Œ ç›®å‰è¯¥ trait ä¸ºå®éªŒç‰¹æ€§ï¼Œç”¨äºæ ‡è¯†åŠ¨æ€å¤§å°ç±»å‹ (DST)

// ç›®å‰ Rust ä¸­çš„åŠ¨æ€ç±»å‹æœ‰ trait å’Œ [T]ï¼Œ å…¶ä¸­ [T]ä»£è¡¨ä¸€å®šæ•°é‡çš„ T åœ¨å†…å­˜ ä¸­ä¾æ¬¡æ’åˆ—
// ç”¨ Unsize æ¥æ ‡è®°


// Dynamical sized type -> DST
// è¿è¡ŒæœŸæ‰çŸ¥é“å¤§å°çš„ç±»å‹
// å…¸å‹å¦‚ str (ä¸æ˜¯ &str å“¦), ç¼–è¯‘å™¨ä¸å¯çŸ¥å¤§å°
//      &str è¿™ä¸ªç±»å‹çš„å€¼åŒ…å«ä¸¤ä¸ªéƒ¨åˆ†, str çš„åœ°å€, str çš„é•¿åº¦, æ‰€ä»¥ &str çš„å¤§å°ç±»å‹å¯ä»¥ç¡®å®š å³ 2*usize
// å…¸å‹å¦‚ trait, éƒ½æ˜¯åŠ¨æ€ç±»å‹

// æ‰€ä»¥ä¸ºäº†èƒ½å¤Ÿç¼–è¯‘é€šè¿‡, å¿…é¡»å°†åŠ¨æ€ç±»å‹æ”¾åˆ°æŒ‡é’ˆèƒŒå

// Sized trait å†³å®š ç±»å‹çš„å¤§å°æ˜¯å¦åœ¨ç¼–è¯‘æœŸå¯çŸ¥, 
//
// compileré»˜è®¤ä¸º ç±»å‹åŠ ä¸Šäº† Sized trait, å¦‚:
fn xxx<T: Sized>(t: T); // æŒ‡å®š t ä¸ºå¯çŸ¥å¤§å°ç±»å‹, Sized å¯çœç•¥, ç¼–è¯‘å™¨é»˜è®¤æ·»åŠ äº†

// ?Sized åŒ…å« Sized å’Œ unsized
fn xxx<T: ?Sized> (t: T);// t ä¸º ç¼–è¯‘æœŸé—´ä¸å¯çŸ¥å¤§å°çš„ç±»å‹ or ä¸º å¯çŸ¥å¤§å°ç±»å‹, å‘Šè¯‰ ç¼–è¯‘å™¨, åˆ°åº•æ˜¯é‚£ç§ç±»å‹ä¸ç¡®å®š



// ä½†æ˜¯åŠ¨æ€å¤§å°ç±»å‹ä¸èƒ½éšæ„ä½¿ç”¨ï¼Œè¿˜éœ€è¦éµå¾ªå¦‚ä¸‹ä¸‰æ¡é™åˆ¶è§„åˆ™:
// 
// 1. åªå¯ä»¥é€šè¿‡èƒ–æŒ‡é’ˆæ¥æ“ä½œ Unsizeç±»å‹ï¼Œæ¯”å¦‚&[T]æˆ–&Trait
// 2. å˜é‡ã€å‚æ•°å’Œæšä¸¾å˜é‡ä¸èƒ½ä½¿ç”¨åŠ¨æ€å¤§å°ç±»å‹
// 3. ç»“æ„ä½“ä¸­åªæœ‰æœ€åä¸€ä¸ªå­—æ®µå¯ä»¥ä½¿ç”¨åŠ¨æ€å¤§å°ç±»å‹ï¼Œå…¶ä»–å­—æ®µä¸å¯ä»¥ä½¿ç”¨



```

### Default trait

```rs
// ä¸º struct æä¾›é»˜è®¤å€¼
struct ColoredString {
    input: String,
    fgcolor: String,
    bgcolor: String,
}
impl Default for ColoredString {
    fn default() -> Self {
        ColoredString {
            input: String::default(),// è¿™æ ·ä½¿ç”¨å³å¯
            fgcolor: String::new(),
            bgcolor: String::new(),
        }
    }
}

```

### Extend trait

```rs
// é€šè¿‡ iteratorä¸­çš„å…ƒç´ , æ‰©å……é›†åˆ
// åŒ…å«æ–¹æ³•:
// fn extend<T: IntoIterator<Item = A>>(&mut self, iter: T);

let mut s = "Hello".to_owned();
s.extend(&[' ', 'R', 'u', 's', 't']);
println!("{}", s);//Hello Rust

// String åˆšå¥½å®ç°äº†è¿™ä¸ª trait


```

### Any trait

```rs
// use std::any::Any;

```

### å’Œæ¯”è¾ƒæ’åºç›¸å…³çš„trait

```rs
// PartialEqã€ Eqã€ PartialOrd å’Œ Ord
// - PartialEqä»£è¡¨éƒ¨åˆ†ç­‰ä»·å…³ç³»ï¼Œå…¶ä¸­å®šä¹‰äº† eqå’Œ ne (ä¸ç­‰, æœ‰é»˜è®¤å®ç°)ä¸¤ä¸ªæ–¹æ³•
// - Eq ä»£è¡¨ç­‰ä»·å…³ç³»ï¼Œè¯¥ trait ç»§æ‰¿è‡ª PartialEqï¼Œ ä½†æ˜¯å…¶ä¸­æ²¡æœ‰å®šä¹‰ä»»ä½•æ–¹æ³• ã€‚ å®ƒå®é™…ä¸Š ç›¸å½“äºæ ‡è®°å®ç°äº† Eq çš„ç±»å‹æ‹¥æœ‰ç­‰ä»·å…³ç³»
// - PartialOrdå¯¹åº”äºååºï¼Œå…¶ä¸­å®šä¹‰äº† partial_cmp (å¿…é¡»å®ç°)ã€ ltã€ le(å°äºç­‰äº)ã€ gtå’Œ geäº”ä¸ªæ–¹æ³•
// - Ordå¯¹åº”äºå…¨åºï¼Œå…¶ä¸­å®šä¹‰äº† cmpã€ maxå’Œ minä¸‰ä¸ªæ–¹æ³•
// 
// æšä¸¾ä½“ä¸º Orderingï¼Œ ç”¨äºè¡¨ç¤º æ¯”è¾ƒç»“æœï¼Œå…¶ä¸­å®šä¹‰äº† å°äºã€ç­‰äºå’Œå¤§äºä¸‰ç§çŠ¶æ€ã€‚


   let mut v = [-5i32, 4, 1, -3, 2];
//    é»˜è®¤å‡åº
    v.sort();
    assert!(v == [-5, -3, 1, 2, 4]);
    // è€Œ sort_by æ˜¯æŒ‰ a å’Œ b çš„æ¯”è¾ƒç»“æœæ˜¯å¦ç­‰äº Less çš„è§„åˆ™è¿›è¡Œæ’åº çš„ï¼Œ è‹¥ç­‰äº less, åˆ™ a å°äº bï¼Œä¸ºå‡åºæ’åˆ—
    v.sort_by(|a, b| a.cmp(b));
    assert!(v == [-5, -3, 1, 2, 4]);
    v.sort_by(|a, b| b.cmp(a));
    assert!(v == [4, 2, 1, -3, -5]);
    v.sort_by_key(|k| k.abs());
   assert!(v == [1, 2, -3, 4, -5]);


   let result = 1.0.partial_cmp(&2.0);//æµ®ç‚¹æ•°ï¼Œåªèƒ½ç”¨ååºæ¯”è¾ƒ
    assert_eq!(result, Some(Ordering::Less));
    let result = 1.cmp(&1);
    assert_eq!(result, Ordering::Equal);
    let result = "abc".partial_cmp(&"Abc");
    assert_eq!(result, Some(Ordering::Greater));
    let mut v: [f32; 5] = [5.0, 4.1, 1.2, 3.4, 2.5];
    v.sort_by(|a, b| a.partial_cmp(b).unwrap());
    assert!(v == [1.2, 2.5, 3.4, 4.1, 5.0]);
    v.sort_by(|a, b| b.partial_cmp(a).unwrap());
    assert!(v == [5.0, 4.1, 3.4, 2.5, 1.2]);
```


## å…ƒç»„


```rust



    // å…ƒç»„,
    //ç±»å‹å¯ä»¥ä¸åŒ
    const tup: (i32, f64, u8, &'static str) = (500, 6.4, 1, "holla");
    // tup.0 ç­‰äº 500
    // tup.1 ç­‰äº 6.4
    // tup.2 ç­‰äº 1

    // ç»“æ„å…ƒç»„
    let (x, y, z, w) = tup;
    // y ç­‰äº 6.4

    // å½“å…ƒç»„ä¸­åªæœ‰ä¸€ä¸ªå€¼çš„æ—¶å€™ï¼Œéœ€è¦åŠ é€—å·ï¼Œå³(0,)

    // ç©ºå…ƒç»„ / å•å…ƒç±»å‹
    ()
    // é›¶å¤§å°ç±»å‹(Zero Sized Type, ZST), ä¸å ç©ºé—´
    // 
    // ä½¿ç”¨åœºæ™¯:
    // 1. åœ¨å¼€å‘æ—¶, æŸ¥çœ‹æ•°æ®ç±»å‹; 
    let a: () = vec![();10];// error, æç¤º expected (), foundstruct ã€std: :vecÂ·:Vee, è¿™æ ·å°±çŸ¥é“äº†å³å€¼ vec![(); 10]æ˜¯å‘é‡ç±»å‹
    // 2. åœ¨éœ€è¦å¾ªç¯æŒ‡å®šæ¬¡æ•°çš„ä½ç½®, ç”¨æ¥æé«˜æ€§èƒ½ (å› ä¸º Vee å†…éƒ¨è¿­ä»£å™¨ä¸­ ä¼šé’ˆå¯¹ ZST ç±»å‹åšä¸€äº›ä¼˜åŒ–)
    let v: Vee<()>= vec![(); 10];
    for i in v {
        // xxx
    }
    // 3. å®˜æ–¹æ ‡å‡†åº“ ä¸­çš„ HashSet<T> å’Œ BTreeSet<T>
    // å…¶å®åªæ˜¯æŠŠ HashMap<K, T>æ¢æˆäº† HashMap<K, ()>ï¼Œ ç„¶åå°±å¯ ä»¥å…±ç”¨ HashMap<K, T>ä¹‹å‰çš„ä»£ç ï¼Œè€Œä¸éœ€è¦å†é‡æ–°å®ç°ä¸€é HashSet<T>äº†ã€‚


```


## ç»“æ„ä½“

### ç»“æ„ä½“åŸºæœ¬ä½¿ç”¨

```rust

/// ç»“æ„ä½“
/// ç»“æ„ä½“ï¼ˆStructï¼‰ä¸å…ƒç»„ï¼ˆTupleï¼‰éƒ½å¯ä»¥å°†è‹¥å¹²ä¸ªç±»å‹ä¸ä¸€å®šç›¸åŒçš„æ•°æ®æ†ç»‘åœ¨ä¸€èµ·å½¢æˆæ•´ä½“
/// ä½†æ˜¯ç»“æ„ä½“å¯ä»¥ç»™æ¯ä¸ªæ•°æ®èµ·ä¸ªåå­—
/// è¿™æ ·è®¿é—®å®ƒæˆå‘˜çš„æ—¶å€™å°±ä¸ç”¨è®°ä½ä¸‹æ ‡äº†
///
/// å’Œ c ä¸åŒ,  Rust é‡Œ struct è¯­å¥ä»…ç”¨æ¥å®šä¹‰ï¼Œä¸èƒ½å£°æ˜å®ä¾‹ï¼Œç»“å°¾ä¸éœ€è¦ ; ç¬¦å·
///
/// ç»“æ„ä½“å¿…é¡»æŒæ¡å­—æ®µå€¼æ‰€æœ‰æƒï¼Œå› ä¸ºç»“æ„ä½“å¤±æ•ˆçš„æ—¶å€™ä¼šé‡Šæ”¾æ‰€æœ‰å­—æ®µ, æ‰€ä»¥å­—ç¬¦ä¸²å­—æ®µä½¿ç”¨ String ä¸ç”¨ &str (å› ä¸º &str æ˜¯å€Ÿç”¨çš„æ‰€æœ‰æƒ)
///
/// æ²¡æœ‰èº«ä½“çš„ç»“æ„ä½“ä¸ºå•å…ƒç»“æ„ä½“ï¼ˆUnit Structï¼‰, å¦‚ struct UnitStruct;
/// 
///
fn struct_demo() {
    // å®šä¹‰
    #[derive(Debug)] // åœ¨å®šä¹‰ struct æ—¶å¯¼å…¥è°ƒè¯•åº“, æ‰èƒ½ print
    struct Site {
        domain: String,
        name: String,
        nation: String,
        found: u32,
    }
    // å®ä¾‹åŒ–, è‹¥æ˜¯ç©º struct,     let inner_a = InnerA {};
    let domain = String::from("xiaoyureed.github.io");
    let st = Site {
        domain, // æœ‰å­—æ®µåç§°å’Œç°å­˜å˜é‡åç§°ä¸€æ ·çš„ï¼Œå¯ä»¥ç®€åŒ–ä¹¦å†™, ç±»ä¼¼ JavaScript
        name: String::from("xiaoyu"),
        nation: String::from("China"),
        found: 2013,
    };
    // éƒ¨åˆ†æ›´æ–°
    // å› ä¸ºæ²¡æœ‰å®ç°äº† Copy trait, æ‰€æœ‰ st æ‰€æœ‰æƒä¼šè½¬ç§»
    let st1 = Site {
        domain: String::from("new domain"),
        ..st
    };

    // è¾“å‡ºç»“æ„ä½“
    // éœ€è¦å®šä¹‰ struct æ—¶å¯¼å…¥è°ƒè¯•åº“ #[derive(Debug)]
    println!("st = {:?}", st1);
    // æ ¼å¼åŒ–è¾“å‡º {:#?}
    println!("st = {:#?}", st1);


// åªæœ‰ æˆå‘˜éƒ½ä¸º å¤åˆ¶è¯­ä¹‰,  struct æ‰èƒ½è‡ªåŠ¨ Copy derive 
#[derive(Debug,Copy,Clone)]
struct Book<'a> {
    name: &'a str,
    isbn: i32,
    version: i32,
}
fn main(){
    let book = Book {
        name: "Rustç¼–ç¨‹ä¹‹é“" , isbn: 20181212, version: 1
    };
    let book2 = Book { version: 2, ..book};
    println!("{:?}",book);// book ç”±äº å®ç° äº† Copy trait, æ‰€æœ‰æƒæ²¡æœ‰è½¬ç§»
    println!("{:?}",book2);
}
```

### å…ƒç»„ç»“æ„ä½“ and å•å…ƒç»“æ„ä½“


```rust



    // å…ƒç»„ç»“æ„ä½“
    // ç®€åŒ–çš„ç»“æ„ä½“, æ²¡æœ‰å­—æ®µåç§°, åªæœ‰å­—æ®µç±»å‹
    // æ˜¯ä¸ºäº†å¤„ç†é‚£äº›éœ€è¦å®šä¹‰ç±»å‹ï¼ˆç»å¸¸ä½¿ç”¨ï¼‰åˆä¸æƒ³å¤ªå¤æ‚çš„ç®€å•æ•°æ®
    struct Color(u8, u8, u8);
    struct Point(f64, f64);
    let black = Color(0, 0, 0);
    let origin = Point(0.0, 0.0);
    // ä½¿ç”¨å’Œå…ƒç»„ä¸€æ ·, é€šè¿‡ä¸‹æ ‡è®¿é—®å­—æ®µ
    println!("black = ({}, {}, {})", black.0, black.1, black.2);
    println!("origin = ({}, {})", origin.0, origin.1);
    // ç›´æ¥æ‰“å°ç»“æ„ä½“ é”™è¯¯
    // è¦æ‰“å°, ä¸¤ç§æ–¹æ³•:
    // 1. å®šä¹‰ struct æ—¶ç»§æ‰¿ #[derive(Debug)], ç„¶å ä½¿ç”¨ {:?} or {:#?} æ‰“å°
    // 2. ä¸º struct å®ç° fmt::Display æ¥å£, ç„¶åä½¿ç”¨ {} å³å¯
    // println!("tuple struct - {}", black);



    // å•å…ƒç»“æ„ä½“ å³ ç©ºçš„ç»“æ„ä½“, é›¶å¤§å°ç±»å‹(Zero Sized Type, ZST), ä¸å ç©ºé—´
    // 
    // åœ¨Debugç¼–è¯‘æ¨¡å¼ä¸‹, å¤šä¸ª ç©ºç»“æ„ä½“ å®ä¾‹æ˜¯ä¸åŒ çš„å¯¹è±¡
    // åœ¨åœ¨Releaseç¼–è¯‘æ¨¡å¼ä¸‹, ä¼šè¢«ä¼˜åŒ–ä¸ºåŒä¸€ä¸ª å¯¹è±¡ (å†…å­˜åœ°å€ç›¸åŒ)
    //
    // æ ‡å‡†åº“ä¸­è¡¨ç¤ºå…¨èŒƒå›´()çš„ RangeFullï¼Œ å°±æ˜¯ä¸€ä¸ªå•å…ƒç»“æ„ä½“

```


### ç»“æ„ä½“æ–¹æ³•

```rust

    //
    // ç»“æ„ä½“æ–¹æ³•
    //
    impl Site {
        // &self å…³é”®å­— æ€»æ˜¯ç¬¬ä¸€ä¸ªå‚æ•°, ç±»ä¼¼ Python
        fn to_string(&self) -> String {
            // self è¡¨ç¤º struct å®ä¾‹
            format!("to string -> {:?}", self)
        }
    }
    println!("st.to_string() = {}", st.to_string());

    //
    // ç»“æ„ä½“å…³è”å‡½æ•°
    //ç±»ä¼¼ Java ä¸­çš„é™æ€æ–¹æ³•, è°ƒç”¨ä¸ä¾èµ– struct å®ä¾‹
    //
    //æ²¡æœ‰ &self å‚æ•°
    impl Site {
        fn create() -> Site { // Site å¯ç”¨ Self æ›¿ä»£
            Site {
                domain: String::from("new domain create()"),
                name: String::from("xiaoyu"),
                nation: String::from("nation"),
                found: 2020,
            }
        }
    }
    let create_site = Site::create();
    println!("create_site = {:?}", create_site);

```


### new type æ¨¡å¼ å’Œ ç±»å‹åˆ«å Selfåˆ«å

å½“ä¸€ä¸ªå…ƒç»„ç»“æ„ä½“åªæœ‰ä¸€ä¸ªå­—æ®µçš„æ—¶å€™ï¼Œç§°ä¹‹ä¸º New Type æ¨¡å¼


```rust
// ä½¿ç”¨åœºæ™¯:
// - æ˜ç¡®è¯­ä¹‰: ä¸ºåŒç±»å‹çš„æ•°æ®åˆ†åˆ«å®šä¹‰æ–°çš„ç±»å‹è¿›è¡ŒåŒºåˆ†, å¦‚ ä¸º i32 ç±»å‹åˆ†åˆ«å®šä¹‰ Hour, Second ç±»å‹ (è¿™æ˜¯ä¸ºäº†èƒ½ä¿è¯åœ¨ç¼–è¯‘æ—¶ï¼Œç¼–è¯‘æœŸé—´å³å¯å‘ç°é”™è¯¯ã€‚), åŒ…è£…äº†ä¸€å±‚
// - ä½¿å¤åˆ¶è¯­ä¹‰çš„ ç±»å‹å…·æœ‰ç§»åŠ¨è¯­ä¹‰; æ¯”å¦‚ f64 æœ¬æ¥æ˜¯å¤åˆ¶è¯­ä¹‰ ï¼Œè€ŒåŒ…è£…ä¸º Miles(f64)ä¹‹ åï¼Œå› ä¸ºç»“æ„ä½“æœ¬èº«ä¸èƒ½è¢«è‡ªåŠ¨å®ç° Copyï¼Œæ‰€ä»¥ Miles(f64)å°±æˆäº†ç§»åŠ¨è¯­ä¹‰ã€‚
// - éšè—å®é™…ç±»å‹ï¼Œ é™åˆ¶åŠŸèƒ½; ä½¿ç”¨ Newtypeæ¨¡å¼åŒ…è£…çš„ç±»å‹å¹¶ä¸èƒ½è¢«å¤–ç•Œè®¿é—®ï¼Œé™¤éæ ä¾›ç›¸åº”æ–¹æ³•ã€‚
// - ç»™æ ‡å‡†åº“ä¸­çš„ç»“æ„å®ç°æ ‡åº“ä¸­çš„ trait, å¦‚ç»™ Vector å®ç° Display trait.
//         ç”±äºå­¤å„¿è§„åˆ™, è¿™æ˜æ˜¾ä¸è¡Œ, å¯ä»¥é€šè¿‡ç»™ Vector åŒ…è£…ä¸€å±‚æ¥è¾¾åˆ°ç›®çš„
    struct Wrapper(Vec<String>);
    impl std::fmt::Display for Wrapper {
        fn .....
    }

    //new type æƒ¯ç”¨æ³•
    //
    //
    struct Years(i64);
    struct Days(i64);
    impl Years {
        pub fn to_days(&self) -> Days {
            Days(self.0 * 365)
        }
    }
    impl Days {
        /// èˆå»ä¸æ»¡ä¸€å¹´çš„éƒ¨åˆ†
        pub fn to_years(&self) -> Years {
            Years(self.0 / 365)
        }
    }
    fn old_enough(age: &Years) -> bool {
        age.0 >= 18
    }
    let age = Years(5);
    let age_days = age.to_days();
    println!("Old enough {}", old_enough(&age));// åªèƒ½ä¼ å¹´å•ä½çš„æ•°å­—
    println!("Old enough {}", old_enough(&age_days.to_years()));
    
    println!("Old enough {}", old_enough(&age_days)); //å‡ºé”™, ç¼–è¯‘æœŸé—´å³å¯å‘ç° // ä¸èƒ½ä¼ å¤©å•ä½çš„æ•°å­—






    // ç±»å‹åˆ«å
    // ä¹Ÿå¯ä»¥ä½¿ç”¨ typeå…³é”®å­—ä¸ºä¸€ä¸ªç±»å‹åˆ›å»ºåˆ«åï¼Œå¦‚ä»£ç ç¬¬ 2è¡Œä¸º i32ç±»å‹åˆ›å»ºäº†ä¸€ä¸ªåˆ«å Intï¼Œ ä½†æ˜¯å…¶æœ¬è´¨è¿˜æ˜¯ i32 ç±»å‹ï¼Œå®ƒæ‰€æ‹¥æœ‰çš„è¡Œä¸ºå’Œ i32 æ˜¯ä¸€æ · çš„ ã€‚ç›¸ æ¯”ä¹‹ä¸‹ï¼Œ New Type æ¨¡å¼ å±äº è‡ªå®šä¹‰ç±»å‹ï¼Œæ›´åŠ çµæ´»
    //åˆ«åçš„ä¸»è¦ç”¨é€”æ˜¯é¿å…å†™å‡ºå†—é•¿çš„æ¨¡æ¿åŒ–ä»£ç ï¼ˆboilerplate codeï¼‰ã€‚å¦‚ IoResult<T> æ˜¯ Result<T, IoError> ç±»å‹çš„åˆ«åã€‚
    enum VeryVerboseEnumOfThingsToDoWithNumbers {
        Add,
        Subtract,
    }
    // Creates a type alias
    type Operations = VeryVerboseEnumOfThingsToDoWithNumbers;
    let x = Operations::Add; // èƒ½è¿™ä¹ˆç”¨
    impl VeryVerboseEnumOfThingsToDoWithNumbers {
        fn run(&self, x: i32, y: i32) -> i32 {
            match self {
                // Self åˆ«å
                Self::Add => x + y,
                Self::Subtract => x - y,
            }
        }
    }
    // `NanoSecond` æ˜¯ `u64` çš„æ–°åå­—ã€‚
    type NanoSecond = u64;
    type Inch = u64;

    // é€šè¿‡è¿™ä¸ªå±æ€§å±è”½è­¦å‘Šã€‚
    #[allow(non_camel_case_types)]
    type u64_t = u64;
    // `NanoSecond` = `Inch` = `u64_t` = `u64`.
    let nanoseconds: NanoSecond = 5 as u64_t;
    let inches: Inch = 2 as u64_t;
}
```


### æ¡ˆä¾‹ å½©è‰²å‘½ä»¤è¡Œè¾“å‡º

main.rs 

```rs
mod color;
use color::Colorized;

fn main() {
    let s=  "hello".red().on_yellow();
    println!("{}", s);
}
```


color.rs 

```rs
use std::fmt::Display;

pub struct ColorString {
    input: String, // å†…å®¹
    fg: String,    // å‰æ™¯
    bg: String,    // èƒŒæ™¯
}
// å®ç°é»˜è®¤å€¼, å¯¹ color string è¿›è¡Œåˆå§‹å¡«å……
impl Default for ColorString {
    fn default() -> Self {
        ColorString {
            input: String::default(),
            fg: String::default(),
            bg: String::default(),
        }
    }
}
pub trait Colorized {
    // å…³è”å¸¸é‡, å’Œè”ç±»å‹ç±»ä¼¼ï¼Œ ç”±å®ç°è¯¥ trait çš„ç±»å‹æ¥æŒ‡å®šå¸¸é‡çš„å€¼
    // è¿™é‡ŒæŒ‡å®šäº†é»˜è®¤å€¼
    const FG_RED: &'static str = "31";
    const BG_YELLOW: &'static str = "43";

    fn red(self) -> ColorString;

    fn on_yellow(self) -> ColorString;
}

impl Colorized for ColorString {
    fn red(self) -> ColorString {
        ColorString {
            fg: String::from(Self::FG_RED),
            ..self
        }
    }

    fn on_yellow(self) -> ColorString {
        ColorString {
            bg: String::from(Self::BG_YELLOW),
            ..self
        }
    }

    const FG_RED: &'static str = "31";

    const BG_YELLOW: &'static str = "43";
}

impl<'a> Colorized for &'a str {
    fn red(self) -> ColorString {
        ColorString {
            input: String::from(self),
            fg: String::from(Self::FG_RED),
            ..ColorString::default()
        }
    }

    fn on_yellow(self) -> ColorString {
        ColorString {
            input: String::from(self),
            bg: String::from(Self::BG_YELLOW),
            ..ColorString::default()
        }
    }

    const FG_RED: &'static str = "31";

    const BG_YELLOW: &'static str = "43";
}
impl ColorString{
    // ç»„è£… ansi ç 
    // \xlB[43;31m, 
    fn compute_style(&self) -> String {
        let mut res = String::from("\x1B[");// ansi ç èµ·å§‹
        let mut has_wrote = false;
        if !self.bg.is_empty() {
            res.push_str(&self.bg);
            has_wrote = true;
        }
        if !self.fg.is_empty() {
            if has_wrote {
                res.push(';');
            }
            res.push_str(&self.fg);
        }
        res.push('m');// ansi ç ç»“æŸ
        res
    }
}
impl Display for ColorString {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&self.compute_style())?;
        write!(f, "{}", self.input)?;
        write!(f, "\x1B[0m")?;
        Ok(())
    }
}
```



## æšä¸¾

### æšä¸¾åŸºæœ¬ä½¿ç”¨

```rust

/// æšä¸¾ç±»
///
/// æšä¸¾å…ƒç´ å¯ä»¥å„ä¸ç›¸åŒ
///
fn enum_demo() {
    println!("-------------enum demo-----------------------");


       enum Resp<T, E> {
            Obj(T),
            Err(E),
        }

        fn divide(a: i32, b: i32) -> Resp<i32, String> {
            if b == 0 {
                return Resp::Err("åˆ†æ¯ä¸èƒ½ä¸ºé›¶".to_owned());
            }
            Resp::Obj(a / b)
        }

        let a = divide(4, 2);
        let b = divide(4, 0);

        match a {
            Resp::Obj(n) => println!("n: {}", n),
            _ => {}
        }
        match b {
            Resp::Err(msg) => println!("msg: {}", &msg),
            _ => {}
        }


    #[derive(Debug)]
    enum Book {
        Papery,
        Book1(i32),
        Book2(String),
        Book3 {field1: String, field2: String},
    }
    let book = Book::Papery;
    println!(" enum book = {:?}", book);

    // å®ä¾‹åŒ–å¸¦å±æ€§çš„æšä¸¾ç±»
    let boot1 = Book::Book1(11);
    // é”™è¯¯, æ²¡è¿™ä¸ªè¯­æ³•
    println!("book1.0 = {}", boot1.0);
    // æ­£ç¡®
    println!("book1 = {:?}", boot1);

    // è®¿é—®æšä¸¾ç±»çš„å±æ€§, å¿…é¡»å€ŸåŠ© match
    let book3 = Book::Book3{
        field1: String::from("hello"),
        field2: String::from("world"),
    };
    match book3 {
        Book::Papery => println!("book"),
        // å¯¹äº å…ƒç»„, ç”±äºæ²¡æœ‰å­—æ®µåç§°, éœ€è¦ä¸´æ—¶æŒ‡å®šä¸€ä¸ªå½¢å‚
        Book::Book1(i) => println!("book1.i = {}", i),
        Book::Book2(s) => println!("book2.s = {}", s),
        Book::Book3{field1, field2} => {
            println!("book3.field1 = {}, book3.field2 = {}", field1, field2);
        },
        _ =>  println!("no match"),
    }


```

### Option 


```rust

// Option æšä¸¾ç±»
    //æ˜¯ Rust æ ‡å‡†åº“ä¸­çš„æšä¸¾ç±»ï¼Œè¿™ä¸ªç±»ç”¨äºå¡«è¡¥ Rust ä¸æ”¯æŒ null å¼•ç”¨çš„ç©ºç™½
    //
    // enum Option<T> {
    //    Some(T),
    //    None,
    // }
    // 

    // ä½¿ç”¨åœºæ™¯:
    // - åˆå§‹åŒ–å€¼
    // - ä½œä¸ºå‡½æ•°çš„è¿”å›å€¼, è¡¨ç¤ºç©º, or å‡ºç°çš„ç®€å•é”™è¯¯
    // - ä½œä¸ºå‡½æ•°å¯é€‰å‚æ•°
    // - ä½œä¸ºç»“æ„ä½“çš„å¯é€‰å­—æ®µ
    // - ä½œä¸ºç»“æ„ä½“ä¸­å¯å€Ÿå‡º/è½½å…¥çš„å­—æ®µ
    // - ä»£è¡¨ç©ºæŒ‡é’ˆ

    // è§£å¼€å¯ä»¥é€šè¿‡ match æ¨¡å¼åŒ¹é…, 
    // or:
    // é€šè¿‡ unwrap ç³»åˆ—æ–¹æ³•
    // - expect("error message") è§£å¼€ Some, è‹¥ None, åˆ™ panic!("error message")
    // -  unwrap()    è§£å¼€ Some, è‹¥ç¢°åˆ° None, åˆ™ panic
    // - unwrap_or(T)  è§£å¼€ Some, è‹¥ç¢°åˆ° None, åˆ™ è¿”å›æŒ‡å®šçš„é»˜è®¤å€¼
    // - unwrap_or_else(FnOnce()->T) è§£å¼€ Some, ç¢°åˆ° None, åˆ™æ‰§è¡Œä¸€æ®µé—­åŒ… 


    let opt = Option::Some("Hello"); // opt å…è®¸ä¸ºç©º
    match opt {
        Option::Some(something) => {
            println!("{}", something);
        },
        Option::None => {
            println!("opt is nothing");
        }
    }
    // ç›´æ¥å®šä¹‰ä¸€ä¸ª &str ç±»å‹çš„ç©ºå€¼
    //Option æ˜¯ Rust ç¼–è¯‘å™¨é»˜è®¤å¼•å…¥çš„ï¼Œåœ¨ä½¿ç”¨æ—¶å¯ä»¥çœç•¥ Option:: ç›´æ¥å†™ None æˆ–è€… Some()ã€‚
    let opt: Option<&str> = None;
    match opt {
        Some(something) => {
            println!("{}", something);
        },
        None => {
            println!("opt is nothing");
        }
    }


    // 
    // æµå¼å¤„ç†
    // ç»„åˆç®—å­ combinator: ç®€åŒ– match å¤„ç†
    // 
    // map()
    // map_or() å¯ä»¥ä¸º None æŒ‡å®šé»˜è®¤å€¼
    // map_or_else()
    //
    // æ¥å—ä¸€ä¸ªå‡½æ•°f, è¿”å›ä¸€ä¸ªoption, è¿™ä¸ªå‡½æ•°f:
    //  - å‚æ•°ä¸ºoptionåŒ…å«çš„å…ƒç´ , è¿”å›å€¼ä¸ºå¤„ç†åçš„å…ƒç´ 
    //
    // 
    // è¦æ±‚å¤„ç†çš„optionä¸­å…ƒç´ å¯ä»¥æ˜¯ä¸åŒç±»å‹
    // 
    // 
    #[derive(Debug)] enum Food { Apple, Potato, Banana}
    #[derive(Debug)] struct Peeled(Food);//å‰Šçš®çš„é£Ÿç‰©
    #[derive(Debug)] struct Chopped(Food);//åˆ‡å—çš„é£Ÿç‰©
    #[derive(Debug)] struct Cooked(Food);// çƒ¹ç…®çš„é£Ÿç‰©
    fn process(food: Option<Food>) -> Option<Cooked> {
        food.map(|foo| Peeled(foo))// é—­åŒ…å‚æ•°æ˜¯Food ç±»å‹, è¿™é‡Œæ˜¯è§£å¼€äº† Option, è¿”å› Option<Peeled> ç±»å‹
            .map(|Peeled(foo)| Chopped(foo)) // å‚æ•°æ˜¯ Peeled ç±»å‹, è¿™é‡Œè§£å¼€äº†Option, Peeled
            .map(|Chopped(foo)| Cooked(foo))
    }
    match process(Some(Food::Apple)) {
        Some(cooked) => println!("cooked: {:?}", cooked),
        _ => println!("error"),
    }

    //
    // and_then() 
    //
    //æ¥å—ä¸€ä¸ªå‡½æ•°fä½œä¸ºå‚æ•°, è¿”å›option, å‡½æ•°fæ»¡è¶³: 
    //- å‚æ•°ä¸º option åŒ…å«çš„å…ƒç´ , è¿”å›ä¸ºoption
    // 
    // è¦æ±‚å¤„ç†çš„optionä¸­å…ƒç´ æ˜¯ç›¸åŒç±»å‹, æ¯”å¦‚éƒ½å±äºæŸä¸ªæšä¸¾ç±»
    // 
    //
    fn to_potato(food: Food) -> Option<Food> {
        Some(Food::Potato)
    }
    fn to_banana(food: Food) -> Option<Food> {
        Some(Food::Banana)
    }
    match to_potato(Food::Apple).and_then(to_banana) {
        Some(banana) => println!("banana: {:?}", banana),
        _ => println!("error"),
    }




```

### c é£æ ¼çš„æšä¸¾

```rust
    //
    // æ‹¥æœ‰éšå¼è¾¨åˆ«å€¼ï¼ˆimplicit discriminatorï¼Œä» 0 å¼€å§‹ï¼‰çš„ enum
    enum Number {
        Zero,
        One,
        Two,
    }
    // c é£æ ¼æšä¸¾
    // æ‹¥æœ‰æ˜¾å¼è¾¨åˆ«å€¼ï¼ˆexplicit discriminatorï¼‰çš„ enum
    enum Color {
        Red = 0xff0000,
        Green = 0x00ff00,
        Blue = 0x0000ff,
    }
    // `enum` å¯ä»¥è½¬æˆæ•´å½¢ã€‚
    println!("zero is {}", Number::Zero as i32);//0
    println!("one is {}", Number::One as i32);//1
    println!("roses are #{:06x}", Color::Red as i32);//ff0000
    println!("violets are #{:06x}", Color::Blue as i32);//0000ff

```

### æ¡ˆä¾‹ å½©è‰²å‘½ä»¤è¡Œè¾“å‡ºä¼˜åŒ–

```rs
use std::convert::From;
use std::str::FromStr;
use std::string::String;
use std::fmt;

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
enum Color {
    Red,
    Yellow,
    Blue,
}

impl Color {
    pub fn to_fg_str(&self) -> &str {
        match *self {
            Color::Red => "31",
            Color::Yellow => "33",
            Color::Blue => "34",
        }
    }
    pub fn to_bg_str(&self) -> &str {
        match *self {
            Color::Red => "41",
            Color::Yellow => "43",
            Color::Blue => "44",
        }
    }
}

impl<'a> From<&'a str> for Color {
    fn from(src: &str) -> Self {
        // parse æ–¹æ³•ï¼Œè¦æ±‚ç›®æ ‡ç±»å‹å¿…é¡»å®ç° FromStr
        src.parse().unwrap_or(Color::Red)
    }
}
impl From<String> for Color {
    fn from(src: String) -> Self {
        src.parse().unwrap_or(Color::Red)
    }
}
impl FromStr for Color {
    type Err = ();
    //  from sä»• æ–¹æ³•åŒ…å«äº† é”™è¯¯å¤„ç†ç›¸å…³çš„ä»£ç 
    fn from_str(src: &str) -> Result<Self, Self::Err> {
        let src = src.to_lowercase();
        match src.as_ref() {
            "red" => Ok(Color::Red),
            "yellow" => Ok(Color::Yellow),
            "blue" => Ok(Color::Blue),
            _ => Err(()),
        }
    }
}

#[derive(Clone, Debug, PartialEq, Eq)]
struct ColoredString {
    input: String,
    fgcolor: Option<Color>,
    bgcolor: Option<Color>,
}

impl ColoredString {
    fn compute_style(&self) -> String {
        let mut res = String::from("\x1B[");
        let mut has_wrote = false;
        if let Some(ref bgcolor) = self.bgcolor {
            if has_wrote {
                res.push(';');
            }
            res.push_str(bgcolor.to_bg_str());
            has_wrote = true;
        }
        if let Some(ref fgcolor) = self.fgcolor {
            if has_wrote {
                res.push(';');
            }
            res.push_str(fgcolor.to_fg_str());
        }
        res.push('m');
        res
    }
}

impl Default for ColoredString {
    fn default() -> Self {
        ColoredString {
            input: String::default(),
            fgcolor: None,
            bgcolor: None,
        }
    }
}

// impl<'a> From<&'a str> for ColoredString {
//     fn from(s: &'a str) -> Self {
//         ColoredString { input: String::from(s), ..ColoredString::default() }
//     }
// }

trait Colorize {
    fn red(self) -> ColoredString;
    fn yellow(self) -> ColoredString;
    fn blue(self) -> ColoredString;
    // Colorå®ç°äº† Fromï¼Œæ‰€ä»¥å¯¹äº Stringå’Œ&â€™a strç±»å‹çš„å­—ç¬¦ä¸²å‡å¯é€š è¿‡ into æ–¹æ³•è½¬æ¢ä¸º Color
    fn color<S: Into<Color>>(self, color: S) -> ColoredString;
    fn on_red(self) -> ColoredString;
    fn on_yellow(self) -> ColoredString;
    fn on_blue(self) -> ColoredString;
    fn on_color<S: Into<Color>>(self, color: S) -> ColoredString;
}
impl Colorize for ColoredString {
    fn red(self) -> ColoredString {self.color(Color::Red)}
    fn yellow(self) -> ColoredString {self.color(Color::Yellow)}
    fn blue(self) -> ColoredString {self.color(Color::Blue)}
    fn color<S: Into<Color>>(self, color: S) -> ColoredString {
        ColoredString { fgcolor: Some(color.into()), ..self }
    }
    fn on_red(self) -> ColoredString {self.on_color(Color::Red)}
    fn on_yellow(self) -> ColoredString {self.on_color(Color::Yellow)}
    fn on_blue(self) -> ColoredString {self.on_color(Color::Blue)}
    fn on_color<S: Into<Color>>(self, color: S) -> ColoredString {
        ColoredString { bgcolor: Some(color.into()), ..self }
    }
}
impl<'a> Colorize for &'a str {
    fn red(self) -> ColoredString {self.color(Color::Red)}
    fn yellow(self) -> ColoredString {self.color(Color::Yellow)}
    fn blue(self) -> ColoredString {self.color(Color::Blue)}
    fn color<S: Into<Color>>(self, color: S) -> ColoredString {
        ColoredString {
            fgcolor: Some(color.into()),
            input: String::from(self),
            ..ColoredString::default()
        }
    }
    fn on_red(self) -> ColoredString {self.on_color(Color::Red)}
    fn on_yellow(self) -> ColoredString {self.on_color(Color::Yellow)}
    fn on_blue(self) -> ColoredString {self.on_color(Color::Blue)}
    fn on_color<S: Into<Color>>(self, color: S) -> ColoredString {
        ColoredString {
            bgcolor: Some(color.into()),
            input: String::from(self),
            ..ColoredString::default()
        }
    }
}

impl fmt::Display for ColoredString {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let mut input = &self.input.clone();

        try!(f.write_str(&self.compute_style()));
        try!(f.write_str(input));
        try!(f.write_str("\x1B[0m"));
        Ok(())
    }
}

fn main() {
    let red = "red".red();
    println!("{}", red);
    let yellow = "yellow".yellow().on_blue();
    println!("{}", yellow);
    let blue = "blue".blue();
    println!("{}", blue);
    let red = "red".color("red");
    println!("{}", red);
    let yellow = "yellow".on_color("yellow");
    println!("{}", yellow);
}
```


### å®ä¾‹ åˆ›å»ºé“¾è¡¨

```rust

    //
    //
    // enum çš„ä¸€ä¸ªå¸¸è§ç”¨æ³•å°±æ˜¯åˆ›å»ºé“¾è¡¨ï¼ˆlinked-listï¼‰
    //
    //
    //
    use List::*;

    enum List {
        // Consï¼šå…ƒç»„ç»“æ„ä½“ï¼ŒåŒ…å«é“¾è¡¨çš„ä¸€ä¸ªå…ƒç´ å’Œä¸€ä¸ªæŒ‡å‘ä¸‹ä¸€èŠ‚ç‚¹çš„æŒ‡é’ˆ
        Cons(u32, Box<List>),
        // Nilï¼šæœ«ç»“ç‚¹ï¼Œè¡¨æ˜é“¾è¡¨ç»“æŸ
        Nil,
    }

    // å¯ä»¥ä¸º enum å®šä¹‰æ–¹æ³•
    impl List {
        // åˆ›å»ºä¸€ä¸ªç©ºçš„ List å®ä¾‹
        fn new() -> List {
            Nil
        }

        // å¤„ç†ä¸€ä¸ª Listï¼Œåœ¨å…¶å¤´éƒ¨æ’å…¥æ–°å…ƒç´ ï¼Œå¹¶è¿”å›è¯¥ List
        // self ä¸åŠ  &
        fn prepend(self, elem: u32) -> List {
            // `Cons` åŒæ ·ä¸º List ç±»å‹
            Cons(elem, Box::new(self))
        }

        // è¿”å› List çš„é•¿åº¦
        fn len(&self) -> u32 {
            // `self` ä¸º `&List` ç±»å‹ï¼Œ`*self` ä¸º `List` ç±»å‹ï¼ŒåŒ¹é…ä¸€ä¸ªå…·ä½“çš„ `T`
            // ç±»å‹è¦å¥½è¿‡åŒ¹é…å¼•ç”¨ `&T`ã€‚
            match *self {
                // ä¸èƒ½å¾—åˆ° tail çš„æ‰€æœ‰æƒï¼Œå› ä¸º `self` æ˜¯å€Ÿç”¨çš„ï¼›æ‰€ä»¥è¦ä½¿ç”¨å¼•ç”¨
                // å› æ­¤ä½¿ç”¨ä¸€ä¸ªå¯¹ tail çš„å¼•ç”¨
                Cons(_, ref tail) => 1 + tail.len(),
                // ï¼ˆé€’å½’çš„ï¼‰åŸºå‡†æƒ…å½¢ï¼ˆbase caseï¼‰ï¼šä¸€ä¸ªé•¿åº¦ä¸º 0 çš„ç©ºåˆ—è¡¨
                Nil => 0
            }
        }

        // è¿”å›åˆ—è¡¨çš„å­—ç¬¦ä¸²è¡¨ç¤ºï¼ˆè¯¥å­—ç¬¦ä¸²æ˜¯å †åˆ†é…çš„ï¼‰
        fn stringify(&self) -> String {
            match *self {
                Cons(head, ref tail) => {
                    // `format!` å’Œ `print!` ç±»ä¼¼ï¼Œä½†è¿”å›çš„æ˜¯ä¸€ä¸ªå †åˆ†é…çš„å­—ç¬¦ä¸²ï¼Œ
                    format!("{}, {}", head, tail.stringify())
                },
                Nil => {
                    format!("Nil")
                },
            }
        }
        // // åˆ›å»ºä¸€ä¸ªç©ºé“¾è¡¨
        // let mut list = List::new();

        // // è¿½åŠ ä¸€äº›å…ƒç´ 
        // list = list.prepend(1);
        // list = list.prepend(2);
        // list = list.prepend(3);

        // // æ˜¾ç¤ºé“¾è¡¨çš„æœ€åçŠ¶æ€
        // println!("linked list has length: {}", list.len());
        // println!("{}", list.stringify());
    }
```


## match æ¨¡å¼åŒ¹é…

### æ¨¡å¼åŒ¹é…ç®€å•ä½¿ç”¨

```rust

/// match æ¨¡å¼åŒ¹é…
/// ç±»ä¼¼ Java ä¸­çš„ switch
/// 
/// å¿…é¡»ç©·å°½æ‰€æœ‰åˆ†æ”¯ (ä½¿ç”¨ _ å¿½ç•¥æŸä¸ªæƒ…å†µ), æ¯ä¸ªåˆ†æ”¯è¿”å›åŒä¸ªç±»å‹ 
///
fn match_demo() {

    println!("------------------------ match demo ------------------------");

    // å¯ä»¥å¯¹æšä¸¾ç±», å¯¹æ•´æ•°ã€æµ®ç‚¹æ•°ã€å­—ç¬¦å’Œå­—ç¬¦ä¸²åˆ‡ç‰‡å¼•ç”¨ï¼ˆ&strï¼‰ç±»å‹çš„æ•°æ®è¿›è¡Œåˆ†æ”¯é€‰æ‹©,    

    // match è¿”å›çš„å˜é‡
    let a = match "hello".len() {
        5 => "len = 5",
        0 => "len = 0",
        _ => "unkonwn len",
    };
    println!("{}", a);


    // ä½œä¸ºå‡½æ•°è¿”å›å€¼
    //
    // å®ç°ä¸€ä¸ªç¼“å­˜, ä¿å­˜ç¬¬ä¸€æ¬¡å¤„ç†åçš„å€¼
    //
    struct Cache<T> where T: Fn(i32) -> i32 {  // å‡½æ•°ç±»å‹ä½œä¸ºæ³›å‹, Fn æ˜¯ä¸€ä¸ª trait
        calc: T, 
        value: Option<i32>,
    }
    impl<T: Fn(i32) -> i32> Cache<T>{
        fn new(caculator: T) -> Self {
            Cache {
                caculator: caculator,
                value: None,
            }
        }
        
        fn value(&mut self, arg: i32) -> i32 { 
            // å¤–å±‚ match æ²¡æœ‰ return, æ²¡æœ‰ åˆ†å· 
            match self.value {
                Some(v) => v, // è¿”å›å€¼åªæ˜¯è¿”å›ç»™ match è¡¨è¾¾å¼, ä¸æ˜¯ç›´æ¥è¿”å›ç»™äº†å¤–å±‚çš„å‡½æ•°, è‹¥æƒ³ç›´æ¥è¿”å›ç»™å‡½æ•°, éœ€è¦ return å…³é”®å­—
                None => {
                    println!("ç¬¬ä¸€æ¬¡, arg = {}", arg);
                    let v = (self.caculator)(arg);// å¿…é¡»æœ‰æ‹¬å·
                    self.value = Some(v);// self å¿…é¡»å¯å˜
                    v
                }
            }
        }
    }
    let mut ca = Cache::new(|x| x+1);// è¿™é‡Œå¯ä»¥çœç•¥å‚æ•°ç±»å‹æ˜¯å› ä¸ºç±»å‹ä¿¡æ¯å®šä¹‰åœ¨å‰é¢çš„æ³›å‹ä¸­äº†
    println!("arg = 1, v = {}", ca.value(1));
    println!("arg = 1, v = {}", ca.value(1));

    // å’Œ if åˆç”¨çš„åŒ¹é…
    match value.log2() {
       x if x.is_normal() => Some(x),
       _                      => None
   }

```

### if lef while let è¯­æ³•ç³–

```rust
    // if let è¯­æ³•ç³–
    //é€‚ç”¨äºåªåŒºåˆ†ä¸¤ç§æƒ…å†µçš„ match è¯­å¥
    // è¯­æ³•:
    // if let åŒ¹é…å€¼ = æºå˜é‡ {
    //    è¯­å¥å—
    // }
    //
    //
    enum Book {
        Papery(u32),
        Electronic(String)
    }
    let book = Book::Electronic(String::from("url"));
    if let Book::Papery(index) = book {
        println!("Papery {}", index);
    } else {
        println!("Not papery book");
    }


    // ç±»ä¼¼çš„è¿˜æœ‰ while let è¯­æ³•ç³–
    while let Some(v) = xx_vec.pop() {
        println!("{}", v);
    }

    

}

```



## é”™è¯¯å¤„ç†

### æ–­è¨€

```rs
// assert ç³»åˆ—å®åœ¨è°ƒè¯•( Debug)å’Œå‘å¸ƒ( Release)æ¨¡å¼ä¸‹å‡å¯ç”¨ï¼Œ å¹¶ä¸”ä¸èƒ½è¢«ç¦ç”¨ã€‚ debug_assertç³»åˆ—å®åªåœ¨è°ƒè¯•æ¨¡å¼ä¸‹èµ·ä½œç”¨
// å°½é‡ä½¿ç”¨ debug_assert ç³»åˆ—å®è¾ƒå°æ€§èƒ½å¼€é”€
// åº•å±‚å®é™…ä¹Ÿæ˜¯ä½¿ç”¨ panic! å®å¼•å‘çº¿ç¨‹ææ…Œ

// â€¢ assert!ï¼Œ ç”¨äºæ–­è¨€å¸ƒå°”è¡¨è¾¾å¼åœ¨è¿è¡Œæ—¶ä¸€å®šè¿”å› trueã€‚
// â€¢ assert_eq!ï¼Œ ç”¨äºæ–­ è¨€ä¸¤ä¸ªè¡¨è¾¾å¼æ˜¯å¦ç›¸ç­‰(ä½¿ç”¨ PartialEq)ã€‚
// â€¢ assert_ne!ï¼Œ ç”¨äºæ–­è¨€ä¸¤ä¸ªè¡¨è¾¾å¼æ˜¯å¦ä¸ç›¸ç­‰(ä½¿ç”¨ PartialEq)ã€‚
// â€¢ debug_assert!ï¼Œ ç­‰ä»·äº asseæ­¤!ï¼Œåªèƒ½ç”¨äºè°ƒè¯•æ¨¡å¼ã€‚
// â€¢ debug assert_eq!ï¼Œ ç­‰ä»·äº asseæ­¤ä¸€eq!ï¼Œåªèƒ½ç”¨äºè°ƒè¯•æ¨¡å¼ã€‚
// â€¢ debug_assert_ne!ï¼Œ ç­‰ä»·äº assert ne!ï¼Œåªèƒ½ç”¨äºè°ƒè¯•æ¨¡å¼ ã€‚

// å‡ä¼šå¼•å‘çº¿ç¨‹ææ…Œ, åŒæ—¶è¾“å‡ºé”™è¯¯ä¿¡æ¯
assert! (x,"x wasnâ€™t true");
debug_assert!(a + b == 30,"a={), b = {}", a, b);
```


### panic å’Œ Abort


```rust
// panic ä¸ºçº¿ç¨‹ææ…Œ, ä¼šé€ æˆåº”ç”¨ç¨‹ åºä»¥éé›¶é€€å‡ºç é€€å‡ºè¿›ç¨‹ï¼Œ ä¹Ÿå°±æ˜¯å‘ç”Ÿå´©æºƒ
// Abort ä¸ºçº¿ç¨‹ç»ˆæ­¢, å°†è¿›ç¨‹ æ­£å¸¸ä¸­æ­¢ 
// 
/// RUST_BACKTRACE=1 cargo run è¿™ç§æ–¹å¼è¿è¡Œå¸¦æœ‰å›æº¯, ç¢°åˆ° panic!("xxx") ä¼šæ˜¾ç¤º backtrace
/// 
/// å¦‚æœæƒ³ä½¿ä¸€ä¸ªå¯æ¢å¤é”™è¯¯æŒ‰ä¸å¯æ¢å¤é”™è¯¯å¤„ç†(ç±»æ¯”java ä¸­ å°† exceptin è½¬ä¸º runtime exception)ï¼ŒResult ç±»æä¾›äº†ä¸¤ä¸ªåŠæ³•ï¼šunwrap() å’Œ expect(message: &str) 
//  
/// 
/// https://rust-cli.github.io/book/tutorial/errors.html
/// 
fn error_handling() {

    // ä½¿ç”¨ panic!() å®: å¯¹äºä¸å¯æ¢å¤é”™è¯¯ä½¿ç”¨ panic! å®æ¥å¤„ç†
    //
    let f = File::open("hello.txt");
    match f {
        Ok(file) => {
            println!("File opened successfully.");
        },
        Err(err) => {
            println!("Failed to open the file.");
            panic!("{:?}", err);
        }
    }
    //
    // if let è¯­æ³•ç³–
    let f = File::open("hello.txt");
    if let Ok(file) = f {
        println!("File opened successfully.");
    } else {
        println!("Failed to open the file.");
       panic!("error"); // panic ä¼šä¸­æ–­ç¨‹åº, è‹¥ä¸å¸Œæœ›ä¸­æ–­ç¨‹åº, ä¸è¦ panic
    }

    // ç®€åŒ–å†™æ³•: ç›´æ¥è§£åŒ…è£…, å¯æ¢å¤å¼‚å¸¸ä¹Ÿä¼š panic
    //
    //ä¸ä¼šä¸ºå‡½æ•°äº§ç”Ÿè¿”å›å€¼, è€Œæ˜¯ç›´æ¥ panic
    //
    let f1 = File::open("hello.txt").unwrap(); //åŸç†: åœ¨ Result ä¸º Err æ—¶è°ƒç”¨ panic! å®
    let f2 = File::open("hello.txt").expect("Failed to open.");//expect èƒ½å¤Ÿå‘ panic! å®å‘é€ä¸€æ®µæŒ‡å®šçš„é”™è¯¯ä¿¡æ¯
    // è‡ªå·±æ§åˆ¶æ˜¯å¦ panic
    unwrap_or_else(|e| {  panic!("failed to execute process: {}", e)})
    //
  



```

### Result  å’Œ é—®å·æ“ä½œç¬¦

```rust

/// å¯æ¢å¤é”™è¯¯, ç”¨ Result<T, E> ç±»æ¥å¤„ç†ï¼Œ,ç±»æ¯” java ä¸­ çš„ exception
/// //åœ¨ Rust æ ‡å‡†åº“ä¸­å¯èƒ½äº§ç”Ÿå¼‚å¸¸çš„å‡½æ•°çš„è¿”å›å€¼éƒ½æ˜¯ Result ç±»å‹çš„
/// enum Result<T, E> { 
///   Ok(T),
///   Err(E),
/// }


    // å¼‚å¸¸ä¼ é€’, å‡½æ•°è¿”å›å€¼
    //
    fn func(i: i32) -> Result<i32, bool> {
        if i >= 0 { Ok(i) }
        else { Err(false) }
    }
    fn g(i: i32) -> Result<i32, bool> {
        let t = func(i);
        return match t { // æˆ–è€…çœç•¥ return å’Œåˆ†å·
            Ok(i) => Ok(i), // åŸæ ·ä¼ ç»™ match, matchä½œä¸ºæœ€ç»ˆç»“æ„ä¼ ç»™å‡½æ•°è¿”å›å€¼
            Err(b) => Err(b)
        };
    }
    // æ›´å¥½çš„å†™æ³•: 
    //? ç¬¦çš„å®é™…ä½œç”¨æ˜¯å°† Result ç±»éå¼‚å¸¸çš„å€¼ç›´æ¥å–å‡ºï¼Œå¦‚æœæœ‰å¼‚å¸¸å°±å°†å¼‚å¸¸ Result è¿”å›å‡ºå»ã€‚æ‰€ä»¥ï¼Œ? ç¬¦ä»…ç”¨äºè¿”å›å€¼ç±»å‹ä¸º Result<T, E> çš„å‡½æ•°
    //?å· æ˜¯ â€œè¦ä¹ˆ unwrap è¦ä¹ˆ return Err(From::from(err))â€ã€‚
    //
    // ä¼šä¸ºå‡½æ•°äº§ç”Ÿè¿”å›å€¼
    //
    fn g1(i: i32) -> Result<i32, bool> {
        let t = func(i)?;
        Ok(t) // å› ä¸ºç¡®å®š t ä¸æ˜¯ Err, t åœ¨è¿™é‡Œå·²ç»æ˜¯ i32 ç±»å‹
    }
    let r = g1(10000);
    if let Ok(v) = r {println!("ok, r = {}", v)}
    else { println!("Err")}



    // è·å– error ç±»å‹, å¤„ç†å¼‚å¸¸
    fn read_text_from_file(path: &str) -> Result<String, io::Error> {
        let mut f = File::open(path)?;
        let mut s = String::new();
        f.read_to_string(&mut s)?;
        Ok(s)
    }
    let str_file = read_text_from_file("hello.txt");
    match str_file {
        Ok(s) => println!("{}", s),
        Err(e) => {
            match e.kind() {
                io::ErrorKind::NotFound => {
                    println!("No such file");
                },
                _ => {
                    println!("Cannot read the file");
                }
            }
        }
    }

    // Result çš„ map, and_then
    //
    // ç±»ä¼¼ option, resultä¹Ÿæœ‰è‡ªå·±çš„é“¾å¼å¤„ç†æ–¹æ³•
    //
    use std::num::ParseIntError;
    fn multiply(first_number_str: &str, second_number_str: &str) -> Result<i32, ParseIntError> {
        // parse() è¿”å›çš„æ˜¯ result ç±»å‹
        first_number_str.parse::<i32>().and_then(|first_number| {
            second_number_str.parse::<i32>().map(|second_number| first_number * second_number)
        })
    }
    // æ›´æ¨èçš„å†™æ³•
    //
    // æ¨èç»™ å¤ªé•¿çš„ç±»å‹èµ·ä¸ªåˆ«å
    type AliasedResult<T> = Result<T, ParseIntError>;
    fn multiply1(first_number_str: &str, second_number_str: &str) -> AliasedResult<i32> {
        let first_number = first_number_str.parse::<i32>()?;
        let second_number = second_number_str.parse::<i32>()?;
    
        Ok(first_number * second_number)
    }

    //
```



### é”™è¯¯è£…ç®± è‡ªå®šä¹‰å¼‚å¸¸

```rust
    

    //
    //
    // 
    //è£…ç®±å¯ä»¥ä¿å­˜åŸå§‹é”™è¯¯ä¿¡æ¯, åå¤„å°±æ˜¯ï¼Œè¢«åŒ…è£…çš„é”™è¯¯ç±»å‹åªèƒ½åœ¨è¿è¡Œæ—¶äº†è§£ï¼Œè€Œä¸èƒ½è¢«é™æ€åœ° åˆ¤åˆ«ã€‚
    //
    //å¯¹ä»»ä½•å®ç°äº† Error trait çš„ç±»å‹ï¼Œæ ‡å‡†åº“çš„ Box é€šè¿‡ From ä¸ºå®ƒä»¬æä¾›äº† åˆ° Box<Error> çš„è½¬æ¢, åªè¦è°ƒç”¨ XxxError.into() å³è£…ç®±
    //
    use std::error;
    use std::fmt;
    // ä¸º `Box<error::Error>` å–åˆ«åã€‚
    type Result<T> = std::result::Result<T, Box<error::Error>>;
    // è‡ªå®šä¹‰å¼‚å¸¸ /////////////////////////////
    // è¿˜å¿…é¡»åŒæ—¶å®ç° Debug å’Œ Display
    #[derive(Debug, Clone)]
    struct EmptyVec;
    impl fmt::Display for EmptyVec {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            write!(f, "invalid first item to double")
        }
    }
    impl error::Error for EmptyVec {
        fn description(&self) -> &str {
            "invalid first item to double"
        }
        fn cause(&self) -> Option<&error::Error> {
            // æ³›å‹é”™è¯¯ã€‚æ²¡æœ‰è®°å½•å…¶å†…éƒ¨åŸå› ã€‚
            None
        }
    }
    // å°†ç¬¬ä¸€ä¸ªæ•°å­—ä¹˜ä»¥2
    fn double_first(vec: Vec<&str>) -> Result<i32> {
        vec.first()
        .ok_or_else(|| EmptyVec.into())  // è£…ç®±
        .and_then(|s| {
                s.parse::<i32>()
                    .map_err(|e| e.into())  // è£…ç®±
                    .map(|i| 2 * i)
            })
    }
    
    // æ›´å¥½çš„å†™æ³•: ä½¿ç”¨ ? å·
    // ?å· æ˜¯ â€œè¦ä¹ˆ unwrap è¦ä¹ˆ return Err(From::from(err))â€ã€‚From::from æ˜¯ ä¸åŒç±»å‹é—´çš„è½¬æ¢å·¥å…·ï¼Œ
    fn double_first(vec: Vec<&str>) -> Result<i32> {
        let first = vec.first().ok_or(EmptyVec)?;
        let parsed = first.parse::<i32>()?;
        Ok(2 * parsed)
    }



}


```

### æ•è·å¼‚å¸¸

```rs
// ææ…Œå®‰å…¨: å‘ç”Ÿ panicå, ä»£ç ç»ˆæ­¢æ‰§è¡Œ, åç»­çš„èµ„æºå›æ”¶ç›¸å…³çš„ä»£ç ä¸ä¼šæ‰§è¡Œ, å¯èƒ½å¼•å‘é—®é¢˜, é˜²æ­¢è¿™æ ·çš„é—®é¢˜å°±æ˜¯ä¿è¯ææ…Œå®‰å…¨

// rust é€šè¿‡ raiiæœºåˆ¶, ä¿è¯äº†åŸºæœ¬çš„ææ…Œå®‰å…¨, å³ä½¿åœ¨ safe rust ä¸­å‘ç”Ÿ panic, ä¹Ÿèƒ½ä¿è¯èµ„æºå›æ”¶
// ä½†æ˜¯è‹¥ panic å‘ç”Ÿåœ¨ unsafe rust é‡Œé¢, å°±æ— æ³•ä¿è¯ææ…Œå®‰å…¨äº†

// catch_unwind æ–¹æ³•æ¥è®©å¼€å‘è€…æ•è·ææ…Œï¼Œæ¢å¤å½“å‰çº¿ç¨‹ã€‚
// 
// æ¥æ”¶çš„æ˜¯ä¸€ä¸ªæ­£å¸¸çš„é—­åŒ…ï¼Œåœ¨è¯¥é—­åŒ…ä¸­ å¹¶æœªå‘ç”Ÿææ…Œï¼Œæ‰€ ä»¥æ­£å¸¸æ‰§è¡Œ
let result = panic::catch_unwind(|| { println!("hello!"); });
assert!(result.is_ok());
// æ•è·æ­¤ææ…Œï¼Œå¹¶æ¢å¤å½“å‰çº¿ç¨‹
let result = panic::catch_unwind(|| { panic!("oh no!"); });// è¾“ å‡º ç»“æœ ä¸­æ‰“å° äº†ææ…Œä¿¡æ¯ï¼Œä½†æ˜¯å¹¶æ²¡æœ‰å½± å“ åˆ°åç»­ä»£ç  çš„æ‰§è¡Œ
assert!(result.is_err());
println!("{}", sum(1, 2));

// ä½¿ç”¨ set_hook è‡ªå®šä¹‰panic æ¶ˆæ¯æ¶ˆæ¯
// set_hook æ˜¯å…¨å±€æ€§è®¾ç½®ï¼Œ å¹¶ä¸æ˜¯åªé’ˆå¯¹å•ä¸ªä»£ç æ¨¡å—çš„, å¯ä»¥å’Œ take_hook é…åˆä½¿ç”¨
// 
panic::set_hook(Box::new(|panic_info| {
    if let Some(location) = panic_info.location() {
        println!("panic occurred '{}' at {}",
            location.file(), location.line()
        );
    } else {
        println!("can't get location information...");
    }
}));
let result = panic::catch_unwind(|| { panic!("oh no!"); });
assert!(result.is_err());
```

### é”™è¯¯å¤„ç†è¿›åŒ–è¿‡ç¨‹

```rust
    //
    // ç›´æ¥è§£é™¤åŒ…è£…
    // 
  // è¯»å–æ–‡ä»¶å†…å®¹, ä¸€æ­¥åˆ°ä½
    let content = std::fs::read_to_string(&args.path).unwrap();
// panic
    let content = match std::fs::read_to_string(&args.path) {
        Ok(content) => content,
        Err(err) => panic!(">>> Error occurred: {}", err),
    };
// è¿”å› error
    // éœ€è¦ main è¿”å› Result<(), Box<dyn std::error::Error>>
    let content = match std::fs::read_to_string(&args.path) {
        Ok(content) => content,
        Err(error) => {return Err(error.into())},
    };
    
    // ä½¿ç”¨é—®å·
    main() -> Result<(), Box<dyn std::error::Error>> {
        let content = std::fs::read_to_string(&args.path)?;
    }

    // æ·»åŠ é”™è¯¯ä¸Šä¸‹æ–‡, è‡ªå®šä¹‰å¼‚å¸¸
    main -> Result<(),SomeErr> {
        let content = std::fs::read_to_string(&args.path)
                .map_err(|err| SomeErr(format!("Error of reading {}: {}", &args.path, err)))?;
    }
    
    // ä½¿ç”¨ç¬¬ä¸‰æ–¹åº“
    use failure::ResultExt;
    use exitfailure::ExitFailure;
    let ref path: PathBuf = args.path;
    let content = std::fs::read_to_string(path)
        .with_context(|_| format!("could not read file {}", path.to_str().unwrap()))?;


```

### ç¬¬ä¸‰æ–¹åº“å¤„ç†å¼‚å¸¸

 error-chainå’Œ failure(æ›´æ¨è)

 error chain çš„ç‰¹è‰²æ˜¯ä½¿ç”¨è‡ªå®šä¹‰çš„å®æ¥æ–¹ä¾¿å¼€å‘è€…ç»Ÿä¸€ç®¡ç†é”™è¯¯ï¼Œ 
 
 è€Œ failureçš„é”™è¯¯ç®¡ç†æ€ç»´åˆ™æ˜¯å¯¹æ ‡å‡†åº“ä¸­ En-orçš„è¿›ä¸€æ­¥å¢å¼ºï¼Œæ›´åŠ è´´è¿‘ Rustçš„é”™è¯¯å¤„ç†æ€ æƒ³ 



## io

### å‘½ä»¤è¡Œå‚æ•°

```rust
fn io_demo() {
    //
    let args = std::env::args();
    println!("args: {:?}", args);//Args { inner: ["target/debug/hello", "main.rs"] }
    for item in args {
        println!("arg: {}", item);
    }
    //arg: target/debug/hello
    //arg: main.rs

    args.next().unwrap();
    let arg0 = args.next().unwrap();// å‘½ä»¤æœ¬èº«, æ‹¿åˆ°å‚æ•°è¦ä¸¤ä¸ª args.next()

    // æˆ–è€…ä¸€æ­¥åˆ°ä½
    let pattern = std::env::args().nth(1).expect("no pattern given");

     // æˆ–è€…é€šè¿‡ vector æ”¶é›†
    let args: Vec<String> = env::args().collect();


    //
    //
    //å‘½ä»¤è¡Œè¾“å…¥æ–‡æœ¬
    //
    let secret_number = rand::thread_rng().gen_range(1, 101);

    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("You guessed: {}", guess);

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }



```


### æ–‡ä»¶ io



```rust
    // 
    // //////////////////////////  æ–‡ä»¶ io //////////////
    //
    use std::fs;
    use std::io::prelude::*; //æ¶‰åŠåˆ° write éœ€è¦ ä¸‡èƒ½å¯¼å…¥ prelude
    // åˆ›å»ºå†™å…¥æ–‡ä»¶
    //
    //é™æ€æ–¹æ³•ï¼Œä»¥ å¯å†™ æ¨¡å¼æ‰“å¼€æ–‡ä»¶ã€‚
    //å¦‚æœæ–‡ä»¶å­˜åœ¨åˆ™æ¸…ç©ºæ—§å†…å®¹
    //å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨åˆ™æ–°å»º                  ç±»ä¼¼ echo "xxxx" > path
    let mut file = fs::File::create("./cc.md").expect("create file error");
    file.write_all("hello ".as_bytes()).expect("write error");
    file.write_all(" world".as_bytes()).expect("write error");
    file.write_all("\nä½ å¥½".as_bytes()).expect("write error");


    // è¯»å–æ–‡ä»¶
    //
    // ä¸€æ¬¡æ€§è¯»å–
    //
    //
    // é™æ€æ–¹æ³•
    let text = std::fs::read_to_string("./Cargo.toml").unwrap(); // ç›¸å¯¹è·¯å¾„æ˜¯ç›¸å¯¹äºæ ¹ç›®å½•
    println!("{}", text);
    //
    // or
    let mut file = fs::File::open("./cc.md").expect("open error");// åªè¯»æ¨¡å¼æ‰“å¼€, ç›¸å½“äº cat <path>
    let mut str_buf = String::new();
    // å®ä¾‹æ–¹æ³•
    file.read_to_string(&mut str_buf).expect("read error");
    println!("{}", str_buf);


    // ä¿®æ”¹
    //  append() ç”¨äºå°†æ–‡ä»¶çš„æ‰“å¼€æ¨¡å¼è®¾ç½®ä¸º è¿½åŠ æ¨¡å¼
    //
    //æ­¤å¤–è¿˜æœ‰ .read(true).write(true)
    // æ¯”å¦‚  OpenOptions::new().create(true).write(true).open(path) å¯åˆ›å»º, å¯å†™æ¨¡å¼æ‰“å¼€ , ç›¸å½“äº touch xxx , æœ‰åˆ™ä¸åŠ¨, æ— åˆ™åˆ›å»º
    //
    let mut file = fs::OpenOptions::new().append(true).open("./cc.md").unwrap();
    file.write_all("\nappend something...".as_bytes()).unwrap();
    let updated_content = fs::read_to_string("./cc.md").unwrap();
    println!("{}", updated_content);

    // è¯»å†™äºŒè¿›åˆ¶æ–‡ä»¶
    // æ–‡ä»¶æµè¯»å–, å¤šæ¬¡è¯»å–
    // 
    // or
    // äºŒè¿›åˆ¶ ä½¿ç”¨ std::fs::read("") è¯»å– u8 ç±»å‹é›†åˆ
    //
    // å¤åˆ¶æ–‡ä»¶çš„ demo:
    //
    let mut buffer = [0u8; 5];
    let mut file = fs::File::open("cc.md").unwrap();
    println!("æ–‡ä»¶æ‰“å¼€æˆåŠŸï¼š{:?}",file);//File { fd: 3, path: ".../data.txt", read: true, write: false }
    file.read(&mut buffer).unwrap();
    println!("{:?}", buffer);
    file.read(&mut buffer).unwrap();
    println!("{:?}", buffer);

    // åˆ é™¤
    fs::remove_file("cc.md").unwrap();



    // å…¶ä»–æ–‡ä»¶ç³»ç»Ÿæ“ä½œ
    //
    //
    // åˆ›å»º ç›®å½•, è¿”å› io::Result<()>
    fs::create_dir("a") 
    //
    // é€’å½’åˆ›å»º,ç›®å½•
    fs::create_dir_all("a/c/d")

    // åˆ›å»ºç¬¦å·é“¾æ¥
    //
    unix::fs::symlink("../b.txt", "a/c/b.txt")

    //è¯»å–ç›®å½•ä¸‹çš„æ‰€æœ‰çš„å†…å®¹ï¼Œè¿”å› `io::Result<Vec<Path>>`
    //
    match fs::read_dir("a") {
        Err(why) => println!("! {:?}", why.kind()),
        Ok(paths) => for path in paths {
            println!("> {:?}", path.unwrap().path());
        },
    }

    // ç§»é™¤ä¸€ä¸ªç©ºç›®å½•ï¼Œè¿”å› `io::Result<()>`
    fs::remove_dir("a/c/d")



    println!("-----------------meta -------------------");
    // metadata å…ƒæ•°æ®
    //
    // éå†ç›®å½•
    let meta = fs::metadata("./src");
    /*
        Ok(Metadata {
            file_type: FileType(FileType {
                mode: 16895
            }),
            is_dir: true,
            is_file: false,
            permissions: Permissions(FilePermissions {
                mode: 16895
            }),
            modified: Ok(SystemTime {
                tv_sec: 1597127845,
                tv_nsec: 217049100
            }),
            accessed: Ok(SystemTime {
                tv_sec: 1597132516,
                tv_nsec: 30962100
            }),
            created: Err(Custom {
                kind: Other,
                error: "creation time is not available for the filesystem"
            })
        })
    */
    println!("meta = {:?}", meta);
    println!("src is dir? {}", meta.unwrap().is_dir());//true
}

fn copy_file() {
    let mut command_line: std::env::Args = std::env::args();
   command_line.next().unwrap();

   // è·³è¿‡ç¨‹åºå
   // åŸæ–‡ä»¶
   let source = command_line.next().unwrap();

   // æ–°æ–‡ä»¶
   let destination = command_line.next().unwrap();
   let mut file_in = std::fs::File::open(source).unwrap();
   let mut file_out = std::fs::File::create(destination).unwrap();
   let mut buffer = [0u8; 4096];
   use std::io::Write;
   loop {
      let nbytes = file_in.read(&mut buffer).unwrap();
      file_out.write(&buffer[..nbytes]).unwrap();
      if nbytes < buffer.len() { break; }// å¦‚æœæŸæ¬¡è¯»å–æ²¡æœ‰å°† buf è¯»æ»¡, åˆ™å†™å®Œåé€€å‡ºå¾ªç¯
   }
}


```

## é¢å‘å¯¹è±¡ oop


### å¯è§æ€§

```rs
// rust ä¸‹æ‰€æœ‰å…ƒç´ éƒ½æ˜¯é»˜è®¤ç§æœ‰çš„, æ— æ³•åœ¨å¤–éƒ¨ä½¿ç”¨, é€šè¿‡ pub å£°æ˜ä¸º å…¬å¼€, æ‰èƒ½åœ¨å¤–éƒ¨ä½¿ç”¨
// 
// - pubï¼Œ å¯ä»¥å¯¹å¤– æš´éœ² å…¬å…±æ¥å£ï¼Œéšè—å†…éƒ¨å®ç°ç»†èŠ‚ (å¯ç”¨äºä»»ä½•å¯¹è±¡)
// - pub(crate)ï¼Œå¯¹æ•´ä¸ª crate å¯è§ ã€‚
// - pub(in Path)ï¼Œå…¶ä¸­ Pathæ˜¯æ¨¡å—è·¯å¾„(ä»¥ crate å¼€å¤´), è¡¨ç¤ºåªèƒ½åœ¨ Path æŒ‡å®šçš„æ¨¡å—ä¸­è®¿é—®
// - pub(self)ï¼Œ ç­‰ä»·äº pub(in self)ï¼Œè¡¨ç¤ºåªé™å½“å‰æ¨¡å—å¯è§/ä½¿ç”¨
// - pub(super)ï¼Œ ç­‰ä»·äº pub(in super)ï¼Œè¡¨ç¤ºåœ¨å½“å‰æ¨¡å—å’Œçˆ¶æ¨¡å—ä¸­å¯è§
// 
// 
// ç»“æ„ä½“ä¸­çš„å­—æ®µ, éœ€è¦å•ç‹¬ä½¿ç”¨ pub å…³é”®å­—æ¥ æ”¹å˜å…¶ å¯è§æ€§ 

// 2015 
pub mod outer_mod {
    pub(self) fn outer_mod_fn() {}
    pub mod inner_mod {
        // use outer_mod::outer_mod_fn;
        // å¯¹å¤–å±‚æ¨¡å— `outer_mod` å¯è§
        pub(in outer_mod) fn outer_mod_visible_fn() {}
        // å¯¹æ•´ä¸ªcrateå¯è§
        pub(crate) fn crate_visible_fn() {}
        // `outer_mod` å†…éƒ¨å¯è§
        pub(super) fn super_mod_visible_fn() {
            // è®¿é—®åŒä¸€æ¨¡å—çš„å‡½æ•°
            inner_mod_visible_fn();
            // è®¿é—®çˆ¶æ¨¡å—çš„å‡½æ•°éœ€è¦ä½¿ç”¨â€œ::â€å‰ç¼€
            ::outer_mod::outer_mod_fn();
        }
        // ä»…åœ¨`inner_mod`å¯è§
        pub(self) fn inner_mod_visible_fn() {}
    }
     
    pub fn foo() {
        inner_mod::outer_mod_visible_fn();
        inner_mod::crate_visible_fn();
        inner_mod::super_mod_visible_fn();
     
        // ä¸èƒ½ä½¿ç”¨inner_mod çš„ç§æœ‰å‡½æ•°
        // inner_mod::inner_mod_visible_fn();
    }
}
fn bar() {
    // è¯¥å‡½æ•°å¯¹æ•´ä¸ªcrateå¯è§
    outer_mod::inner_mod::crate_visible_fn();
 
    // è¯¥å‡½æ•°åªå¯¹outer_modå¯è§
    // outer_mod::inner_mod::super_mod_visible_fn();
 
    // è¯¥å‡½æ•°åªå¯¹outer_modå¯è§
    // outer_mod::inner_mod::outer_mod_visible_fn();
     
    // é€šè¿‡fooå‡½æ•°è°ƒç”¨å†…éƒ¨ç»†èŠ‚
    outer_mod::foo();
}
fn main() { bar() }






// 2018
pub mod outer_mod {
    pub(self) fn outer_mod_fn() {}
     
    pub mod inner_mod {
        // åœ¨Rust 2018 edtion æ¨¡å—ç³»ç»Ÿå¿…é¡»ä½¿ç”¨useå¯¼å…¥
        use crate::outer_mod::outer_mod_fn;
        // å¯¹å¤–å±‚æ¨¡å— `outer_mod` å¯è§
        pub(in crate::outer_mod)  fn outer_mod_visible_fn() {}
        // å¯¹æ•´ä¸ªcrateå¯è§
        pub(crate) fn crate_visible_fn() {}
        // `outer_mod` å†…éƒ¨å¯è§
        pub(super) fn super_mod_visible_fn() {
            // è®¿é—®åŒä¸€æ¨¡å—çš„å‡½æ•°
            inner_mod_visible_fn();
            // ä½¿ç”¨useå¯¼å…¥äº†outer_mod
            outer_mod_fn();
        }
        // ä»…åœ¨`inner_mod`å¯è§
        pub(self) fn inner_mod_visible_fn() {}
    }
     
    pub fn foo() {
        inner_mod::outer_mod_visible_fn();
        inner_mod::crate_visible_fn();
        inner_mod::super_mod_visible_fn();
     
        // ä¸èƒ½ä½¿ç”¨inner_mod çš„ç§æœ‰å‡½æ•°
        // inner_mod::inner_mod_visible_fn();
    }
}
fn bar() {
    // è¯¥å‡½æ•°å¯¹æ•´ä¸ªcrateå¯è§
    outer_mod::inner_mod::crate_visible_fn();
 
    // è¯¥å‡½æ•°åªå¯¹outer_modå¯è§
    // outer_mod::inner_mod::super_mod_visible_fn();
 
    // è¯¥å‡½æ•°åªå¯¹outer_modå¯è§
    // outer_mod::inner_mod::outer_mod_visible_fn();
     
    // é€šè¿‡fooå‡½æ•°è°ƒç”¨å†…éƒ¨ç»†èŠ‚
    outer_mod::foo();
}
fn main() { bar() }
```



### å¤šæ€


```rust

fn oop_demo() {

    // å¤šæ€
    //
    pub struct Screen {
        pub components: Vec<Box<dyn Draw>>,// Box<dyn Draw> ä¸ºä»»ä½•å®ç°äº† Draw trait çš„ç±»å‹çš„æ›¿èº«
    }

    // å¦å¤–å¤šæ€ä¾‹å­
    //
    struct Rectangle {
        width : u32,
        height : u32,
    } 
    struct Circle {
        x : u32,
        y : u32,
        radius : u32,
    }
    trait  IShape  { 
        fn area(&self) -> f32;
        fn to_string(&self) -> String;
    }
    impl IShape  for Rectangle {
        fn area(&self) -> f32 { (self.height * self.width) as f32 }
        fn to_string(&self) ->String {
            format!("Rectangle -> width={} height={} area={}", 
                    self.width, self.height, self.area())
        }
    }
    use std::f64::consts::PI;
    impl IShape  for Circle  {
        fn area(&self) -> f32 { (self.radius * self.radius) as f32 * PI as f32}
        fn to_string(&self) -> String {
            format!("Circle -> x={}, y={}, area={}", 
                    self.x, self.y, self.area())
        }
    }

    // ä½¿ç”¨
    use std::vec::Vec;
    let rect = Box::new( Rectangle { width: 4, height: 6});
    let circle = Box::new( Circle { x: 0, y:0, radius: 5});
    let mut v : Vec<Box> = Vec::new();
    v.push(rect);
    v.push(circle);
    for i in v.iter() {
        println!("area={}", i.area() );
        println!("{}", i.to_string() );
    }



```


### å‘ä¸‹è½¬å‹



```rust



    //å‘ä¸‹è½¬å‹
    //
    //
    //å…ˆå¾—è®© IShape ç»§æ‰¿äº Any ï¼Œå¹¶å¢åŠ ä¸€ä¸ª as_any() çš„è½¬å‹æ¥å£
    use std::any::Any;
    trait  IShape : Any + 'static  {
        fn as_any(&self) -> &dyn Any; 
        â€¦â€¦ â€¦â€¦ â€¦â€¦ 
    }
    //ç„¶åï¼Œåœ¨å…·ä½“ç±»ä¸­å®ç°è¿™ä¸ªæ¥å£
    impl IShape  for Rectangle {
        fn as_any(&self) -> &dyn Any { self }
        â€¦â€¦ â€¦â€¦ â€¦â€¦ 
    }
    impl IShape  for Circle  {
        fn as_any(&self) -> &dyn Any { self }
        â€¦â€¦ â€¦â€¦ â€¦â€¦ 
    }
    let mut v : Vec<Box<dyn IShape>> = Vec::new();
    v.push(rect);
    v.push(circle);
    for i in v.iter() {
        if let Some(s) = i.as_any().downcast_ref::<Rectangle>() {
            println!("downcast - Rectangle w={}, h={}", s.width, s.height);
        }else if let Some(s) = i.as_any().downcast_ref::<Circle>() {
            println!("downcast - Circle x={}, y={}, r={}", s.x, s.y, s.radius);
        }else{
            println!("invaild type");
        }
    }



    
}

```

### å„ç§selfåŒºåˆ†ä½¿ç”¨

```rs
&self           å¸¸ç”¨, è¡¨ç¤ºå½“å‰å¯¹è±¡çš„å¼•ç”¨, ä¸å¯å˜, æ— æ³•ä¿®æ”¹
&mut self       å¸¸ç”¨, è¡¨ç¤ºå½“å‰å¯¹è±¡çš„å¼•ç”¨, å¯å˜
self            ä¸å¸¸ç”¨, è¡¨ç¤ºå½“å‰å¯¹è±¡æœ¬èº«, æ“ä½œå®Œæˆå, å½“å‰å¯¹è±¡æ— æ³•å†ä½¿ç”¨,ä¼šè¢«ä¸¢å¼ƒå›æ”¶ (åœºæ™¯: ææ„å‡½æ•°)
mut self        ä¸å¸¸ç”¨ ..... æ“ä½œå®Œæˆè¢«ä¸¢å¼ƒ



```


### è®¾è®¡æ¨¡å¼

#### å»ºé€ è€…æ¨¡å¼

```rs
// std::process::Command å°±ä½¿ç”¨äº† å»ºé€ è€…æ¨¡å¼


struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}
struct CircleBuilder {
    x: f64,
    y: f64,
    radius: f64,
}
impl Circle {
    fn area(&self) -> f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
    fn new() -> CircleBuilder {
        CircleBuilder {
            x: 0.0, y: 0.0, radius: 1.0,
        }
   }
}
impl CircleBuilder {
   fn x(&mut self, coordinate: f64) -> &mut CircleBuilder {
       self.x = coordinate;
       self
   }
   fn y(&mut self, coordinate: f64) -> &mut CircleBuilder {
       self.y = coordinate;
       self
   }
   fn radius(&mut self, radius: f64) -> &mut CircleBuilder {
       self.radius = radius;
      self
   }
   fn build(&self) -> Circle {
       Circle {
           x: self.x, y: self.y, radius: self.radius,
       }
   }
}
```

#### è®¿é—®è€…æ¨¡å¼


```rs
// ç”¨äºå°†æ•°æ®ç»“æ„å’Œä½œç”¨äºç»“æ„ä¸Šçš„æ“ä½œè§£ç¥¸ã€‚
// è®¿é—®è€…æ¨¡å¼ä¸€èˆ¬åŒ…å«ä¸¤ä¸ªå±‚ æ¬¡:
// - å®šä¹‰éœ€è¦æ“ä½œçš„å…ƒç´ ã€‚
// - å®šä¹‰ç›¸å…³çš„æ“ä½œ. ä¸€èˆ¬å°†æ“ä½œå°è£…åˆ°ä¸€ä¸ª trait ä¸­, é’ˆå¯¹ä¸åŒçš„å…ƒç´ , æœ‰ä¸åŒçš„æ–¹æ³•å®ç°
// Serdeçš„æ¶æ„æ˜¯è®¿é—®è€…æ¨¡å¼


use std::any::Any;
trait HouseElement {
    fn accept(&self, visitor: &HouseElementVisitor);
    fn as_any(&self) -> &Any;
}
trait HouseElementVisitor {
    fn visit(&self, element: &HouseElement);
}
struct House {
    components: Vec<Box<HouseElement>>,
}
impl House {
    fn new() -> Self {
        House {
            components: vec![Box::new(Livingroom::new())],
        }
    }
}
impl HouseElement for House {
    fn accept(&self, visitor: &HouseElementVisitor) {
        for component in self.components.iter() {
            component.accept(visitor);
        }
        visitor.visit(self);
    }
    fn as_any(&self) -> &Any { self }
}

struct Livingroom;
impl Livingroom {
    fn new() -> Self { Livingroom }
}
impl HouseElement for Livingroom {
    fn accept(&self, visitor: &HouseElementVisitor) {
        visitor.visit(self);
    }
    fn as_any(&self) -> &Any { self }
}

struct HouseElementListVisitor;
impl HouseElementListVisitor {
    fn new() -> Self { HouseElementListVisitor }
}

impl HouseElementVisitor for  HouseElementListVisitor {
    fn visit(&self, element: &HouseElement) {
        match element.as_any() {
            house if house.is::<House>() => println!("Visiting the house..."),
            living if living.is::<Livingroom>() => println!("Visiting the Living room..."),
            _ => {}
        }
    }
}
struct HouseElementDemolishVisitor;
impl HouseElementDemolishVisitor {
    pub fn new() -> Self {
        HouseElementDemolishVisitor
    }
}
impl HouseElementVisitor for HouseElementDemolishVisitor {
    fn visit(&self, element: &HouseElement) {
        match element.as_any() {
            house if house.is::<House>() => println!("Annihilating the house...!!!"),
            living if living.is::<Livingroom>() => println!("Bombing the Living room...!!!"),
            _ => {}
        }
    }
}

fn main() {
    let house = House::new();
    // simply print out the house elements
    house.accept(&HouseElementListVisitor::new());
    println!();
    // do something with the elements of a house
    house.accept(&HouseElementDemolishVisitor::new());
}
```


#### raiiæ¨¡å¼


é‡æ„åçš„ä»£ç :

```rs
/*
åˆ©ç”¨Rustçš„ownershipï¼ˆlinear/affine typeï¼‰æ¥è®¾è®¡æ¥å£

Refact

1. å»æ‰letterçš„Cloneï¼Œä½¿ç”¨æ‰€æœ‰æƒä¿è¯å…¶å”¯ä¸€æ€§ï¼›å¹¶ä¸”ä¿¡å°çš„wrapæ–¹æ³•åªæ¥å—è·å¾—æ‰€æœ‰æƒçš„ä¿¡å°ï¼Œè€Œéå¼•ç”¨
2. ä½¿ç”¨ç±»å‹ç³»ç»Ÿæ¥ä¿è¯ä¿¡å°çš„å”¯ä¸€æ€§
3. ä½¿ç”¨RAIIæœºåˆ¶æ¥ç®¡ç†æ”¶å°¾é€»è¾‘ï¼Œæ¯”å¦‚å®ç°Drop

å…¶ä»–ç¤ºä¾‹ï¼š

1. http response
2. steaming engine

*/

// #[derive(Clone)]
pub struct Letter {
    text: String,
}
pub struct EmptyEnvelope {}
pub struct ClosedEnvelope {
    letter: Letter,
}
pub struct PickupLorryHandle {
    done: bool,
}
impl Letter {
    pub fn new(text: String) -> Self {
        Letter {text: text}
    }
}
impl EmptyEnvelope {
    pub fn wrap(self, letter: Letter) -> ClosedEnvelope {
        ClosedEnvelope {letter: letter}
    }
}
pub fn buy_prestamped_envelope() -> EmptyEnvelope {
    EmptyEnvelope {}
}
impl PickupLorryHandle {
    pub fn pickup(&mut self, envelope: ClosedEnvelope) {
        /*give letter*/
    }
    pub fn done(self) {}
}
impl Drop for PickupLorryHandle {
    fn drop(&mut self) {
        println!("sent");
    }
}
pub fn order_pickup() -> PickupLorryHandle {
    PickupLorryHandle {done: false , /* other handles */}
}
fn main(){
    let letter = Letter::new(String::from("Dear RustFest"));
    let envelope = buy_prestamped_envelope();
    let closed_envelope = envelope.wrap(letter);
    let mut lorry = order_pickup();
    lorry.pickup(closed_envelope);
}

```

æœ‰é—®é¢˜çš„ä»£ç :

```rs
/*
åˆ©ç”¨Rustçš„ownershipï¼ˆlinear/affine typeï¼‰æ¥è®¾è®¡æ¥å£

å­˜åœ¨çš„é—®é¢˜ï¼š

1. Letteræœ‰å¯èƒ½å¤åˆ¶å¤šä»½åˆ°å¤šä¸ªä¿¡å°ï¼ˆenvelopeï¼‰é‡Œï¼Œä¸å®‰å…¨
2. ä¿¡å°é‡Œæœ‰å¯èƒ½æœ‰ä¿¡ï¼Œä¹Ÿæœ‰å¯èƒ½æ²¡æœ‰ä¿¡, å¯èƒ½å¯„å‡ºçš„æ˜¯ç©ºä¿¡å°ï¼›æˆ–è€…åŒä¸€ä¸ªä¿¡å°è£…å¤šæ¬¡ä¸åŒçš„ä¿¡ä»¶, é€ æˆä¿¡ä»¶çš„è¦†ç›–ï¼Œä¸å®‰å…¨
3. æœ‰æ²¡æœ‰æŠŠä¿¡äº¤ç»™é‚®è½¦ä¹Ÿæ˜¯æ— æ³•ä¿è¯ï¼Œä¸å®‰å…¨

*/
// ä¿¡çº¸
#[derive(Clone)]
pub struct Letter {
    text: String,
}
// ä¿¡å°
pub struct Envelope {
    letter: Option<Letter>,
}
// ä¿¡ä»¶å¤„ç†å™¨
pub struct PickupLorryHandle {
    done: bool,//æ˜¯å¦å¯„å‡º
}
impl Letter {
    pub fn new(text: String) -> Self {
        Letter {text: text}
    }
}
impl Envelope {
    // è£…ä¿¡çº¸è¿›å»
    pub fn wrap(&mut self, letter: &Letter){
        self.letter = Some(letter.clone());
    }
}
// åˆ›å»ºç©ºçš„ä¿¡å°
pub fn buy_prestamped_envelope() -> Envelope {
    Envelope {letter: None}
}
impl PickupLorryHandle {
    // è£…è½¦
    pub fn pickup(&mut self, envelope: &Envelope) {
        /*give letter*/
    }
    // å¯„å‡º
    pub fn done(&mut self) {
        self.done = true;
        println!("sent");
    }
}
// åˆ›å»ºå¤„ç†å™¨
pub fn order_pickup() -> PickupLorryHandle {
    PickupLorryHandle {done: false , /* other handles */}
}
fn main(){
    let letter = Letter::new(String::from("Dear RustFest"));
    let mut envelope = buy_prestamped_envelope();
    envelope.wrap(&letter);
    let mut lorry = order_pickup();
    lorry.pickup(&envelope);
    lorry.done();
}

pub fn builder_pattern(){
    unimplemented!();
}
```



## å­è¿›ç¨‹



```rust

/// å­è¿›ç¨‹
/// 
/// process::Output ç»“æ„ä½“è¡¨ç¤ºå·²ç»“æŸçš„å­è¿›ç¨‹ï¼ˆchild processï¼‰çš„è¾“å‡ºï¼Œè€Œ process::Command ç»“æ„ä½“æ˜¯ä¸€ä¸ªè¿›ç¨‹åˆ›å»ºè€…
/// 
/// std::Child ç»“æ„ä½“ä»£è¡¨äº†ä¸€ä¸ªæ­£åœ¨è¿è¡Œçš„å­è¿›ç¨‹ï¼Œå®ƒæš´éœ²äº† stdinï¼ˆæ ‡å‡† è¾“å…¥ï¼‰ï¼Œstdoutï¼ˆæ ‡å‡†è¾“å‡ºï¼‰ å’Œ stderrï¼ˆæ ‡å‡†é”™è¯¯ï¼‰ å¥æŸ„ï¼Œ
/// ä»è€Œå¯ä»¥é€šè¿‡ç®¡é“ä¸ æ‰€ä»£è¡¨çš„è¿›ç¨‹äº¤äº’
/// 
fn sub_process_command() {
    println!("-------------sub_process_command--------------");
    use std::process::Command;

    let output = Command::new("rustc")
        .arg("--version")
        .output().unwrap_or_else(|e| {
            panic!("failed to execute process: {}", e)
    });

    if output.status.success() {
        let s = String::from_utf8_lossy(&output.stdout);

        print!("rustc succeeded and stdout was:\n{}", s);
    } else {
        let s = String::from_utf8_lossy(&output.stderr);

        print!("rustc failed and stderr was:\n{}", s);
    }

    // ç®¡é“
    //
    //
    use std::error::Error;
    use std::io::prelude::*; // éšè—å¯¼å…¥ ä¸‡èƒ½å¯¼å…¥
    use std::process::{Stdio};

    static PANGRAM: &'static str = "the quick brown fox jumped over the lazy dog\n";
    // å¯åŠ¨ `wc` å‘½ä»¤
    let process = match Command::new("wc")
                                .stdin(Stdio::piped())
                                .stdout(Stdio::piped())
                                .spawn() {
        Err(why) => panic!("couldn't spawn wc: {}", why.description()),
        Ok(process) => process,
    };
    // å°†å­—ç¬¦ä¸²å†™å…¥ `wc` çš„ `stdin`ã€‚
    //
    // `stdin` æ‹¥æœ‰ `Option<ChildStdin>` ç±»å‹ï¼Œä¸è¿‡æˆ‘ä»¬å·²ç»çŸ¥é“è¿™ä¸ªå®ä¾‹ä¸ä¸ºç©ºå€¼ï¼Œ
    // å› è€Œå¯ä»¥ç›´æ¥ `unwrap å®ƒã€‚
    match process.stdin.unwrap().write_all(PANGRAM.as_bytes()) {
        Err(why) => panic!("couldn't write to wc stdin: {}", why.description()),
        Ok(_) => println!("sent pangram to wc"),
    }

    // å› ä¸º `stdin` åœ¨ä¸Šé¢è°ƒç”¨åå°±ä¸å†å­˜æ´»ï¼Œæ‰€ä»¥å®ƒè¢« `drop` äº†ï¼Œç®¡é“ä¹Ÿè¢«å…³é—­ã€‚
    //
    // è‹¥ç®¡é“ä¸å…³é—­,  `wc` å°±ä¸ä¼šå¼€å§‹å¤„ç†æˆ‘ä»¬åˆšåˆšå‘é€çš„è¾“å…¥ã€‚

    let mut s = String::new();
    match process.stdout.unwrap().read_to_string(&mut s) {
        Err(why) => panic!("couldn't read wc stdout: {}",
                           why.description()),
        Ok(_) => print!("wc responded with:\n{}", s),
    }

    // ç­‰å¾…
    //
    //å¦‚æœä½ æƒ³ç­‰å¾…ä¸€ä¸ª process::Child å®Œæˆï¼Œå°±å¿…é¡»è°ƒç”¨ Child::waitï¼Œè¿™ä¼šè¿”å› ä¸€ä¸ª process::ExitStatusã€‚
    //
    let mut child = Command::new("sleep").arg("5").spawn().unwrap();
    let _result = child.wait().unwrap(); // å¿…é¡»è°ƒç”¨ wait() ç­‰å¾…
    println!("reached end of main");

}
```




## åå°„

```rs
// æ ‡å‡†åº“æä¾›äº† std::any::Any æ¥æ”¯æŒè¿è¡Œæ—¶åå°„ã€‚
// å¯ä»¥æ¥æ”¶ä»»ä½•é™æ€ç”Ÿå‘½å‘¨æœŸç±»å‹ å³ 'static ç±»å‹, ä¸èƒ½æ¥æ”¶éé™æ€ç”Ÿå‘½å‘¨æœŸçš„ç±»å‹

   let v1 = 0xc0ffee_u32;
    let v2 = E::He;
    let v3 = S { x: 0xde, y: 0xad, z: 0xbeef };
    let v4 = "rust";
    let mut a: &Any; // trait object
    a = &v1;
    // åˆ¤æ–­æ˜¯å¦å±äºæŸç§ç±»å‹
    assert!(a.is::<u32>());
    // å…¨å±€å”¯ä¸€ç±»å‹æ ‡è¯†ç¬¦
    // ç­‰ä»· get_type_id()
    // TypeId { t: 12849923012446332737 }
    println!("{:?}", TypeId::of::<u32>());   
    a = &v2;
    assert!(a.is::<E>());
    // TypeId { t: 15527215023668350898 }
    println!("{:?}", TypeId::of::<E>());   
    a = &v3;
    assert!(a.is::<S>());
    // TypeId { t: 17868507538031848664 }
    println!("{:?}", TypeId::of::<S>());   
    a = &v4;
    assert!(a.is::<&str>());
    // TypeId { t: 1229646359891580772 }
    println!("{:?}", TypeId::of::<&str>());


    // å‘ä¸‹è½¬å‹ä¸ºå…·ä½“ç±»å‹
    use std::any::Any;
    #[derive(Debug)]
    enum E { H, He, Li}
    struct S { x: u8, y: u8, z: u16 }
    // å‚æ•°é™¤ä½¿ç”¨&Anyå¤–ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ Box<Any>
    fn print_any(a: &Any) {
        if let Some(v) = a.downcast_ref::<u32>() {
            println!("u32 {:x}", v);
        } else if let Some(v) = a.downcast_ref::<E>() {
            println!("enum E {:?}", v);
    } else if let Some(v) = a.downcast_ref::<S>() {
        println!("struct S {:x} {:x} {:x}", v.x, v.y, v.z);
    } else {
        println!("else!");
    }
    }
    fn main() {
        print_any(& 0xc0ffee_u32);                       
        print_any(& E::He);                             
        print_any(& S{ x: 0xde, y: 0xad, z: 0xbeef }); 
        print_any(& "rust");                           
        print_any(& "hoge");                           
    }



    // éé™æ€ç”Ÿå‘½å‘¨æœŸçš„ç±»å‹æœªå®ç°Any, æ— æ³•è¢« Any ç±»å‹æ¥æ”¶
    use std::any::Any;
    struct UnStatic<'a> { x: &'a i32 }
    fn main() {
        let a = 42;
        let v = UnStatic { x: &a };
        let mut any: &Any;
        any = &v;  // Compile Error!
    }
    //ok
    // å› ä¸º ä½¿ç”¨äº† é™æ€ç”Ÿå‘½å‘¨æœŸç±»å‹æ¥åˆ›å»º UnStatic, ä½¿å¾— UnStatic ä¹Ÿå˜ä¸º äº†é™æ€ç”Ÿå‘½å‘¨æœŸç±»å‹
    static ANSWER: i32 = 42;
    fn main() {
        let v = UnStatic { x: &ANSWER };
        let mut a: &Any;
        a = &v;
        assert!(a.is::<UnStatic>());
    }
```

## å®

### å®åŸºæœ¬ä»‹ç»

```rs


/// å¯è¿›è¡Œå…ƒç¼–ç¨‹ï¼ˆmetaprogrammingï¼‰
/// å®å¹¶ä¸äº§ ç”Ÿå‡½æ•°è°ƒç”¨ï¼Œè€Œæ˜¯å±•å¼€æˆæºç ï¼Œå¹¶å’Œç¨‹åºçš„å…¶ä½™éƒ¨åˆ†ä¸€èµ·è¢«ç¼–è¯‘
/// 
/// ä½¿ç”¨åœºæ™¯:
/// - é¿å…é‡å¤ä»£ç  (https://doc.rust-lang.org/stable/rust-by-example/macros/dry.html)
/// - é¢†åŸŸä¸“ç”¨è¯­è¨€ï¼ˆDSLï¼Œdomain-specific languageï¼‰ã€‚å®å…è®¸ä½ ä¸ºç‰¹å®šçš„ç›®çš„åˆ›é€ ç‰¹å®šçš„ è¯­æ³•
/// - å¯å˜æ¥å£ï¼ˆvariadic interfaceï¼‰ã€‚æœ‰æ—¶ä½ éœ€è¦èƒ½å¤Ÿæ¥å—ä¸å®šæ•°ç›®å‚æ•°çš„æ¥å£ï¼Œæ¯”å¦‚ println!
/// 
```

æŒ‰ç…§å®šä¹‰æ–¹å¼åˆ†ç±»:

- å£°æ˜å®, é€šè¿‡ macro_rules! å®šä¹‰
- è¿‡ç¨‹å®

æ ¹æ®ä½¿ç”¨çš„è¯­æ³•å½¢å¼åˆåˆ†ä¸ºä»¥ä¸‹ä¸¤ç§:

- è°ƒç”¨å®ï¼Œ å½¢å¦‚ println!ã€ assert_eq! ã€ thread_local!ç­‰å¯ä»¥å½“ä½œå‡½æ•°è°ƒç”¨çš„å®, 
- å±æ€§å®ï¼Œ ä¹Ÿå°±æ˜¯å½¢å¦‚ `#[derive(Debug))æˆ–#[cfg]`è¿™ç§å½¢å¼çš„è¯­æ³•

æŒ‰å®çš„æ¥æºï¼Œå¯ä»¥åˆ†ä¸ºä»¥ä¸‹ä¸¤ç±»

- å†…ç½®å®
- è‡ªå®šä¹‰å®

æœ‰å“ªäº›å†…ç½®å®?

```rust
todo!()

print!()
println!()
eprintln!(" = {:?}", );

vec!

panic!



#[derive(Debug)] è°ƒè¯•æ‰“å° struct

#[allow(dead_code)] ç”¨äºå±è”½å¯¹æœªä½¿ç”¨ä»£ç çš„è­¦å‘Š


// é€šè¿‡è¿™ä¸ªå±æ€§å±è”½è­¦å‘Šã€‚
#[allow(non_camel_case_types)]

#[cfg(test)]

```

### å£°æ˜å®

#### åˆ›å»ºå®


```rust
// å®å±•å¼€:
// å‡å¦‚æ˜¯å•ç‹¬çš„æ–‡ä»¶åˆ™æ‰§è¡Œæ­¤å‘½ä»¤å±•å¼€
//  rustc -Z unstable-options --pretty=expanded main.rs
// å‡å¦‚æ˜¯ cargo ç”Ÿæˆçš„äºŒè¿›å’ŒlåŒ…åˆ™æ‰§è¡Œæ­¤å‘½ä»¤
// cargo rustc -- -Z unstable-options --pretty=expanded


// macro rules!æœ¬èº« ä¹Ÿ æ˜¯ä¸€ç§å£°æ˜å® ï¼Œ åªä¸è¿‡å®ƒç”±ç¼–è¯‘å™¨ å†…éƒ¨æ‰€å®šä¹‰
// å®çš„åŸç†å’Œæ­£åˆ™è¡¨è¾¾å¼åŒ¹é…çš„åŸç†ç±»ä¼¼ 
// 
// è¯­æ³•:
// macro_rule! $macro_name { 
//      // æ‰©å±•éƒ¨åˆ†, å¤§å°æ‹¬å·å‡å¯
//      ($arg1:expr, $arg2:expr) => {code...}; // åˆ†æ”¯ä»¥åˆ†å·ç»“å°¾
//      () => ()                                // æœ€åä¸€ä¸ªåˆ†æ”¯å¯çœç•¥åˆ†å·
// }
// æœªæ¥ä¼šæ”¯æŒ macro å…³é”®å­—
// #![feature(decl_macro)]
// macro unless($arg:expr, $branch:expr) {
//     ( if !$arg { $branch }); 
// } 
// 
// åŒ¹é…è¡¨è¾¾å¼ä¸­ç±»å‹æ”¯æŒ: (å„ä¸ªç±»å‹èƒ½å¤ŸåŒ¹é…çš„èŒƒå›´æœ‰é‡å è¦†ç›–)
// â€¢ itemï¼Œ ä»£è¡¨è¯­è¨€é¡¹ï¼Œå°±æ˜¯ç»„æˆä¸€ä¸ª RuståŒ…çš„åŸºæœ¬å•ä½ï¼Œæ¯”å¦‚æ¨¡å—ã€å£°æ˜ã€å‡½æ•°å®šä¹‰ ã€ ç±»å‹å®šä¹‰ã€ç»“æ„ä½“å®šä¹‰ã€ impl å®ç°ç­‰ã€‚
// â€¢ blockï¼Œ ä»£è¡¨ä»£ç å—ï¼Œç”±èŠ±æ‹¬å·é™å®šçš„ä»£ç ã€‚
// â€¢ stmtï¼Œä»£è¡¨è¯­å¥ ï¼Œ ä¸€èˆ¬æ˜¯ æŒ‡ä»¥åˆ†å·ç»“å°¾çš„ä»£ç  ã€‚
// â€¢ exprï¼ŒæŒ‡ä»£è¡¨è¾¾å¼ï¼Œä¼šç”Ÿæˆå…·ä½“çš„å€¼ ã€‚
// â€¢ patï¼ŒæŒ‡ä»£æ¨¡å¼ã€‚
// â€¢ tyï¼Œ è¡¨ç¤ºç±»å‹ã€‚
// â€¢ identï¼Œ æŒ‡ä»£æ ‡è¯†ç¬¦ã€‚å¦‚ å˜é‡åæˆ–å‡½æ•°å
// â€¢ pathï¼ŒæŒ‡ä»£è·¯å¾„ï¼Œ æ¯”å¦‚fooã€ std::iterç­‰ã€‚
// â€¢ metaï¼Œ å…ƒä¿¡æ¯ï¼Œè¡¨ç¤ºåŒ…å«åœ¨# [...]æˆ–#![...]å±æ€§ å†…çš„ä¿¡ æ¯ã€‚
// â€¢ tt , TokenTree çš„ ç¼©å†™ï¼ŒæŒ‡ä»£è¯æ¡æ ‘ã€‚æ¯” expr èƒ½åŒ¹é…çš„èŒƒå›´è¦å¹¿
// â€¢ visï¼ŒæŒ‡ä»£å¯è§æ€§ï¼Œæ¯”å¦‚ pubã€‚
// â€¢ lifetimeï¼Œ æŒ‡ä»£ç”Ÿå‘½å‘¨æœŸå‚æ•° ã€‚

// 
// è¿™æ˜¯ä¸€ä¸ªç®€å•çš„å®ï¼Œåä¸º `say_hello`ã€‚
macro_rules! say_hello {
    // `()` è¡¨ç¤ºæ­¤å®ä¸æ¥å—ä»»ä½•å‚æ•°ã€‚
    () => (// è¿™é‡Œä½¿ç”¨ å¤§æ‹¬å·äº¦å¯
        // æ­¤å®å°†ä¼šå±•å¼€æˆè¿™ä¸ªä»£ç å—é‡Œé¢çš„å†…å®¹ã€‚
        println!("Hello cacro!");
    )
}
// è¿™ä¸ªè°ƒç”¨å°†ä¼šå±•å¼€æˆ `println("xxx");`!
say_hello!();// è¿™é‡Œä½¿ç”¨å¤§æ‹¬å·äº¦å¯

// å¸¦å‚æ•°
macro_rules! hello {
    ($name:expr) => {// ä½¿ç”¨ å¤§å°æ‹¬å·å‡å¯
        println!("Hello, {}", $name);
    };
}
fn main() {
    hello!("xy")// ä½¿ç”¨å¤§å°æ‹¬å·å‡å¯
}

// å¸¦ä»£ç æ®µ
macro_rules! unless {
    ($arg: expr, $logic:expr) => (
        if !$arg {
            $logic
        }
    );
}
fn main() {
    let (a, b) = (1, 2);
    unless!(a > b, {// å¤§æ‹¬å·å¯çœç•¥
        println!("a < b");
    });
}


// å‚æ•°ç±»å‹ä¸º æ ‡è¯†ç¬¦
macro_rules! create_function {
    // `ident` æŒ‡ç¤ºç¬¦, æ ‡è¯† func_name æ˜¯å˜é‡åæˆ–å‡½æ•°å
    ($func_name:ident) => (
        fn $func_name() {
            // `stringify!` å®æŠŠ `ident` è½¬æ¢æˆå­—ç¬¦ä¸²ã€‚
            println!("You called {:?}()", stringify!($func_name))
        }
    )
}
// å€ŸåŠ©ä¸Šè¿°å®æ¥åˆ›å»ºåä¸º `foo` å’Œ `bar` çš„å‡½æ•°ã€‚
create_function!(foo);
create_function!(bar);

macro_rules! print_result {
    // `expr` æŒ‡ç¤ºç¬¦è¡¨ç¤ºè¾“å…¥å‚æ•°ä¸ºä¸€ä¸ªè¡¨è¾¾å¼ã€‚
    ($expression:expr) => (
        println!("{:?} = {:?}",
                    stringify!($expression),// `stringify!` æŠŠè¡¨è¾¾å¼*åŸæ ·*è½¬æ¢æˆä¸€ä¸ªå­—ç¬¦ä¸²ã€‚
                    $expression)// æ‰§è¡Œè¡¨è¾¾å¼
    )
}
foo();
bar();
print_result!(1u32 + 1);
//ä»£ç å—ä¹Ÿæ˜¯è¡¨è¾¾å¼ï¼
print_result!({
    let x = 1u32;
    x * x + 2 * x - 1
});


```

#### é‡å¤å¾ªç¯åŒ¹é… 

```rs
// ä¸å®šå‚æ•° å¯å˜æ¥å£
//å®åœ¨å‚æ•°åˆ—è¡¨ä¸­å¯ä»¥ä½¿ç”¨ + æ¥è¡¨ç¤ºä¸€ä¸ªå‚æ•°å¯èƒ½å‡ºç°ä¸€æ¬¡æˆ–å¤šæ¬¡ï¼Œ
// ä½¿ç”¨ * æ¥è¡¨ç¤ºè¯¥ å‚æ•°å¯èƒ½å‡ºç°é›¶æ¬¡æˆ–å¤šæ¬¡
//
macro_rules! map {
    ($($key:expr => $value:expr),*) => {
        // åŒ…è£¹ä¸€å±‚å¤§æ‹¬å·, è¡¨ç¤ºè¿”å›ä¸€ä¸ªå€¼
        {
            // ä½¿ç”¨ç»å¯¹è·¯å¾„, é¿å…å†²çª
            // è‹¥ä½¿ç”¨åˆ°è‡ªå®šä¹‰å‡½æ•°, éœ€è¦åœ¨è·¯å¾„ä¸­ä½¿ç”¨ $crate , é¿å…å¯¼å‡ºæ—¶å‡º bug
            let mut map = std::collections::HashMap::new();
            // å¾ªç¯è¯»å–
            $(
                map.insert($key, $value);
            )*
            map
        }
    };
}
fn main() {
    // è°ƒç”¨æ—¶, å¤§å°æ‹¬å·éƒ½å¯
    let map = map!("a" => 1, "b" => 2, "c" => 3);
    println!("map: {:?}", map);
    let mat1 = map!{1 => "a", 2 => "b", 3 => "c"};
    println!("mat1: {:?}", mat1);
    //ä½†è¿˜æ˜¯å­˜åœ¨é—®é¢˜, æœ«å°¾å…ƒç´ ä¸èƒ½æœ‰é€—å· , å¯ä»¥é€šè¿‡æ·»åŠ å¤šä¸ªåŒ¹é…è§„åˆ™è§£å†³
    // error
    let map2 = map!("a" => 1, "b" => 2,);
}


// è§£å†³:
macro_rules! map {
    ($($key:expr => $value:expr),*) => {
        {
            let mut map = std::collections::HashMap::new();
            $(
                map.insert($key, $value);
            )*
            map
        }
    };
    // æ–°å¢ä¸€æ¡åŒ¹é…è§„åˆ™
    ($($key:expr => $value:expr,)*) => {
        map!($($key => $value),*) // é€’å½’è°ƒç”¨å‰é¢çš„ åŒ¹é…
    };

}

// æˆ–è€…æœ€ç®€å•çš„æ–¹æ³•, å°†åŸæ¥çš„åŒ¹é…ç•¥åŠ ä¿®æ”¹:
// æ·»åŠ çš„ $(,)* è¡¨ç¤ºåŒ¹é…ä»»æ„æ¬¡æ•°çš„é€—å·
($($key:expr => $value:expr),* $(,)*) => {}
// or
($($key:expr => $value:expr,)* $(,)*) => {}


fn main() {
    let map = map!(
        1 => "a",
        2 => "b", // å¯ä»¥ä½¿ç”¨ é€—å·ç»“å°¾äº†
    );
    println!("{:?}", map);
}


```

#### å®é™…æ¡ˆä¾‹



```rs
//  åˆ›å»º map å®
macro_rules! map {
    // @unit æ˜¯çº¦å®šä¿—æˆçš„åœ¨å®å†…éƒ¨å®šä¹‰å®çš„å‘½åè§„åˆ™
    // å¿…é¡»å®šä¹‰åœ¨å¼€å¤´, å¦åˆ™å°±æŒ‰ç…§æ™®é€šåŒ¹é…åˆ†æ”¯å¤„ç†äº†
    (@unit $($x:tt)*) => {()};    // ç»Ÿè®¡ item ä¸ªæ•°æ—¶ä½¿ç”¨çš„å•ä½, è¿™é‡Œä½¿ç”¨ ç©ºå…ƒç»„, ä¸å ç©ºé—´
    (@count $($key:expr),* ) => {
        (<[()]>::len(&[$(map!(@unit $key)),*]));
    };

    ($($key:expr => $value:expr),* $(,)*) => (
        {
            let _cap = map!(@count $($key),*);
            let mut _map = std::collections::HashMap::with_capacity(_cap);
           $(
               _map.insert($key, $value);
            )*
           _map
       }
    )
}
fn main() {
    let map = map!(
        1 => "a",
        2 => "b",
    );
    println!("{:?}", map);
}







//  å®ä¾‹:
    // `min!` å°†æ±‚å‡ºä»»æ„æ•°é‡çš„å‚æ•°çš„æœ€å°å€¼ã€‚
    macro_rules! find_min {
        // åŸºæœ¬æƒ…å½¢ï¼š
        ($x:expr) => ($x);
        // `$x` åé¢è·Ÿç€è‡³å°‘ä¸€ä¸ª `$y,`
        ($x:expr, $($y:expr),+) => (
            // å¯¹ `$x` åé¢çš„ `$y` ä»¬è°ƒç”¨ `find_min!` 
            std::cmp::min($x, find_min!($($y),+))
        )
    }
    println!("{}", find_min!(1u32));
    println!("{}", find_min!(1u32 + 2 , 2u32));
    println!("{}", find_min!(5u32, 2u32 * 3, 4u32));






    // åˆ›é€  dsl
    // è¿™é‡Œåˆ›é€ å…³é”®å­— eval
    //
    macro_rules! calculate {
        (eval $e:expr) => {
            let val: usize = $e; // å¼ºåˆ¶ç±»å‹ä¸ºæ•´å‹
            println!("{} = {}", stringify!{$e}, val);
        };
    }
    calculate! {
        eval 1 + 2 
    }
    calculate! {
        eval (1 + 2) * (3 / 4)
    }

    // å‡çº§ç‰ˆ dsl
    // å¯æ¥å—å¤šä¸ªå‚æ•°
    //
    macro_rules! calculate {
        // å•ä¸ª `eval` çš„æ¨¡å¼
        (eval $e:expr) => {{
            {
                let val: usize = $e; // Force types to be integers
                println!("{} = {}", stringify!{$e}, val);
            }
        }};
    
        // é€’å½’åœ°æ‹†è§£å¤šé‡çš„ `eval`
        (eval $e:expr, $(eval $es:expr),+) => {{
            calculate! { eval $e }
            calculate! { $(eval $es),+ }
        }};
    }
    calculate! { 
        eval 1 + 2,
        eval 3 + 4,
        eval (2 * 3) + 1
    }





```

### å®è°ƒè¯•

```rs
// å¿…é¡» nightly rust æ‰è¡Œ
// #![feature(trace_macros) æ ‡æ³¨å®å®šä¹‰, ç„¶ååœ¨main å¼€å¤´ trace_macros!(true);

#![feature(trace_macros)]
macro_rules! hashmap {
    (@unit $($x:tt)*) => (());
    (@count $($rest:expr),*) => 
        (<[()]>::len(&[$(hashmap!(@unit $rest)),*]));
    ($($key:expr => $value:expr),* $(,)*) => {
        {
            let _cap = hashmap!(@count $($key),*);
            let mut _map = 
                ::std::collections::HashMap::with_capacity(_cap);
           $(
               _map.insert($key, $value);
           )*
           _map
       }
   };
}
fn main(){
   trace_macros!(true);
   let map = hashmap!{
       "a" => 1,
       "b" => 2,
       "c" => 3, 
   };
   assert_eq!(map["a"], 1);
}


```



### è¿‡ç¨‹å®

#### è¿‡ç¨‹å®ä»‹ç»


```rust

// è¿‡ç¨‹å®: æ¥å— rust ä»£ç ä½œä¸ºè¾“å…¥,  åœ¨æ­¤åŸºç¡€ä¸Šä¿®æ”¹å, è¾“å‡º;
// å£°æ˜å®: è¾“å…¥ä»£ç , é€šè¿‡ match åŒ¹é…, ä»¥å¦å¤–çš„ä»£ç æ›¿æ¢è¾“å‡º
// 
// å¯ä»¥ç”¨æ¥:
// - è‡ªå®šä¹‰æ´¾ç”Ÿå±æ€§, ç±»ä¼¼äº #[derive(Debug)]è¿™æ ·çš„ derive å±æ€§ï¼Œå¯ä»¥è‡ªåŠ¨ä¸º ç»“æ„ä½“æˆ–æšä¸¾ç±»å‹è¿›è¡Œè¯­æ³•æ‰©å±•, å¢åŠ æ–°çš„æ–¹æ³•å®ç°
// - è‡ªå®šä¹‰å±æ€§ï¼Œ å¯ä»¥è‡ªå®šä¹‰ç±»ä¼¼äº#[cfg()]è¿™ç§å±æ€§
// - ç±»ä¼¼å‡½æ•°è°ƒç”¨çš„å®, å’Œ macro_rules!å®šä¹‰çš„å®ç±»ä¼¼ï¼Œä»¥ Bang ç¬¦å·(å°±æ˜¯å¹å· "!" )ç»“å°¾çš„å® ã€‚å¯ä»¥åƒå‡½æ•°ä¸€æ ·è¢«è°ƒç”¨ , custom!(...)ã€‚


```

è¿‡ç¨‹å®ï¼Œå¿…é¡»å†™åœ¨å•ç‹¬çš„libç±»å‹çš„crateä¸­, `cargo new --lib proc_macro_me`, éœ€è¦ ä¸ºå½“å‰é¡¹ç›®å£°æ˜ä½¿ç”¨ proc_macro,  proc_macro crateä¸º rust è‡ªå¸¦, é»˜è®¤ä¸å¼•å…¥, éœ€è¦æ˜¾å¼å£°æ˜ä¸º true

```t

[lib]
# è®¾ç½®ä¸º proc_macro ç±»å‹
proc_macro = true


```

#### è‡ªå®šä¹‰å±æ€§å®

Rust è‡ªèº«æœ‰å¾ˆå¤šå†…ç½®çš„å±æ€§ ï¼Œ æ¯”å¦‚æ¡ä»¶ç¼–è¯‘å±æ€§ `#[cfgOJå’Œæµ‹è¯•å±æ€§#[test]`

è¿‡ç¨‹å®å®ç°è‡ªå®šä¹‰å±æ€§çš„åŠŸèƒ½è¿˜æœªç¨³å®šã€‚åœ¨ è¯¥ç‰ˆæœ¬ç¨³å®šä¹‹å‰ï¼Œå¿…é¡»åœ¨ Nightly ç‰ˆæœ¬ä¸‹ä½¿ç”¨ `#![feature(custom_attribute)]`ç‰¹æ€§, å½“å‰ç‰ˆæœ¬ä¸éœ€è¦äº†

å®šä¹‰å®:

```rs
use proc_macro::TokenStream;

#[proc_macro_attribute]
pub fn attr_with_args(args: TokenStream, _input: TokenStream) -> TokenStream {
    // args æ˜¯ #[attr_with_args("Hello attr macro.")] ä¸­çš„å­—ç¬¦ä¸²
    // _input æ˜¯è¾“å…¥, å³ fn boo() {}, è¿™é‡Œç›´æ¥å¿½ç•¥äº†
    format!("fn foo() -> &'static str {{{}}}", args.to_string()).parse().unwrap()
}
```

ä½¿ç”¨:

```rs
#[macro_use] extern crate proc_macro_me;

#[test]
fn tt() {
    #[attr_with_args("Hello attr macro.")]
    fn foo() {}
    println!("{:?}", foo());//"Hello attr macro."
}
```



#### å‡½æ•°è°ƒç”¨å®


å®šä¹‰å‡½æ•°è°ƒç”¨å®:

```rs
use proc_macro::TokenStream;

#[proc_macro]
pub fn make_fn_answer(_item: TokenStream) -> TokenStream {
    "fn answer() -> u32 { 11 }".parse().unwrap()
}
```

ä½¿ç”¨:

```rs
#[macro_use] extern crate proc_macro_me;

#[test]
fn tt() {
    make_fn_answer!();
    println!("{:?}", answer());// 11
}
```

#### derive å®



å®šä¹‰å®

```rs
// è‡ªå®šä¹‰ derive å®
//
// extern crate proc_macro;
// use proc_macro::TokenStream;
//or
// use self::proc_macro::TokenStream;
// or
use proc_macro::TokenStream;


// AnswerFn ç›¸å½“äºæ ‡è¯†ç¬¦, ä½¿ç”¨æ—¶, è¿™æ ·ä½¿ç”¨ #[derive(Hello, AnswerFn)]
#[proc_macro_derive(AnswerFn)]
pub fn derive_answer_fn(_input: TokenStream) -> TokenStream {
    "fn answer() -> u32 { 11 }".parse().unwrap()
}

#[proc_macro_derive(Hello)]//è¡¨ç¤ºå…¶ä¸‹æ–¹çš„å‡½æ•°ä¸“é—¨å¤„ç†è‡ªå®šä¹‰æ´¾ç”Ÿå±æ€§
pub fn derive_a_hello(input: TokenStream) -> TokenStream {
    let input = input.to_string();
    // ä¿è¯ ä»£ç ä¸­å­˜åœ¨ struct A
    assert!(input.contains("struct A"));
    //æ–¹æ³•æœ€ç»ˆä¼šè¿”å›ä¸€ä¸ª Result<TokenSteam, Errã€‰ç±»å‹ï¼Œ 
    // æ‰€ä»¥è¿˜éœ€è¦å†æ¬¡ç”¨ unwrap æ–¹æ³•æ‰èƒ½è¿”å›ã€‚
    r#"
        impl A {
            fn a(&self) -> String {
                format!("hello from a impl")
            }
        }
    "#.parse().unwrap() 
}


```

ä½¿ç”¨:

```rs
// #[macro_use] extern crate proc_macro_me;
//or
use proc_macro_me::{AnswerFn, Hello};

#[derive(Hello, AnswerFn)]
pub struct A;

#[test]
fn test_derive_a() {
    let aa = A;
    assert_eq!("hello from a impl".to_string(), aa.a());
    println!("{}", answer());
}
```


### ä½¿ç”¨ç¬¬ä¸‰æ–¹åŒ…

å®˜æ–¹çš„è¿‡ç¨‹å®åº“ä¸ºproc_macro, è¿˜æ²¡ç¨³å®šï¼Œä¸æ¨èç›´æ¥ä½¿ç”¨

æ¨èæ›´å‹å¥½çš„synã€quoteå’Œproc_macro2è¿™3ä¸ªåº“, å…¶ä¸­, syn å®Œæ•´å®ç°äº† Rust æºç  çš„è¯­ æ³•æ ‘ç»“æ„ã€‚è€Œ quote å¯ä»¥å°† syn çš„è¯­æ³•æ ‘ç»“æ„è½¬ä¸º proc macro::TokenStrem ç±»å‹



### ç¼–è¯‘å™¨æ’ä»¶

Rust ä¸­æœ€å¼ºå¤§çš„å…ƒç¼–ç¨‹å·¥å…·éç¼–è¯‘å™¨æ’ä»¶è«å±, ä½†æ˜¯ç¼–è¯‘å™¨æ’ä»¶ç›®å‰è¿˜ä¸ç¨³å®šã€‚åœ¨ Nightly ç‰ˆæœ¬çš„ Rust ä¹‹ä¸‹ï¼Œé…åˆ   `# ![feature(plugin_registrar)]`ç‰¹æ€§æ‰è¡Œ


# unsafe å±è”½å†…å­˜å®‰å…¨æ£€æŸ¥


## unsafe åŸºæœ¬åœºæ™¯

```rs
// ä½¿ç”¨ unsafe å®šä¹‰ ä¸å®‰å…¨çš„ å‡½æ•°/æ–¹æ³•/trait, ä»¥åŠä¸º trait å®ç°æ–¹æ³•
// 
// å¦‚: String::from_utf8_unchecked å°±æ˜¯ä¸å®‰å…¨çš„, å¯¹äºè¾“å…¥å‚æ•°, æ²¡æœ‰æ£€æŸ¥æ˜¯å¦æ˜¯æœ‰æ•ˆçš„ utf-8å­—èŠ‚åºåˆ—; String::from_utf8_lossy åˆ™æ˜¯å®‰å…¨çš„
// å¦‚: Send trait, Sync trait éƒ½æ˜¯ unsafe çš„, ä½¿ ç”¨ unsafeå¯¹ Sendå’Œ Syncè¿›è¡Œæ ‡è®°ï¼Œå°±æ„å‘³ç€å¼€å‘è€…æ‰‹åŠ¨å®ç°å®ƒä¼šæœ‰å®‰å…¨é£é™©, æ‰€ä»¥ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨å¯¹æˆ‘ä»¬è‡ªå®šä¹‰çš„ç±»å‹å®ç°è¿™ä¸¤ä¸ªæ¥å£
// å¦‚: Searcher trait, æ²¡æœ‰æ£€æŸ¥æˆªå–çš„å­—ç¬¦ä½ç½®åœ¨å­—ç¬¦ä¸²ä¸­æ˜¯å¦æ˜¯æœ‰æ•ˆå­—ç¬¦è¾¹ç•Œ, éœ€è¦å¼€å‘è€…è‡ªå·±ä¿è¯


// åœ¨ unsafe å—ä¸­æ‰§è¡Œä¸å®‰å…¨çš„æ“ä½œ (å¯¹äºä¸å®‰å…¨çš„æ“ä½œ, ä¼šå±è”½å†…å­˜å®‰å…¨æ£€æŸ¥, ä½†æ˜¯å¯¹äºå®‰å…¨çš„æ“ä½œ, ä¾ç„¶æœ‰å®‰å…¨æ£€æŸ¥)
// 
/// - è§£å¼•ç”¨è£¸æŒ‡é’ˆ (ä½†æ˜¯åˆ›å»ºè£¸æŒ‡é’ˆæ— éœ€åœ¨ unsafe ä¸­)
/// - è°ƒç”¨ unsafe çš„å‡½æ•°/æ–¹æ³•
/// - è®¿é—®ä¿®æ”¹å¯å˜é™æ€å˜é‡
/// - å®ç° unsafe çš„ trait
// - è¯»å†™ union è”åˆä½“ä¸­çš„  å­—æ®µ


```


```rust
// è®¿é—®ä¿®æ”¹å¯å˜é™æ€å˜é‡ (ä¸€èˆ¬ç”¨ä¸åˆ°, åªæ˜¯ç”¨äºå’Œ c äº¤äº’)
// 
// 
// é™æ€å˜é‡æ˜¯å…¨å±€å¯è®¿ é—® çš„ ã€‚å¯¹äºä¸å¯å˜é™æ€å˜é‡æ¥è¯´ï¼Œè®¿é—®å®ƒä¸å­˜åœ¨ä»»ä½•å®‰å…¨ é—®é¢˜
// å¦‚æœå¤šä¸ªçº¿ç¨‹åŒæ—¶è®¿ é—®å¯å˜é™æ€å˜é‡, ä¼šæœ‰å®‰å…¨é—®é¢˜, æ‰€ä»¥è¦åœ¨ unsafe ä¸­ä¿®æ”¹
static mut COUNTER: u32 = 0;
fn main() {
    let inc = 3;
    unsafe {
        COUNTER += inc;
        println!("COUNTER: {}", COUNTER);
    }
}





// è®¿é—® union è”åˆä½“ (åªè¦è¿˜æ˜¯ä¸ºäº†æ–¹ä¾¿ å’Œ c äº¤äº’)
// 
// 
// 





// è§£å¼•ç”¨è£¸/åŸç”ŸæŒ‡é’ˆ (raw pointer), è£¸æŒ‡é’ˆå¸¸ç”¨äº å’Œ c äº¤äº’
//
// åˆ†ä¸º:
// ä¸å¯å˜è£¸æŒ‡é’ˆ   *const T
// å¯å˜è£¸æŒ‡é’ˆ     *mut T
//
// - å…è®¸å¿½ç•¥å€Ÿç”¨è§„åˆ™: æŸä¸ªå¯¹è±¡å¯ä»¥åŒæ—¶æ‹¥æœ‰å¯å˜ä¸å¯å˜è£¸æŒ‡é’ˆ, æˆ–è€…å¤šä¸ªåŒæ—¶æŒ‡å‘ç›¸åŒä½ç½®çš„å¯å˜è£¸æŒ‡é’ˆ
// - ä¸ä¿è¯æŒ‡å‘çš„å†…å­˜æ˜¯æœ‰æ•ˆçš„, å…è®¸æŒ‡å‘ç©ºåœ°å€
// - ä¸ä¿è¯çº¿ç¨‹å®‰å…¨
// - æ²¡æœ‰è‡ªåŠ¨æ¸…ç†çš„åŠŸèƒ½, éœ€è¦æ‰‹åŠ¨æ¸…ç†å†…å­˜
// 
let mut a = 1;
let rp1 = & a as *const i32; // åˆ›å»ºæ—¶æ— éœ€åœ¨ unsafe
// åŒæ—¶å‡ºç°äº† å¯å˜, ä¸å¯å˜å€Ÿç”¨, ç¼–è¯‘å™¨ä¸æŠ¥é”™
let rp2 = &mut a as *mut i32;
unsafe {
    println!("rp1 = {}", *rp1);
    println!("rp2 = {}", *rp2);
}


// è®¿é—® unsafe æ–¹æ³•
// 
//
unsafe fn danger() {
    println!("dangerous");
}
unsafe {
    danger();
}




// 



```


## äº¤å‰ç¼–è¯‘

```sh
# å¦‚æœæ˜¯é’ˆå¯¹ ARM åµŒå…¥å¼å¼€å‘å¹³å°, ä¸èƒ½ä½¿ ç”¨stdæ ‡å‡†åº“ (#![no_std))
rustc --target=arm-unknown-linux-gnueabihf hello .rs

cargo build --target=arm - unknown - linux - gnueabihf

# ç¬¬ä¸‰æ–¹äº¤å‰ç¼–è¯‘å·¥å…· xargo
```

é€šè¿‡é…ç½®æ–‡ä»¶æŒ‡å®šé“¾æ¥å™¨: vim ~/ . cargo/config

```t
[target . arm- unknown-linux-gnueabihf]
linker = â€arm-linux-gnueabihf-gcc-4.8â€
```

## ffi å¤–éƒ¨å‡½æ•°æ¥å£


### ffi åŸºæœ¬ä»‹ç»


Javaè¯­è¨€åˆ™å°†FFIç§°ä¸ºJNI CJavaNativeInterface)


https://www.cnblogs.com/Jackeyzhe/p/12623689.html

https://rustcc.cn/article?id=3b8241d0-c4ca-4f49-8e07-0a5142b00f59



```rust
///å¤–éƒ¨è¯­è¨€å‡½æ•°æ¥å£
/// 
/// Rust æä¾›äº†åˆ° C è¯­è¨€åº“çš„å¤–éƒ¨è¯­è¨€å‡½æ•°æ¥å£ï¼ˆForeign Function Interfaceï¼ŒFFIï¼‰ã€‚
/// å¤– éƒ¨è¯­è¨€å‡½æ•°å¿…é¡»åœ¨ä¸€ä¸ª extern ä»£ç å—ä¸­å£°æ˜ï¼Œä¸”è¯¥ä»£ç å—è¦å¸¦æœ‰ä¸€ä¸ªåŒ…å«åº“åç§° çš„ #[link] å±æ€§
/// 
// æ”¯æŒå››ç§åº“:
// - dylib , ruståŠ¨æ€åº“
// - rlib, rust é™æ€åº“
// - cdylib, å…¶ä»–è¯­è¨€å†™çš„åŠ¨æ€åº“
// - staticlib , å…¶ä»–è¯­è¨€é™æ€åº“
// 
// 

// å¦‚ä½•ç¼–è¯‘ä¸ºåº“
// 
// flag å‚æ•°
// (crate type å¯ä»¥æŒ‡å®šå¤šä¸ª, #[crate_type = "bin"] è¿™ç§ä½¿ç”¨å½¢å¼éœ€è¦æ ‡æ³¨åœ¨ lib.rs or main.rs å¼€å¤´)
// 
// --crate-type=bin or #[crate_type = "bin"] è¡¨ç¤ºå°†ç”Ÿæˆ-ä¸ªå¯æ‰§è¡Œæ–‡ä»¶ ã€‚è¦æ±‚ç¨‹åºä¸­å¿… é¡»åŒ…å«ä¸€ä¸ª main å‡½æ•°
// --crate-type=lib or #[crate_type = "lib"] è¡¨ç¤ºå°†ç”Ÿæˆä¸€ä¸ª Ruståº“ã€‚ å…·ä½“ç”Ÿæˆä»€ä¹ˆç±»å‹åº“ï¼Œç”±ç¼–è¯‘å™¨è‡ªè¡Œå†³å®šã€‚é»˜è®¤ä¼šäº§ç”Ÿ rlibé™æ€ åº“
//--crate-type=rlib or #[crate_type = "rlib"] é™æ€ Ruståº“ï¼Œç”±Rustç¼–è¯‘å™¨æ¥ä½¿ ç”¨ã€‚
//--crate-type=dylib or #[crate_type = "dylib"] åŠ¨æ€ Ruståº“,ç”± Rust ç¼–è¯‘å™¨æ¥ä½¿ç”¨(åœ¨ Linuxä¸Šä¼šåˆ›å»º*.soæ–‡ä»¶ï¼Œåœ¨ MacOSXä¸Šä¼šåˆ›å»º.dylibæ–‡ä»¶ï¼Œ åœ¨ Windowsä¸Šä¼šåˆ›å»º.dllæ–‡ä»¶)
// --crate-type=staticlib or #[crate_type = "staticlib"] ç”Ÿæˆé™æ€ç³»ç»Ÿåº“ ã€‚ Rust ç¼–è¯‘å™¨ æ°¸è¿œä¸ä¼šé“¾æ¥è¯¥ç±»å‹åº“ï¼Œä¸»è¦ç”¨äºå’Œ C è¯­è¨€è¿›è¡Œé“¾æ¥ ï¼Œè¾¾æˆå’Œå…¶ä»–è¯­ è¨€äº¤äº’ çš„ç›®çš„ ã€‚ é™æ€ç³»ç»Ÿåº“åœ¨ Linuxå’Œ MacOSXä¸Šä¼šåˆ›å»º.aæ–‡ä»¶ï¼Œåœ¨ Windowsä¸Šä¼šåˆ›å»º*.libæ–‡ä»¶
//--crate-type=cdylib or #[crate_type = "cdylib"] ç”ŸæˆåŠ¨æ€ç³»ç»Ÿåº“ã€‚åŒæ · ç”¨ äºç”Ÿæˆ C æ¥å£ï¼Œ å’Œå…¶ä»–è¯­è¨€äº¤äº’ã€‚è¯¥ç±»å‹åœ¨ Linuxä¸Šä¼šåˆ›å»º.soæ–‡ä»¶ ï¼Œåœ¨ MacOSXä¸Šä¼šåˆ›å»º.dylib , åœ¨ Windowsä¸Šä¼šåˆ›å»º.dllæ–‡ä»¶


```

### åœ¨ rust ä¸­è°ƒç”¨ C å‡½æ•°


```rs
// åœ¨ Rust ä¸­è°ƒç”¨ C å‡½æ•°
// 
// è¿™é‡ŒæŒ‡å®šä½¿ç”¨ C-ABIï¼Œç­‰ä»·äº â€œextern fn foo () â€è¿™æ ·çš„å‡½æ•°å£°æ˜; æ­¤å¤–è¿˜æœ‰ extern "Rustâ€ï¼Œ è¿™æ˜¯é»˜è®¤çš„ ABIï¼Œä»»ä½•æ™®é€š çš„å‡½æ•°éƒ½å°†ä½¿ ç”¨ è¯¥ ABI
extern "C" {//ä¹Ÿå¯ä»¥ ç›´æ¥ä½¿ç”¨ extern å—ï¼Œè€Œçœç•¥æ‰ABIå­—ç¬¦ä¸²Â°Câ€ ã€‚å› ä¸ºé»˜è®¤çš„externå—å°±æ˜¯æŒ‰C-ABIå¤„ç†çš„
    // å®šä¹‰äº† C æ ‡å‡†åº“å†…ç½®çš„ isalnum å‡½æ•°ç­¾å, å¯ä»¥ç›´æ¥ä½¿ç”¨äº†
    fn isalnum(input: i32) -> i32;
}
fn main() {
    unsafe {
        println!("Is 3 a number ?  the answer is : {}", isalnum(3));
        // error, å‚æ•°ç±»å‹é”™è¯¯
        println!("Is 'a' a number ? ", isalnum('a'));
    }
}


```

### åœ¨ rustè°ƒç”¨ cpp


```rs

// è°ƒç”¨ cpp c++
// 
// 




    // å•ç²¾åº¦å¤æ•°çš„æœ€ç®€å®ç°
    #[repr(C)]
    #[derive(Clone, Copy)]
    struct Complex {
        re: f32,
        im: f32,
    }
    impl fmt::Debug for Complex {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            if self.im < 0. {
                write!(f, "{}-{}i", self.re, -self.im)
            } else {
                write!(f, "{}+{}i", self.re, self.im)
            }
        }
    }
    // è¿™ä¸ª extern ä»£ç å—é“¾æ¥åˆ° libm åº“
    #[link(name = "m")]
    extern {
        // è¿™ä¸ªå¤–éƒ¨å‡½æ•°ç”¨äºè®¡ç®—å•ç²¾åº¦å¤æ•°çš„å¹³æ–¹æ ¹
        fn csqrtf(z: Complex) -> Complex;

        // è¿™ä¸ªç”¨æ¥è®¡ç®—å•ç²¾åº¦å¤æ•°çš„å¤å˜ä½™å¼¦
        fn ccosf(z: Complex) -> Complex;
    }
    // ç”±äºè°ƒç”¨å…¶ä»–è¯­è¨€çš„å‡½æ•°è¢«è®¤ä¸ºæ˜¯ä¸å®‰å…¨çš„ï¼Œæˆ‘ä»¬é€šå¸¸ä¼šç»™å®ƒä»¬å†™ä¸€å±‚å®‰å…¨çš„å°è£…
    fn cos(z: Complex) -> Complex {
        unsafe { ccosf(z) }
    }

    // z = -1 + 0i
    let z = Complex { re: -1., im: 0. };
    // è°ƒç”¨å¤–éƒ¨è¯­è¨€å‡½æ•°æ˜¯ä¸å®‰å…¨æ“ä½œ
    let z_sqrt = unsafe { csqrtf(z) };
    println!("the square root of {:?} is {:?}", z, z_sqrt);
    // è°ƒç”¨ä¸å®‰å…¨æ“ä½œçš„å®‰å…¨çš„ API å°è£…
    println!("cos({:?}) = {:?}", z, cos(z));

```


### åœ¨ c ä¸­è°ƒç”¨ rust



# å†…å­˜ç®¡ç†

## å † å’Œ æ ˆ


æ‰‹åŠ¨ç®¡ç†å†…å­˜ -> bug (å†…å­˜æ³„æ¼, å‚æ‚¬æŒ‡é’ˆ)

gc -> æ€§èƒ½é—®é¢˜(stop the world, å› ä¸ºGC åœ¨å·¥ä½œçš„ æ—¶å€™å¿…é¡»ä¿è¯ç¨‹åºä¸ä¼šå¼•å…¥æ–°çš„â€œåƒåœ¾", æ‰€ä»¥è¦ä½¿è¿è¡Œä¸­çš„ç¨‹åºæš‚åœ)

- è™šæ‹Ÿå†…å­˜ç®¡ç†æŠ€æœ¯: å¯¹ç‰©ç†å­˜å‚¨è®¾å¤‡çš„æŠ½è±¡, æ–¹ä¾¿åŒæ—¶è¿è¡Œ å¤šé“ç¨‹åº ï¼Œä½¿å¾—æ¯ä¸ªè¿›ç¨‹éƒ½æœ‰å„è‡ªç‹¬ç«‹çš„è¿›ç¨‹åœ°å€ç©ºé—´

- è™šæ‹Ÿåœ°å€ç©ºé—´: (ç”¨æˆ·æ‰€æ¥è§¦åˆ°çš„åœ°å€éƒ½æ˜¯è™šæ‹Ÿåœ°å€ï¼Œè€Œä¸æ˜¯çœŸå® çš„ç‰©ç†åœ°å€)

    - æ˜¯çº¿æ€§ç©ºé—´, åˆ†ä¸º ç”¨æˆ·ç©º é—´å’Œå†…æ ¸ç©ºé—´ (å®ƒä»¬çš„æ¯”ä¾‹æ˜¯ 3:1 (Linuxç³»ç»Ÿä¸­)æˆ– 2:2 (Windowsç³»ç»Ÿä¸­))

        32 ä½è®¡ç®—æœºLinuxçš„åœ°å€ç©ºé—´å¤§å°æ˜¯ 4GB
    
    - å¥½å¤„:

        - ç”¨æˆ·ç¨‹åºå¯ä»¥ä½¿ç”¨æ¯”ç‰©ç†å†…å­˜æ›´å¤§çš„åœ°å€ç©ºé—´

        - ä¿æŠ¤æ“ä½œç³»ç»Ÿï¼Œè®©è¿›ç¨‹åœ¨å„è‡ªçš„åœ°å€ç©ºé—´å†…æ“ä½œå†…å­˜

- ç”¨æˆ·ç©ºé—´ä¸­çš„ æ ˆ (stack), å † (heap)

    - æ ˆ (å †æ ˆ): ç”¨ äºæ”¯æŒ CPU å…¥æ ˆæˆ–å‡ºæ ˆçš„æŒ‡ä»¤æ“ä½œ, å¦‚å‡½æ•°åµŒå¥—è°ƒç”¨æ—¶éœ€è¦å­˜å‚¨æ–¹æ³•æ ˆå¸§

        stack å†…å­˜ä¸­ä¿å­˜çš„æ•°æ®ï¼Œç”Ÿå‘½å‘¨æœŸéƒ½æ¯”è¾ƒçŸ­ï¼Œä¼šéšç€å‡½æ•°è°ƒç”¨çš„å®Œæˆè€Œæ¶ˆäº¡, 
        
        å¯¹äºåŸºæœ¬åŸç”Ÿæ•°æ®ç±»å‹æ¥è¯´ï¼Œ Rust æ˜¯é»˜è®¤å°†å…¶åˆ†é…åˆ°æ ˆä¸­çš„

        ç»“æ„ä½“æˆ–æšä¸¾, è”åˆä½“åªæ˜¯å®šä¹‰ï¼Œçœ‹å®ƒä»¬è¢«åˆ†é…åœ¨å“ª ï¼Œä¸»è¦æ˜¯çœ‹å…¶ç±»å‹å®ä¾‹å¦‚ ä½•ä½¿ç”¨

    - å †: ä¸€å—å·¨å¤§çš„å†…å­˜ç©ºé—´, é•¿ä¹…åœ°ä¿å­˜åœ¨å†…å­˜ä¸­çš„æ•°æ®ï¼Œä»¥ä¾¿è·¨å‡½æ•°ä½¿ç”¨;ç¨‹åºä¸å¯ä»¥ä¸»åŠ¨ç”³è¯·æ¡” å†…å­˜ï¼Œä½†å¯ä»¥ä¸»åŠ¨ç”³è¯·å †å†…å­˜

    - å †åˆ†é…ç®—æ³•: ç©ºé—²é“¾è¡¨ (Free List)å’Œä½å›¾æ ‡è®° (Bitmap)ã€‚

        ç©ºé—²é“¾è¡¨å®é™…ä¸Šå°±æ˜¯æŠŠå †ä¸­ç©ºé—²çš„å†…å­˜åœ°å€è®°å½•ä¸ºé“¾è¡¨ ï¼Œ å½“ç³»ç»Ÿæ”¶åˆ°ç¨‹åºç”³è¯·æ—¶ï¼Œä¼šé å†è¯¥é“¾è¡¨:å½“æ‰¾åˆ°é€‚åˆçš„ç©ºé—´å †èŠ‚ç‚¹ æ—¶ï¼Œ ä¼šå°†æ­¤èŠ‚ç‚¹ä»é“¾è¡¨ä¸­åˆ é™¤;å½“ç©ºé—´è¢«å›æ”¶ä»¥å ï¼Œ å† å°†å…¶åŠ åˆ°ç©ºé—²é“¾è¡¨ä¸­ã€‚ç©ºé—²é“¾è¡¨çš„ä¼˜åŠ¿æ˜¯å®ç°ç®€å•ï¼Œä½†å¦‚æœé“¾è¡¨é­åˆ°ç ´å ï¼Œ æ•´ä¸ªå †å°±æ— æ³•æ­£ å¸¸å·¥ä½œã€‚

        ä½å›¾çš„æ ¸å¿ƒæ€æƒ³æ˜¯å°†æ•´ä¸ªå †åˆ’åˆ†ä¸ºå¤§é‡å¤§å°ç›¸ç­‰çš„å—ã€‚ å½“ç¨‹åºç”³è¯·å†…å­˜æ—¶ï¼Œæ€»æ˜¯åˆ†é…æ•´ æ•°ä¸ªå—çš„ç©ºé—´ã€‚æ¯å—å†…å­˜éƒ½ç”¨ä¸€ä¸ªäºŒè¿›åˆ¶ä½æ¥è¡¨ç¤ºå…¶çŠ¶æ€ï¼Œå¦‚æœè¯¥å†…å­˜è¢«å ç”¨ ï¼Œåˆ™ç›¸åº”ä½å›¾ ä¸­çš„ä½ç½®ç½®ä¸º 1;å¦‚æœè¯¥å†…å­˜ç©ºé—²ï¼Œåˆ™ç›¸åº”ä½å›¾ä¸­çš„ä½ç½®ç½®ä¸º 0ã€‚ä½å›¾çš„ä¼˜åŠ¿æ˜¯é€Ÿåº¦å¿«ï¼Œå¦‚ æœå•ä¸ªå†…å­˜å—æ•°æ®é­åˆ°ç ´åï¼Œ ä¹Ÿä¸ä¼šå½±å“æ•´ä¸ªå †ï¼Œä½†ç¼ºç‚¹æ˜¯å®¹æ˜“äº§ç”Ÿå†…å­˜ç¢ç‰‡

    - å†…å­˜é‡Šæ”¾: åˆ†é…çš„éƒ½æ˜¯è™šæ‹Ÿåœ°å€ç©º é—´ ã€‚ æ‰€ä»¥å½“å †ç©ºé—´è¢«é‡Šæ”¾æ—¶ï¼Œå¹¶ä¸ä»£è¡¨æŒ‡ç‰©ç† ç©º é—´ä¹Ÿ é©¬ä¸Šè¢«é‡Šæ”¾, åªæ˜¯å†…å­˜è¢«å½’è¿˜ç»™äº†å†…å­˜åˆ†é…å™¨ã€‚ å†…å­˜åˆ†é… å™¨ä¼šå¯¹ç©ºé—²çš„ å†…å­˜è¿›è¡Œç»Ÿä¸€ â€œæ•´ç†â€, åœ¨é€‚åˆ( æ¯”å¦‚ç©ºé—²å†…å­˜è¾¾åˆ° 2048KB)çš„æ—¶å€™ï¼Œæ‰ä¼šæŠŠ å†…å­˜å½’è¿˜ç»™ç³»ç»Ÿ ï¼Œä¹Ÿå°±æ˜¯æŒ‡é‡Šæ”¾ç‰©ç†ç©º é—´

        Rust ç¼–è¯‘å™¨ç›®å‰è‡ªå¸¦ä¸¤ä¸ªé»˜è®¤åˆ†é… å™¨: alloc_system å’Œ alloc_jemalloc, Rust 2018 ç‰ˆæœ¬ ä¸‹ï¼Œ é»˜è®¤ä½¿ç”¨ alloc_system, å¯ä»¥è‡ªå·±æŒ‡å®š


## å†…å­˜å¯¹é½


å†…å­˜å¯¹é½, å³å­—èŠ‚å¯¹é½, å‡å°‘ cpu è¯»å–å†…å­˜æ¬¡æ•°

CPUåœ¨å•ä½æ—¶é—´/ä¸€æ¬¡è®¡ç®—èƒ½å¤„ç†çš„ä½æ•° -> å­—é•¿, 32ä½CPUï¼Œ å…¶å­—é•¿ä¸º32ä½ï¼Œä¹Ÿå°±æ˜¯ä¸€æ¬¡è¯»å–4ä¸ªå­—èŠ‚, æ‰€ä»¥æ¯æ¬¡åªèƒ½å¯¹ 4 çš„ å€æ•°çš„ åœ°å€ è¿›è¡Œè¯»å–

ç°æœ‰ä¸€æ•´æ•°ç±»å‹çš„æ•°æ®ï¼Œé¦–åœ°å€å¹¶ä¸æ˜¯ 4 çš„å€æ•°ï¼Œä¸å¦¨è®¾ä¸º Ox3, å­˜å‚¨åœ¨ åœ°å€èŒƒå›´æ˜¯ Ox3~Ox7 çš„å­˜å‚¨ç©ºé—´, cpu éœ€è¦åˆ†åˆ«åœ¨ Ox1 å’Œ Ox5 å¤„è¿›è¡Œä¸¤æ¬¡è¯»å–, é‡‡å–å†…å­˜å¯¹é½ç­–ç•¥å, æ•°æ®çš„é¦–åœ°å€å˜ä¸º 0x5, CPUåªéœ€è¦è¯»å–ä¸€æ¬¡ã€‚


```rs
// å¯¹åº”åˆ°ä»£ç å±‚é¢:
struct A {
    a: u8,// 1byte
    b: u32,// 4byte
    c: u16,  // 2 byte
}
println!("{:?}", std :: mem::size o f : : < A > ( );// 8 , å•ä½ å­—èŠ‚

// åˆ†æ:
// æ€»å…±æ˜¯ 7, ä¸ºä»€ä¹ˆæ‰“å° 8 ?
// å› ä¸ºå­˜åœ¨å†…å­˜å¯¹é½ç­–ç•¥
// 
// å†…å­˜å¯¹é½åŒ…æ‹¬åŸºæœ¬æ•°æ®å¯¹é½å’Œç»“æ„ä½“(æˆ–è”åˆä½“)æ•°æ®å¯¹é½
// å¯¹äºåŸºæœ¬æ•°æ®ç±»å‹ï¼Œé»˜è®¤ å¯¹é½æ–¹å¼æ˜¯æŒ‰å…¶å¤§å°è¿›è¡Œå¯¹é½ï¼Œä¹Ÿè¢«ç§°ä½œè‡ªç„¶å¯¹é½ã€‚ æ¯”å¦‚Rustä¸­u32ç±»å‹å 4å­—èŠ‚ï¼Œåˆ™å®ƒé»˜ è®¤å¯¹é½æ–¹å¼ä¸º 4 å­—èŠ‚å¯¹é½
```

## æ‰‹åŠ¨å †å†…å­˜åˆ†é…

åœ¨ç¼–å†™ Unsafe Rustçš„è¿‡ç¨‹ä¸­ï¼Œä¹Ÿéœ€è¦æ‰‹åŠ¨è¿›è¡Œå †å†…å­˜åˆ†é…ï¼Œæ‰€ä»¥ Rustæ ‡å‡†åº“ std::alloc æ¨¡å—ä¸­ä¹Ÿæä¾› äº†å †å†…å­˜ åˆ†é…çš„ ç›¸ å…³ API


```rs
// Rust 1.28ä¹‹å‰é»˜è®¤å…¨å±€å†…å­˜åˆ†é…å™¨ï¼šjemalloc
// Rust 1.28å†…å­˜åˆ†é…å™¨ : Systemï¼ŒåŒæ—¶ä¼šæä¾›å…¶ä»–å…¨å±€åˆ†é…å™¨ï¼Œå¯è‡ªå®šä¹‰
// 
use std::alloc::{GlobalAlloc, System, Layout};
struct MyAllocator;// å¯ä»¥ç›´æ¥ä½¿ç”¨GlobalAlloc, è¿™é‡Œæ˜¯åšäº†ä¸€ä¸ªåŒ…è£…
unsafe impl GlobalAlloc for MyAllocator {
    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
        System.alloc(layout)
    }
    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {
        System.dealloc(ptr, layout)
    }
}
// å£°æ˜ä¸ºå…¨å±€åˆ†é…å™¨
#[global_allocator]
static GLOBAL: MyAllocator = MyAllocator;
fn main() {
   // æ­¤å¤„Vecçš„å†…å­˜ä¼šç”±GLOBALå…¨å±€åˆ†é…å™¨æ¥åˆ†é…
   let mut v = Vec::new();
   v.push(1);
}


// æŒ‡å®šå…¨å±€åˆ†é…å™¨ä¸ºjemalloc
// 
extern crate jemallocator;
use jemallacator::Jemalloc;
#[global_allocator]
static GLOBAL: Jemalloc = Jemalloc;

```



# å·¥ç¨‹ç®¡ç† æ¨¡å—

## æ¦‚å¿µç®€å•è§£é‡Š

https://www.jianshu.com/p/51693602114a
https://zhuanlan.zhihu.com/p/73544030
or
https://privaterookie.github.io/2019-07-14-Rust%E6%A8%A1%E5%9D%97%E4%B8%8E%E6%96%87%E4%BB%B6/


```rust
/// - ç®±ï¼ˆCrateï¼‰: äºŒè¿›åˆ¶ç¨‹åºæ–‡ä»¶or åº“æ–‡ä»¶, ä½äºåŒ…ä¸­
/// 
/// - åŒ…ï¼ˆPackageï¼‰: cargo new xxx æ–°å»ºçš„ å°±æ˜¯ åŒ…; åŒ…å¿…é¡»ç”±ä¸€ä¸ª Cargo.toml æ–‡ä»¶æ¥ç®¡ç†ï¼Œè¯¥æ–‡ä»¶æè¿°äº†åŒ…çš„åŸºæœ¬ä¿¡æ¯ä»¥åŠä¾èµ–é¡¹ã€‚
///
///    ä¸€ä¸ª package æœ€å°‘æœ‰ä¸€ä¸ª crate
///
///    å½“ä½¿ç”¨ cargo new å‘½ä»¤åˆ›å»ºå®ŒåŒ…ä¹‹åï¼Œsrc ç›®å½•ä¸‹ä¼šç”Ÿæˆä¸€ä¸ª main.rs æºæ–‡ä»¶ï¼ŒCargo é»˜è®¤è¿™ä¸ªæ–‡ä»¶ä¸ºäºŒè¿›åˆ¶ç®±çš„æ ¹ï¼Œç¼–è¯‘ä¹‹åçš„äºŒè¿›åˆ¶ç®±å°†ä¸åŒ…åç›¸åŒã€‚
///
/// - æ¨¡å—ï¼ˆModuleï¼‰: ä½¿ç”¨ mod å£°æ˜ä¸€ä¸ªæ¨¡å—, ä¸€ä¸ªæ–‡ä»¶é»˜è®¤å°±æ˜¯ä¸€ä¸ª module, æ–‡ä»¶åå°±æ˜¯ module name
// 
//      æ¯ä¸ªåŒ…éƒ½æ‹¥æœ‰ä¸€ä¸ªé¡¶çº§ (top level) æ¨¡å— src/lib.rs æˆ– src/main.rsã€‚
/// 
///     æ¯ä¸ª rust æ–‡ä»¶éƒ½æ˜¯ä¸€ä¸ª module, æ¯”å¦‚: 
//      (è‹¥æƒ³åœ¨åŒä¸ªæ–‡ä»¶å®šä¹‰å¤šä¸ª module , åªéœ€ mod xx_module {...} mod yy_module {...})
///     ```
///     // main.rs
///     mod second_module; // å£°æ˜ä¸€ä¸ªæ¨¡å—
///     fn main() {
///         println!("This is the main module.");
///         println!("{}", second_module::message());
///     }
///     // second_module.rs, æ¨¡å—åå°±æ˜¯æ–‡ä»¶å
///     pub fn message() -> String {
///         String::from("This is the 2nd module.")
///     }
///     ```
// 
//      è‹¥å¸Œæœ›å¤šä¸ª æ–‡ä»¶, ç»„æˆä¸€ä¸ª module,
//      éœ€è¦:
//      åˆå¹¶åˆ°ä¸€ä¸ªæ–‡ä»¶å¤¹, æ–°å»ºä¸€ä¸ª mod.rs (2018 ä¸­å¯ä»¥çœç•¥äº†), ç„¶ååœ¨å…¶ä¸­å¯¼å‡ºå³å¯ (pub use sub1; pub use sub2;), æ–° module name = æ–‡ä»¶å¤¹å
// 
//      è‹¥æ–‡ä»¶å¤¹ å’ŒæŸä¸ªæ–‡ä»¶ aa.rs åŒå, åˆ™æ–‡ä»¶å¤¹ä¸‹å®šä¹‰çš„ module éƒ½æ˜¯ aa.rs çš„å­æ¨¡å— (2015 ä¸­åˆ™ä¸å…è®¸æ–‡ä»¶ä¸ç›®å½•åŒå)
// 
// 
fn mod_package_crate() {

    // è·¯å¾„:
    // Rust ä¸­çš„è·¯å¾„åˆ†éš”ç¬¦æ˜¯ ::
    
    //ç»å¯¹è·¯å¾„ä» crate å…³é”®å­—å¼€å§‹æè¿°ã€‚
    // ç›¸å¯¹è·¯å¾„ä» self æˆ– super å…³é”®å­—æˆ–ä¸€ä¸ªæ ‡è¯†ç¬¦å¼€å§‹æè¿°

    // å¦‚: å¯¼å…¥å¤–éƒ¨ä¾èµ–
    use super::{deserial, serial}; //å¯¼å…¥ parent æŒ‡å®šèµ„æº
    use super::*; // å¯¼å…¥ parent çš„æ‰€æœ‰
    use crate::codec::{serial, deserial}; // ç»å¯¹è·¯å¾„, codec ä¸ºä¾èµ– (ä¸è®ºæ˜¯è‡ªå®šä¹‰æ¨¡å—è¿˜æ˜¯ç¬¬ä¸‰æ–¹ä¾èµ–, è‹¥ä¸ºç¬¬ä¸‰æ–¹æ¨¡å—, åˆ™ crate å…³é”®å­—å¯é€‰), codec ä¹Ÿèƒ½æ˜¯ åŒä¸ªé¡¹ç›®çš„å…¶ä»– module (rust æ–‡ä»¶)

//  æ ‡å‡†åº“ é»˜è®¤å¯¼å…¥äº†, æ‰€ä»¥ä»¥ä¸‹ä¸¤å¥å¯é€‰
    extern crate std; // å¯¼å…¥ æ ‡å‡†åº“ std crate, è¿™æ˜¯ 2015 ä¸­çš„è¯­æ³•, 2018 ä¸­å¯é€‰äº†, åªéœ€è¦ cargo.toml ä¸­å¯¼å…¥å³å¯, æ— éœ€å†ä»£ç ä¸­æ˜¾å¼æŒ‡å®š
    use std : :prelude: :vl: :* ; // æ ‡å‡†åº“çš„ prelude module

    // åœ¨ module å¼€å¤´å£°æ˜ä¸éœ€è¦ æ ‡å‡†åº“, ä½¿ç”¨ æ ¸å¿ƒåº“(åµŒå…¥å¼å¼€å‘å¿…é¡»)
    #[no_std]




    // govern å‡½æ•°çš„ç»å¯¹è·¯å¾„
    crate::nation::government::govern();
    // ç›¸å¯¹è·¯å¾„
    nation::government::govern();


    //Rust ä¸­æœ‰ä¸¤ç§ç®€å•çš„è®¿é—®æƒï¼šå…¬å…±ï¼ˆpubï¼‰å’Œç§æœ‰ï¼ˆæ¨¡å—æˆå‘˜é»˜è®¤éƒ½æ˜¯ç§æœ‰ï¼‰ã€‚
    // ç§æœ‰ æ¨¡å—ä¸­çš„å…ƒç´ éƒ½éœ€è¦ pub ä¿®é¥°æ‰èƒ½åœ¨å¤–éƒ¨è®¿é—®åˆ° , ä½†æ˜¯ æšä¸¾ç±»çš„å­—æ®µä¸å—è¿™ä¸ªé™åˆ¶
    //å¯¹äºç§æœ‰çš„æ¨¡å—ï¼Œåªæœ‰åœ¨ä¸å…¶å¹³çº§çš„ä½ç½®æˆ–ä¸‹çº§çš„ä½ç½®æ‰èƒ½è®¿é—®ï¼Œä¸èƒ½ä»å…¶å¤–éƒ¨è®¿é—®ã€‚
    mod nation {
        pub mod government {
            pub fn govern() {println!("govern()")}
        }
    
        mod congress {
            pub fn legislate() {
                println!("legislate()");
            }
        }
       
        pub mod court {
            pub fn judicial() {
                print!("judicial - ");
                super::congress::legislate();
            }
        }

        // use å…³é”®å­—å¯ä»¥ä¸ pub å…³é”®å­—é…åˆä½¿ç”¨ï¼š
        pub use congress::legislate as le;

    }
    
    nation::government::govern();
    nation::court::judicial();

    // å¯¼å…¥ and ç®€åŒ–è·¯å¾„
    use nation::court::judicial as  ju;
    // ç°åœ¨å¯ä»¥ç›´æ¥ä½¿ç”¨
    ju();

    nation::le();
}

```

## ç¼–è¯‘å™¨ç‰ˆæœ¬ç®¡ç†

åœ¨é¡¹ç›®æ ¹ç›®å½•ä¸‹, æ”¾ rust-toolchain æ–‡ä»¶, æŒ‡å®šç¼–è¯‘å™¨ç‰ˆæœ¬

## ä¸ºé¡¹ç›®å•ç‹¬æŒ‡å®šconfig é…ç½®

```
cargo å…¨å±€é…ç½® : /.cargo/confg
å½“å‰ç”¨æˆ·å…¨å±€é…ç½®: $HOME/.cargo/config
é¡¹ç›®å•ç‹¬é…ç½®:     $proj/.cargo/config (å­æ¨¡å—äº¦å¯ç»§ç»­æŒ‡å®š)

```

## ä¾èµ–ç®¡ç† cargo

### cargo åŸºæœ¬å‘½ä»¤

```sh
# æ–°å»ºå¯æ‰§è¡Œç¨‹åº, é»˜è®¤æ˜¯ --bin
# ç”Ÿæˆ main.rs å¯åŠ¨ç±»
cargo new [--bin] <proj>

# ä¸åˆå§‹åŒ– git
cargo new <proj> --vcs none

# æ–°å»ºåº“, åœ¨é¡¹ç›®æ ¹ç›®å½•ä¸‹
# ç”Ÿæˆ çš„åº“ä¸‹, æœ‰ src, toml, lib_name.rs (å¸¦æœ‰åŸºæœ¬çš„æµ‹è¯•)
cargo new --lib <lib name>


# åœ¨å½“å‰æ–‡ä»¶å¤¹ä¸‹æ–°å»ºé¡¹ç›®
cargo init [--bin]
cargo init --lib




# æ„å»º, æ›´æ–°ä¾èµ–, ä¾èµ–åœ¨è¿™é‡Œæ‰¾ https://crates.io/
# é»˜è®¤æ˜¯ä»¥ debug æ–¹å¼ç¼–è¯‘, ç¼–è¯‘é€Ÿåº¦å¿«, ä½†æ˜¯ç”Ÿæˆçš„å¯æ‰§è¡Œæ–‡ä»¶æœªä¼˜åŒ–
# build åä¼šç”Ÿæˆ Cargo.lock
#  ./target/debug/project_name ä¸­æ‰¾åˆ°ç¼–è¯‘åçš„ å¯æ‰§è¡Œæ–‡ä»¶(exe) è¿è¡Œ
cargo build 

# ä½¿ç”¨ --release å‚æ•°ç¼–è¯‘æœ€ç»ˆå‘å¸ƒç‰ˆæœ¬ã€‚
# ç¼–è¯‘å™¨ä¼šå¯¹ä»£ç è¿›è¡Œä¼˜åŒ–ï¼Œ ä½¿å¾—ç¼–è¯‘æ—¶é—´å˜æ…¢ï¼Œ ä½†æ˜¯ä»£ç è¿è¡Œé€Ÿåº¦ä¼šå˜å¿«ã€‚
cargo build --release

# æŒ‡å®šæ¡ä»¶ç¼–è¯‘å±æ€§ (å¯ä»¥åœ¨ Cargo.toml ä¸­æŒ‡å®š)
# ä¼šç»™ rustc ä¼ é€’ --cfg features="xxx", è¡¨ç¤º ä¼šç¼–è¯‘ aa_module æ¨¡å—, ä¸æŒ‡å®š xxx feature åˆ™ä¸ä¼šç¼–è¯‘ è¯¥æ¨¡å—
cargo build --features "xxx"
# åœ¨ä»£ç ä¸­è¿™ä¹ˆä½¿ç”¨
#   # è¡¨ç¤ºè‹¥æ²¡æœ‰æŒ‡å®š xxx feature, åˆ™ç¼–è¯‘æŠ¥é”™
#   #[cfg(not(feature = "xxx"))]
#   compile_error!("xxx feature is required to build this crate")
#   
#   # è¡¨ç¤º åªæœ‰æŒ‡å®š äº† xxx feature, ç¼–è¯‘æ—¶æ‰ä¼šåŒ…å« aa_module è¿›å»
#   #[cfg(feature = "xxx")]
#   mod aa_module



cargo check # è¿…é€Ÿæ£€æŸ¥é”™è¯¯, æ—¶é—´çŸ­




cargo run 
# è¿è¡Œ example æ–‡ä»¶å¤¹ä¸‹çš„ server.rs çš„ main()
cargo run --example server
# è¿è¡ŒæŒ‡å®šå­æ¨¡å—
cargo run -p <xxx>

# è¿è¡Œå½“å‰é¡¹ç›®(rust_tools)ä¸‹çš„ bin æ–‡ä»¶å¤¹ä¸‹çš„ chat_server.rs å¯æ‰§è¡Œæ–‡ä»¶
cargo run --package rust_tools --bin chat_server




# ä»ä¸­å¿ƒä»“åº“å®‰è£…
cargo install <package>
# ä» GitHub å®‰è£…
cargo install orz --git https://github.com/richox/orz --tag v1.6.1 





cargo doc # ç”Ÿæˆhtmlæ–‡æ¡£
cargo doc --open # åŒæ—¶æ‰“å¼€æ–‡æ¡£é¢„è§ˆ
cargo doc --target-doc ./ #è¾“å‡ºæ–‡æ¡£æ—¶æŒ‡å®štargetç›®å½•





# # æµ‹è¯•, 
# ä¼šè·‘ #cfg[test] ä¸‹çš„ #[test]; ä¹Ÿä¼šè·‘æ–‡æ¡£æ³¨é‡Š (å•å…ƒæµ‹è¯•)
# and  tests/ ä¸‹çš„æµ‹è¯• (é›†æˆæµ‹è¯•)
cargo test 
cargo test xxx # è¿‡æ»¤, è¿è¡Œä»»ä½•åå­—ä¸­åŒ…å« xxx çš„æµ‹è¯•




cargo publish # publish a library to crates.io
cargo --version




# This will write out a new Cargo.lock with the new version information
cargo update           # updates all dependencies
cargo update -p rand   # updates just â€œrandâ€

# ç¬¬ä¸‰æ–¹æ’ä»¶æ‰©å±•:

# éœ€è¦ rustup component add rustfmt [ä¸€toolchain nightly]
cargo fmt # æ ¼å¼åŒ–é¡¹ç›®ä»£ç , åœ¨é¡¹ç›®æ ¹ç›®å½•ä¸‹æ‰§è¡Œ, ä¼šç”Ÿæˆå¤‡ä»½æ–‡ä»¶, .bkç»“å°¾, è·³è¿‡æ ¼å¼åŒ– #[rustfmt_skip]
cargo fix # è‡ªåŠ¨ä¿®å¤ä»£ç è­¦å‘Š
cargo clippy #æ•æ‰å¸¸è§é”™è¯¯ï¼Œæ”¹å–„ä»£ç  (éœ€è¦å®‰è£… clippy)
```

è‡ªå®šä¹‰æ ¼å¼åŒ–:  åœ¨é¡¹ç›®æ ¹ç›®å½• rustfmt.tomI

```t
max_width = 90 # æœ€å¤§å®½åº¦
fn_call_width = 90 # å‡½æ•°å®½åº¦
chain_one_line_max = 80 # é“¾å¼è°ƒç”¨æœ€å¤§å®½åº¦
condense_wildcard_suffixes = true # å‹ç¼©é€šé…ç¬¦å‰ç¼€
```

### æ–‡ä»¶å¸ƒå±€ç»“æ„

```sh
.
â”œâ”€â”€ Cargo.lock
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ benches #æ€§èƒ½æµ‹è¯•
â”‚Â Â  â””â”€â”€ large-input.rs
â”œâ”€â”€ examples    # ç¤ºä¾‹
â”‚Â Â  â””â”€â”€ simple.rs
â”œâ”€â”€ src    # æºç 
â”‚Â Â  â”œâ”€â”€ bin # å…¶ä»–å¯æ‰§è¡Œæ–‡ä»¶ (å¦‚æœå¯æ‰§è¡Œæ–‡ä»¶åŒ…å«ä¸æ­¢ä¸€ä¸ªæºæ–‡ä»¶ï¼Œåˆ™å¯ä»¥ä½¿ç”¨src/binç›®å½•ä¸‹ï¼Œåˆä¸€ä¸ªåŒ…å«main.rsæ–‡ä»¶çš„ç›®å½•,è€Œè¯¥ç›®å½•å°†è¢«è§†ä¸ºå…·æœ‰çˆ¶ç›®å½•åç§°çš„å¯æ‰§è¡Œæ–‡ä»¶)
â”‚Â Â  â”‚Â Â  â””â”€â”€ another_executable.rs
â”‚Â Â  â”œâ”€â”€ lib.rs  # é»˜è®¤åº“æ–‡ä»¶
â”‚Â Â  â””â”€â”€ main.rs # é»˜è®¤å¯æ‰§è¡Œæ–‡ä»¶
â””â”€â”€ tests   # é›†æˆæµ‹è¯• , å•å…ƒæµ‹è¯•ä¸€èˆ¬å°±å†™åœ¨ src ä¸‹
    â””â”€â”€ some-integration-tests.rs


```

### Cargo.toml

Cargo.toml é¡¹ç›®å…ƒä¿¡æ¯, åŒ…æ‹¬ç‰ˆæœ¬, ä¾èµ–


```t
[package]
...
build = "build.rs" # æ„å»ºè„šæœ¬, ç›¸å¯¹äºæ ¹ç›®å½•
workspace = ".." # è¿™æ˜¯ sub crate ä¸­çš„é…ç½®
member = ["", ""] # è¿™æ˜¯ parent crate ä¸­çš„é…ç½®

[[bin]]
name = "run-main" # ç”Ÿæˆçš„å¯æ‰§è¡Œæ–‡ä»¶çš„åå­—
path = "src/main.rs" # å½“æƒ³åœ¨ä¸€ä¸ªä½œä¸ºåº“çš„åŒ…é‡ŒåŒæ—¶åŒ…å« main.rs , éœ€è¦é…ç½®è¿™ä¸ª, æ–‡ä»¶åå¿…é¡»ä¸º main.rs, è‹¥æ”¾åœ¨ src/bin ä¸‹åˆ™å¯ä»¥è‡ªå®šä¹‰æ–‡ä»¶å
bench = false # ç”Ÿæˆ å¯æ‰§è¡Œæ–‡ä»¶æ—¶ä¸æ‰§è¡Œæ€§èƒ½æµ‹è¯•


[[bench]]
name = "bench"
path = "src/bench.rs" # æ€§èƒ½æµ‹è¯•ä»£ç 
test = false
bench = true


# ä¾èµ–
#  [dependencies] ä¸“é—¨ç”¨äºè®¾ç½®ç¬¬ä¸‰æ–¹åŒ…çš„ä¾èµ–ï¼Œè¿™äº›ä¾èµ–ä¼šåœ¨æ‰§è¡Œ cargo buildå‘½ä»¤ç¼–è¯‘ æ—¶ä½¿ç”¨ã€‚
[dependencies]
uuid = "0.0.1" # ä¼šä»ä¸­å¿ƒä»“åº“ä¸‹è½½
ferris-says = "0.1"

# ç‰ˆæœ¬å·è§„åˆ™


[dependencies]
gfx-hal = { version = "0.1.0", git = "https://github.com/gfx-rs/gfx", rev = "bd7f058efe78d7626a1cc6fbc0c1d3702fb6d2e7" }
#  æˆ–è€…å†™æˆå¤šè¡Œ (ä½¿ç”¨ç‚¹ "." è¡¨ç¤ºjson ä¸­çš„åµŒå¥—)
[dependencies.gfx-hal]
git = "https://github.com/gfx-rs/gfx"
version = "0.1.0" 
rev = "bd7f058efe78d7626a1cc6fbc0c1d3702fb6d2e7"


# æœ¬åœ°é¡¹ç›®å¯¼å…¥
[dependencies]
hello_utils = { path = "../hello_utils", version = "0.1.0" }

# é»˜è®¤ä¸ä¼šè¢«ç¼–è¯‘, ä½†æ˜¯å®šä¹‰äº†ä¸€ä¸ª å’Œä¾èµ–åç§°ä¸€æ ·çš„ feature, å³ gif, åœ¨ä»£ç ä¸­å¯ä»¥ä½¿ç”¨ cfg(feature = "gif"), ç„¶åå‘½ä»¤è¡Œä¸­å¯ä»¥ --features gif ä½¿ç”¨æ¡ä»¶ç¼–è¯‘
# å½“ç„¶, ä¹Ÿèƒ½è¿™æ ·ä½¿ç”¨: 
    # [dependencies]
    # ravif = { version = "0.6.3", optional = true }
    # rgb = { version = "0.8.25", optional = true }
    # 
    # [features]
    # avif = ["ravif", "rgb"] (æ— æ³•ç›´æ¥ä½¿ç”¨ raif, æˆ–è€… rgb)
gif = { version = "0.11.1", optional = true }

 
# [dev-dependencies]è¡¨çš„ä½œç”¨ç”¨æ¥è®¾ç½®æµ‹è¯•( tests)ã€ç¤ºä¾‹ (examples)å’ŒåŸºå‡†æµ‹è¯•( benchmarks)æ—¶ä½¿ç”¨çš„ä¾èµ–, åœ¨æ‰§è¡Œ cargo test æˆ– cargo bench å‘½ ä»¤ æ—¶ä½¿ç”¨ ã€‚
[dev-dependencies]



# build ä¾èµ–åº“
[build-dependencies]
cc = "1.0"

# æ‰“å¼€æŒ‡å®š feature
[dependencies]
serde = { version = "1.0.118", features = ["derive"] }
# ç¦ç”¨é»˜è®¤æ‰“å¼€çš„ feature
flate2 = { version = "1.0.3", default-features = false, features = ["zlib"] }



# æ¡ä»¶ç¼–è¯‘åŠŸèƒ½ (é€‰æ‹©æ€§åœ°ç¼– è¯‘ ä»£ ç )
# é€šè¿‡å‘½ä»¤è¡Œ --features "foo bar"
# é»˜è®¤æ‰€æœ‰ features æ˜¯å…³é—­çš„, é™¤éæ‰‹åŠ¨æ‰“å¼€, é€šè¿‡ default feature å¯ä»¥æ”¹å˜è¿™ä¸€é»˜è®¤çº¦å®š
# å¯ä»¥é€šè¿‡å¼•å…¥ä¾èµ–æ—¶æŒ‡å®š default-features=false å³ flate2 = { version = "1.0.3", default-features = false, features = ["zlib"] } æ¥é˜²æ­¢é»˜è®¤æ‰“å¼€æŸäº› feature
[features]
default=["use_std"] # use_std feature å°±é»˜è®¤æ‰“å¼€äº†
use_std=[]
unstable= ["pattern"]
patter=[]
# æ‰“å¼€jpeg-decoderä¾èµ–çš„ rayon feature
parallel = ["jpeg-decoder/rayon"]


# æœ€ç»ˆç¼–è¯‘ç›®æ ‡åº“çš„ä¿¡æ¯
[lib]
name = foo # è¡¨ç¤ºå°†æ¥ç¼–è¯‘çš„åº“åå­—ä¸ºâ€œlibfooaâ€ æˆ– â€œlibfoo.so"ç­‰ã€‚
crate-type = dylib # æ¯”å¦‚ crate-type = [â€dylibâ€, â€staticlibâ€]ï¼Œè¡¨ç¤ºå¯ ä»¥åŒæ—¶ç¼–è¯‘ç”ŸæˆåŠ¨æ€åº“å’Œé™æ€åº“ã€‚
path = "src/lib.rs" # è¡¨ç¤ºåº“æ–‡ä»¶å…¥å£ ï¼Œ å¦‚æœä¸æŒ‡å®šï¼Œ åˆ™é»˜è®¤æ˜¯ src/lib.rsã€‚
test=true # è¡¨ç¤ºå¯ä»¥ä½¿ç”¨å•å…ƒæµ‹è¯•
bench = true # è¡¨ç¤ºå¯ä»¥ä½¿ç”¨æ€§èƒ½åŸºå‡†æµ‹è¯•, è‹¥ä»£ç ä¸­æ²¡æœ‰æä¾›æ€§èƒ½åŸºå‡†æµ‹è¯•, åˆ™å¯è®¾ç½®ä¸º  false


# åŒä¸­æ‹¬å· -> æ•°ç»„
[[test]]
path = "tests/test_default.rs" 
name = "default"
[[test]]
name = "aa"
path = "tests/aa.rs"




# ä½¿ç”¨æœ¬åœ°ä»“åº“ä¸­çš„ä»£ç build
[patch.crates-io]
uuid = { path = "../path/to/uuid" }
# é»˜è®¤ master åˆ†æ”¯, # æ‰‹åŠ¨æŒ‡å®š commit id, ä¸è¿‡æœ‰äº† lock æ–‡ä»¶, å°±ä¸å¿…è¿™ä¹ˆå¹²äº†
uuid = {git = "https://github.com/uuid-rs/uuid.git",  rev = "9f35b8e"} 


# å››ä¸ªå†…å»ºçš„ profile : dev, release, test, and bench, åœ¨å‘½ä»¤è¡Œé€šè¿‡ --release æŒ‡å®š

# å¯¹æ¯ä¸ª profile è¿›è¡Œæ›´ç»†è‡´çš„é…ç½®
# åˆ†åˆ«ä»£è¡¨å¯¹ Releaseã€ Bench å’Œ Test, debug å››ç§ ç¼–è¯‘æ¨¡å¼è¿›è¡Œé…ç½®
[profile.release]
debug=true # ç¼–è¯‘æ—¶, åŒ…å« debug ä¿¡æ¯
# ä¼˜åŒ–çº§åˆ«
opt-level = 3 # ç¼–è¯‘ä¼˜åŒ–, è€—æ—¶æ›´é•¿

[profile.bench]
debug=true

[profile.test]
debug=true

[profile.dev]
opt-level = 0 # ä¼˜åŒ–çº§åˆ«, å‘½ä»¤è¡Œé€šè¿‡  -C opt-level=1 æŒ‡å®š
                # 0: no optimizations, also turns on cfg(debug_assertions) (the default).
                # 1: basic optimizations.
                # 2: some optimizations.
                # 3: all optimizations.
                # s: optimize for binary size.
                # z: optimize for binary size, but also turn off loop vectorization.

overflow-checks = false # Disable integer overflow checks
lto= # è¿æ¥æ—¶é—´ä¼˜åŒ–



```





### cargo.lock

é”å®šä¾èµ–ç‰ˆæœ¬



### workspace

å·¥ä½œç©ºé—´å¯ä»¥ç®¡ç†å¤šä¸ª proj å’Œ lib

æ–°å»º Cargo.toml ä½œä¸ºæ ¹åŒ…çš„å…ƒæ•°æ® (å·¥ä½œç©ºé—´ä¸­çš„å­åŒ… ä¹Ÿéƒ½æœ‰è‡ªå·±çš„ Cargo.toml é…ç½®ï¼Œå„è‡ªç‹¬ç«‹ï¼Œ äº’ä¸å½±å“)

```t
[workspace]
members = [
    "main", # å¯æ‰§è¡Œ ä¸»ç¨‹åº
    "core", # æ ¸å¿ƒç±»åº“
    "util", # å·¥å…·åº“
]
```

ä¸ç®¡æ˜¯ç¼–è¯‘æ ¹åŒ…è¿˜æ˜¯å­åŒ…ï¼Œæœ€ç»ˆçš„ç¼–è¯‘ç»“ æœæ°¸è¿œéƒ½ä¼šè¾“å‡ºåˆ°æ ¹åŒ…çš„ target ç›®å½•ä¸‹ï¼Œå¹¶ä¸”æ•´ä¸ªå·¥ä½œç©ºé—´åªå…è®¸æœ‰ä¸€ä¸ª Cargo.lock æ–‡ä»¶ã€‚

`cargo new [--bin] main`, `cargo new --lib core`, `cargo new --lib util`; ç”±äºæ¯æ¬¡åˆ›å»ºæ—¶, cargo éƒ½ä¼šæ£€æŸ¥ é¡¶å±‚ Cargo é…ç½®æ–‡ä»¶ä¸­çš„ member æ˜¯å¦éƒ½å­˜åœ¨, æ‰€ä»¥ä¸­é—´å¯èƒ½æ£€æŸ¥å‡ºç°é”™è¯¯, ä¸å¿…æ‹…å¿ƒ, å…¨éƒ¨åˆ›å»ºå®Œé”™è¯¯å°±æ¶ˆå¤±äº†

lib ç±»å‹ç±»å‹éœ€è¦å°†æ–°å»ºçš„ module (å³rsæ–‡ä»¶) åœ¨ lib.rs ä¸­å£°æ˜ `pub mod xxx`, pub å¯é€‰

### ä¾èµ–çš„ç‰ˆæœ¬å·è§„åˆ™

```rs
// Rust åŒ…ä½¿ç”¨çš„æ˜¯è¯­ä¹‰åŒ–ç‰ˆæœ¬å· (SemVer)ã€‚åŸºæœ¬æ ¼å¼ä¸ºâ€œXå«Zâ€

// â€¢ xï¼Œä¸»ç‰ˆæœ¬å· å½“åšäº†ä¸å…¼å®¹æˆ–é¢ è¦†æ€§çš„æ›´æ–°æ—¶ ï¼Œ ä¿®æ”¹æ­¤ç‰ˆæœ¬å·ã€‚
// â€¢ yï¼Œ ;æ¬ ç‰ˆæœ¬å· (minor)ã€‚å½“åšäº†å‘ä¸‹å…¼å®¹çš„åŠŸèƒ½æ€§ä¿®æ”¹æ—¶ï¼Œä¿®æ”¹æ­¤ç‰ˆæœ¬å· ã€‚ 
// â€¢ zï¼Œä¿®è®¢ç‰ˆæœ¬å· (patch)ã€‚å½“åšäº†å‘ä¸‹å…¼å®¹çš„é—®é¢˜ä¿®æ­£æ—¶ï¼Œä¿®æ”¹æ­¤ç‰ˆæœ¬å·ã€‚

// ç¬¦å·:
// ^: ç‰ˆæœ¬å·å¿…é¡»å¤§äºæŒ‡å®šç‰ˆæœ¬, æ–°çš„ç‰ˆæœ¬å¿…é¡»æ»¡è¶³ä¸ä¿®æ”¹[major, minor, patch]ä¸­æœ€å·¦è¾¹éé›¶æ•°å­—ã€‚å¦‚æŒ‡å®š ^1.0.0, ç­‰ä»·äº >=1.0.0 <2.0.0
// *: é€šé…ç¬¦, å¯ä»¥ç”¨åœ¨[major, minor,patch]çš„ä»»ä½•ä¸€ä¸ªä¸Šé¢ã€‚ 
// ~: å…è®¸ä¿®æ”¹[major, minor, patch]ä¸­æ²¡æœ‰æ˜ç¡®æŒ‡å®šçš„ç‰ˆæœ¬å·
// æ‰‹åŠ¨æŒ‡å®šï¼Œ é€šè¿‡ >, <, =, >=, <= æ¥æŒ‡å®šç‰ˆæœ¬å· ã€‚

```

## build.rs

build.rså¯å®ç°æœ¬é¡¹ç›®ç¼–è¯‘å‰çš„é¢å¤–æ“ä½œï¼Œæ¯”å¦‚ä»£ç ç”Ÿæˆã€è°ƒç”¨cmake/clang/gcc/ndk-buildç­‰ç¼–è¯‘æ‰€ä¾èµ–çš„C/C++åº“ã€è¯»å–C/C++å¤´æ–‡ä»¶ç”ŸæˆFFIæ–‡ä»¶ç»™Rusté¡¹ç›®ä½¿ç”¨ç­‰ç­‰ï¼Œç›¸å½“äºRustå†™çš„shellè„šæœ¬

å…ˆäº cargo build è¢«ç¼– è¯‘

```rs

```

## é¡¹ç›®ç®¡ç†æ¡ˆä¾‹

### å¯¼å‡ºè‡ªå®šä¹‰å®

`cargo new --bin hello_macro`, æ–°å»º lib.rs (åå­—ä»»æ„), å®šä¹‰ macro, å¯¼å‡º

```rs
#[macro_export]
macro_rules! map {
    // ç»Ÿè®¡ item ä¸ªæ•°æ—¶ä½¿ç”¨çš„å•ä½, è¿™é‡Œä½¿ç”¨ ç©ºå…ƒç»„, ä¸å ç©ºé—´
    // @unit æ˜¯çº¦å®šä¿—æˆçš„åœ¨å®å†…éƒ¨å®šä¹‰å®çš„å‘½åè§„åˆ™
    // å¿…é¡»å®šä¹‰åœ¨å¼€å¤´æ¡, å¦åˆ™å°±æŒ‰ç…§æ™®é€šåŒ¹é…åˆ†æ”¯å¤„ç†äº†
    (@unit $($x:tt)*) => {()};
    (@count $($key:expr),* ) => {
        (<[()]>::len(&[$(map!(@unit $key)),*]));
    };

    ($($key:expr => $value:expr),* $(,)*) => (
        {
            let _cap = map!(@count $($key),*);
            let mut _map = std::collections::HashMap::with_capacity(_cap);
           $(
               _map.insert($key, $value);
           )*
           _map
       }
    )
}

```

åœ¨ main.rs ä¸­å¯¼å…¥ä½¿ç”¨

```rs
// #[macro_use] extern crate hello_async; 
// or
use hello_macro::map;

fn main() {
    let map = map!(
        1 => "a",
        2 => "b",
    );
    println!("{:?}", map);
}






// å¯¼å‡ºåŒä¸ªåŒ…ä¸‹, å…¶ä»– mod å†…çš„å®
#[macro_use]
mod macros {
     macro_rules! xxx {...}
     macro_rules! yy {..}
}
fn main() {
    // ç›´æ¥ä½¿ç”¨
    xxx!(...);
}

```


### å¯¼å…¥è‡ªå®šä¹‰ crate


`cargo new web-server`

`cd web-server`

`cargo new --lib thread-pool`

ä¿®æ”¹ web-server çš„ cargo.toml:

```t
[dependencies]
thread-pool = {path = "./thread-pool" } # å¿…é¡»ä¸º thread-pool, å’Œåº“åä¸€è‡´; thread_pool é”™è¯¯, threadpoolé”™è¯¯
                                    # ä½¿ç”¨: use thread_pool::xxxx (å˜ä¸ºä¸‹åˆ’çº¿)
```

### æ‰§è¡Œå­ç›®å½•ä¸­çš„ module

```t

[[example]]
name = "udp_server"
path = "examples/udp_server.rs"

[[example]]
name = "udp_client"
path = "examples/udp_client.rs"

[[example]]
name = "tcp_server"
path = "examples/tcp_server.rs"

[[example]]
name = "tcp_client"
path = "examples/tcp_client.rs"

```

ç„¶ååœ¨ /examples ä¸‹æ–°å»º rs æ–‡ä»¶, å†™ main æ–¹æ³•å³å¯


### å¯¼å…¥è‡ªå®šä¹‰ module

```rust
//ferris_says  ä¸ºè‡ªå®šä¹‰ module

mod ferris_says; // æ–¹æ³• 1: é€šè¿‡å£°æ˜å¯¼å…¥ module
use ferris_says::say;// æ–¹æ³• 2: å¯¼å…¥æ¨¡å—çš„æ–¹æ³•  // æ”¯æŒ as , å¦‚ use xxx as yyy
use std::io::{stdout, BufWriter}; 

fn demo() {
    let stdout = stdout();
    let message = String::from("Hello fellow Rustaceans!");
    let width = message.chars().count();

    let mut writer = BufWriter::new(stdout.lock());
    say(message.as_bytes(), width, &mut writer).unwrap();
}
```

### å¯¼å…¥ç¬¬ä¸‰æ–¹ crate

```rs
// Rust 2015 ç‰ˆæœ¬çš„å†™æ³•
// åœ¨ Rust2018 ç‰ˆæœ¬ä¸­ï¼Œå¯ä»¥çœç•¥æ‰ extern erate, å› ä¸ºåœ¨ Cargo.toml ä¸­å·²ç»æ·»åŠ äº†ä¾èµ– 
// extern crate å£°æ˜åŒ…çš„åç§° æ˜¯ linked_listï¼Œ ç”¨çš„æ˜¯ä¸‹ç”»çº¿â€œ_â€ï¼Œ è€Œåœ¨ Cargo.tom! ä¸­ç”¨çš„æ˜¯è¿å­—ç¬¦"-"ã€‚è¿™æ˜¯æ€ä¹ˆå›äº‹å‘¢?å…¶å® Cargo é»˜è®¤ä¼šæŠŠè¿å­—ç¬¦è½¬æ¢æˆ ä¸‹ç”»çº¿ 
extern crate linked_listï¼Œ
```




# å•å…ƒæµ‹è¯•


```rust
/// å•å…ƒæµ‹è¯•
/// 
/// ä½¿ç”¨ cargo test è¿è¡Œ
/// 
/// è¿è¡ŒæŸä¸ªç‰¹å®šçš„æµ‹è¯•æ–¹æ³• cargo test test_any_panic
/// 
/// cargo test panic æ–¹æ³•åä¸­å«æœ‰ panic çš„æµ‹è¯•æ–¹æ³•ä¼šè¿è¡Œ
/// 


#[cfg(test)]// æ¡ä»¶ç¼–è¯‘ ï¼Œ å‘Šè¯‰ç¼–è¯‘å™¨åªåœ¨è¿è¡Œæµ‹è¯•( cargo test å‘½ä»¤)æ—¶æ‰ç¼–è¯‘æ‰§è¡Œ
mod tests {
    // æ³¨æ„è¿™ä¸ªæƒ¯ç”¨æ³•ï¼šåœ¨ tests æ¨¡å—ä¸­ï¼Œä»å¤–éƒ¨ä½œç”¨åŸŸå¯¼å…¥æ‰€æœ‰åå­—ã€‚
    use super::*;

    #[test]
    fn test_xx() {
        println!("hello unit test");
    }

    // æµ‹è¯• panic
    #[test]
    #[ignore] // å¿½ç•¥æµ‹è¯•, æˆ–è€…ä½¿ç”¨ cargo test -- --ignored å‘½ä»¤æ¥è¿è¡Œå®ƒä»¬ã€‚
    #[should_panic(expected = "assertion failed")] // å€’ç½®æˆ‘ä»¬çš„æµ‹è¯•ç»“æœ (å¦‚æœå‘ç”Ÿé”™è¯¯æµ‹è¯•å°†ä¼šæˆåŠŸå¹¶ä¸”å¦‚æœæ²¡æœ‰é”™è¯¯ä¼šå¤±è´¥), ä¸€èˆ¬ å’Œ `(expected = "assertion failed")` ä¸€èµ·ä½¿ç”¨
    fn test_any_panic() {
        divide_non_zero_result(1, 0);
    }

    // æµ‹è¯• å¸¦æœ‰è¾“å‡ºæ–‡æœ¬çš„panic
    #[test]
    #[should_panic(expected = "Divide result is zero")]
    fn test_specific_panic() {
        divide_non_zero_result(1, 10);
    
}



```




# äº¤å‰ç¼–è¯‘ and æ¡ä»¶ç¼–è¯‘

https://github.com/japaric/rust-cross#tldr-ubuntu-example
https://zhuanlan.zhihu.com/p/76611800
https://zhuanlan.zhihu.com/p/128626720




```rust
///æ¡ä»¶ç¼–è¯‘
/// 
/// cfg å±æ€§ï¼šåœ¨å±æ€§ä½ç½®ä¸­ä½¿ç”¨ #[cfg(...)]
///cfg! å®ï¼šåœ¨å¸ƒå°”è¡¨è¾¾å¼ä¸­ä½¿ç”¨ cfg!(...)
/// 
fn condition_compile() {
    // è¿™ä¸ªå‡½æ•°ä»…å½“ç›®æ ‡ç³»ç»Ÿæ˜¯ Linux çš„æ—¶å€™æ‰ä¼šç¼–è¯‘
    #[cfg(target_os = "linux")]
    fn are_you_on_linux() {
        println!("You are running linux!")
    }
    // è€Œè¿™ä¸ªå‡½æ•°ä»…å½“ç›®æ ‡ç³»ç»Ÿ **ä¸æ˜¯** Linux æ—¶æ‰ä¼šç¼–è¯‘
    #[cfg(not(target_os = "linux"))]
    fn are_you_on_linux() {
        println!("You are *not* running linux!")
    }

    are_you_on_linux();

    if cfg!(target_os = "linux") {
        println!("Yes. It's definitely linux!");
    } else {
        println!("Yes. It's definitely *not* linux!");
    }

    // è‡ªå®šä¹‰æ¡ä»¶
    //
    // `rustc --cfg some_condition custom.rs && ./custom`
    //
    // #[cfg(some_condition)]
    // fn conditional_function() {
    //     println!("condition met!")
    // }

    // conditional_function();
}

```




# å¹¶å‘

## é€šç”¨æ¦‚å¿µ

### è¿›ç¨‹ and çº¿ç¨‹

è¿›ç¨‹æ˜¯èµ„æºåˆ†é…çš„æœ€å°å•å…ƒï¼Œçº¿ç¨‹æ˜¯ç¨‹åºæ‰§è¡Œæ—¶çš„æœ€å°å•å…ƒ 

å¯ä»¥ä½¿ç”¨å¤šè¿›ç¨‹æ¥æä¾›å¹¶å‘ï¼Œæ¯”å¦‚ Master-Worker æ¨¡å¼ï¼Œç”± Master è¿›ç¨‹æ¥ç®¡ç† Worker å­è¿›ç¨‹ï¼Œ Worker å­è¿›ç¨‹æ‰§è¡Œä»»åŠ¡ ã€‚ Master å’Œ Worker ä¹‹é—´é€šå¸¸ä½¿ç”¨ Socket æ¥è¿›è¡Œè¿›ç¨‹é—´é€šä¿¡å¥½å¤„æ˜¯ç¨‹åºå¥å£®, ç¼ºç‚¹æ˜¯è€—è´¹èµ„æº

ä½¿ç”¨çº¿ç¨‹æä¾›å¹¶å‘, å ç”¨èµ„æºå°‘, ä½†æ˜¯ç¼–ç¨‹è°ƒè¯•ç›¸å½“å¤æ‚

### äº‹ä»¶å›è°ƒå®ç°çš„å¼‚æ­¥å¹¶å‘

>å¤šè¿›ç¨‹/çº¿ç¨‹ å®ç°çš„å¹¶å‘, è¿˜æ˜¯æ— æ³•æ”¯æ’‘ä¸‡çº§åˆ«çš„å¹¶å‘è®¿é—®, å› ä¸ºå°±ç®—ä¸€ä¸ªçº¿ç¨‹å¤„ç†ä¸€ä¸ªè¿æ¥, ä¹Ÿè¦ä¸Šä¸‡çº¿ç¨‹, è¿™æ—¶å€™æœåŠ¡å™¨ä¹Ÿå´©äº†

äº‹ä»¶é©±åŠ¨å®ç°å¹¶å‘: åªæœ‰ä¸€ä¸ªçº¿ç¨‹, ä¸æ–­ä»äº‹ä»¶é˜Ÿåˆ—ä¸­æŸ¥è¯¢æ˜¯å¦æœ‰äº‹ä»¶å‘ç”Ÿ, è‹¥æœ‰, åˆ™è°ƒç”¨å…³è”çš„å›è°ƒå‡½æ•°, æ•´ä¸ªè¿‡ç¨‹æ˜¯éé˜»å¡çš„

1. ä¸ºäº†è§£å†³å›è°ƒåœ°ç‹±çš„é—®é¢˜, æ–°çš„æ–¹æ¡ˆå‡ºç°äº† --> Promise, Future, promise ç«™åœ¨ä»»åŠ¡å¤„ç†è€…çš„è§’åº¦ï¼Œå°†å¼‚æ­¥ä»»åŠ¡å®Œæˆæˆ–å¤±è´¥çš„ çŠ¶æ€æ ‡è®°åˆ° Promise å¯¹è±¡ä¸­ ã€‚ Future åˆ™ç«™åœ¨ä»»åŠ¡è°ƒç”¨è€…çš„è§’åº¦ï¼Œæ¥æ£€æµ‹ä»»åŠ¡æ˜¯å¦å®Œæˆï¼Œå¦‚æœ å®Œæˆåˆ™ç›´æ¥è·å–ç»“æœï¼Œå¦‚æœæœªå®Œæˆåˆ™é˜»å¡ç›´åˆ°è·å–åˆ°ç»“æœ ï¼Œ æˆ–è€…ç¼–å†™å›è°ƒå‡½æ•°é¿å…é˜»å¡

1. ä¸ºäº†è¿›ä¸€æ­¥è§£å†³ä»£ç å†—ä½™ ---> åç¨‹: æè¿°äº†ä¸€ç§ä»»åŠ¡ååŒæ‰§è¡Œçš„æ–¹å¼, åªæœ‰ä¸€ä¸ªçº¿ç¨‹, åŒæ—¶å¤„ç†å¤šä¸ªä»»åŠ¡, ä¸€ä¸ªæ—¶é—´ç‰‡åœ¨æ‰§è¡Œä»»åŠ¡ 1, æŸä¸ªæ—¶é—´ç‰‡åˆåˆ‡åˆ°æ‰§è¡Œä»»åŠ¡ 2, çœ‹èµ·æ¥å°±å¥½åƒä»»åŠ¡ 1,2 åŒæ—¶åœ¨æ‰§è¡Œ (æ•´ä¸ªæ¦‚å¿µç±»ä¼¼ CPU å¯¹çº¿ç¨‹çš„è°ƒåº¦æ–¹å¼)

    æ€»çš„æ¥è¯´ï¼Œåç¨‹å¯ä»¥è®©å¼€å‘è€…ç”¨å†™åŒæ­¥(é¡ºåº)ä»£ç çš„æ–¹ å¼ç¼–å†™å¯å¼‚æ­¥æ‰§è¡Œçš„ä»£ç  

    åç¨‹æ˜¯ä»¥çº¿ç¨‹ä¸ºå®¹å™¨çš„ï¼Œ åç¨‹çš„ç‰¹ç‚¹æ˜¯å†…å­˜å ç”¨æ¯”çº¿ç¨‹æ›´å°ã€ä¸Šä¸‹æ–‡åˆ‡æ¢çš„å¼€é”€æ›´å°, ä¹Ÿè¢«ç§°ä¸ºç”¨æˆ· æ€çº¿ç¨‹ï¼Œæ‰€ä»¥å¯å¤§é‡ä½¿ç”¨

    è™½ç„¶å……åˆ†æŒ–æ˜äº†å•çº¿ç¨‹çš„åˆ©ç”¨ç‡ï¼Œåœ¨ å•çº¿ç¨‹ä¸‹å¯ä»¥å¤„ç†é«˜å¹¶å‘ioï¼Œä½†å´æ— æ³•åˆ©ç”¨å¤šæ ¸, å› ä¸ºå§‹ç»ˆåªæœ‰ä¸€ä¸ªçº¿ç¨‹ã€‚

## çº¿ç¨‹åŸºæœ¬ä½¿ç”¨

### åˆ›å»ºçº¿ç¨‹

```rust
/// å¹¶å‘ é—­åŒ…
/// Rust ä¸­é€šè¿‡ std::thread::spawn å‡½æ•°åˆ›å»ºæœ¬åœ°æ“ä½œç³»ç»Ÿï¼ˆnative OSï¼‰çº¿ç¨‹
/// 
/// spawn() è¿”å›æ–°çº¿ç¨‹çš„å¥æŸ„ï¼ˆhandleï¼‰ï¼Œæˆ‘ä»¬å¿…é¡»æ‹¥æœ‰å¥æŸ„ï¼Œæ‰èƒ½è·å–çº¿ç¨‹çš„è¿”å›å€¼, é€šè¿‡ handle.join().unwrap();
// 
// 
/// 
fn concurrent() {
    use std::thread;
    use std::time::Duration;

    // åˆ›å»º
    // 
    // æ™®é€šå‡½æ•°çš„å†™æ³•, ä¸æ¨èå†™æ³•
    //
    fn spawn_function() {
        for i in 0..5 {
            println!("spawned thread print {}", i);
            thread::sleep(Duration::from_millis(1));
        }
    }
    let t = thread::spawn(spawn_function);

    //
    // é—­åŒ…çš„å†™æ³•
    let t = thread::spawn(|| {
        for i in 0..5 {
            println!("spawned thread print {}", i);
            thread::sleep(Duration::from_millis(1));// ç¡çœ 
        }
    });

    t.join().unwrap();// ç­‰å¾…çº¿ç¨‹ç»“æŸ or è·å–è¿”å›å€¼



    //move å¼ºåˆ¶æ‰€æœ‰æƒè¿ç§»
    //
    //åœ¨å­çº¿ç¨‹ä¸­å°è¯•ä½¿ç”¨å½“å‰å‡½æ•°çš„èµ„æº, è¿™ä¸€å®šæ˜¯é”™è¯¯çš„
    // éœ€è¦ä½¿ç”¨ move, å°†èµ„æºæ‰€æœ‰æƒç§»åŠ¨åˆ°å­çº¿ç¨‹å†…éƒ¨ä½¿å¾—å¤–éƒ¨èµ„æºå¤±æ•ˆ
    //
    
    // let s = "hello"; // è‹¥æ˜¯ &str ç±»å‹, åˆ™ move æ‰§è¡Œçš„æ˜¯ copy, é—­åŒ…å¤–å±‚ s è¿˜æ˜¯æœ‰æ•ˆçš„
    let s = "hello".to_owned();// è‹¥ä¸º String, åˆ™ move æ‰§è¡Œ ç§»åŠ¨è¯­ä¹‰, s å¤±æ•ˆ
   
    let handle = thread::spawn(move || {// ä¸€å®šè¦åŠ  move
        println!("sub thread, s = {}", s);
    });
    // é”™è¯¯, så·²ç» å¤±æ•ˆäº†
    println!("main thread, s= {}", s);
    handle.join().unwrap();


}

```

### è‡ªå®šä¹‰é…ç½®çº¿ç¨‹


```rs

// è®¾ç½®çº¿ç¨‹æ ˆ, çº¿ç¨‹å
// 
 // ç›´æ¥ä½¿ç”¨ thread::spawnç”Ÿæˆçš„çº¿ç¨‹ï¼Œ é»˜è®¤æ²¡æœ‰åç§°ï¼Œ å¹¶ä¸”å…¶æ ˆå¤§å°é»˜è®¤ä¸º 2MB (å…¶å®åº•å±‚è¿˜æ˜¯é€šè¿‡ builder åˆ›å»ºçš„)
    // ä½¿ç”¨ thread::Builder ç»“æ„ä½“æ¥åˆ›å»ºå¯é…ç½®çš„çº¿ ç¨‹, ä¸»çº¿ç¨‹æ— æ³•é…ç½®, å’Œ rust æ— å…³, å› ä¸ºä¸»çº¿ç¨‹é»˜è®¤ä½¿ç”¨ è¿›ç¨‹çš„æ ˆ, ç”±æ“ä½œç³»ç»Ÿå†³å®š
    // ä¹Ÿå¯ä»¥é€šè¿‡æŒ‡å®šç¯å¢ƒå˜ é‡ RUST_MIN_STACK  è®¾ç½®æ–°åˆ›å»ºçš„çº¿ç¨‹çš„çº¿ç¨‹æ ˆ, ä¼šè¢« builder è¦†ç›–
    // 
    // 
use std::{panic::catch_unwind, thread::{Builder, current}};
fn main() {
    let mut ths = vec![];
    for id in 0..3 {
        let thread_builder = Builder::new()
            .name(format!("child-{}", id))
            // unit: byte
            .stack_size(3 * 1024);
        let child = thread_builder.spawn(move || {
            println!("child id = {}", id);
            if id == 2 {
                // panic!("panic.");
                catch_unwind(|| {
                    panic!("panic.");
                }).unwrap();
                println!("catch panic in {}", current().name().unwrap());
                
            }
        }).unwrap();
        ths.push(child);
    }
    for t in ths {
        t.join().unwrap();
    }
}

```

### çº¿ç¨‹æœ¬åœ°å˜é‡


```rs
// çº¿ç¨‹æœ¬åœ°å˜é‡
use std::cell::RefCell;
use std::thread;
fn main() {
    thread_local!(static FOO: RefCell<u32> = RefCell::new(1));
    FOO.with(|f| {
        assert_eq!(*f.borrow(), 1);
        *f.borrow_mut() = 2;
    });
    thread::spawn(|| {
       FOO.with(|f| {
           assert_eq!(*f.borrow(), 1);
           *f.borrow_mut() = 3;
       });
   });
   FOO.with(|f| {
       assert_eq!(*f.borrow(), 2);
   });
}


```

### æ‰‹åŠ¨é˜»å¡å”¤é†’

```rs
use std::thread;
use std::time::Duration;
fn main() {
    let parked_thread = thread::Builder::new()
        .spawn(|| {
            println!("Parking thread");
            // é˜»å¡
            // ä¹Ÿå¯ä»¥ é€šè¿‡ std::thread: :park_timeout æ¥æ˜¾ å¼æŒ‡å®šé˜»å¡è¶…æ—¶æ—¶é—´ 
            thread::park();
            println!("Thread unparked");
        }).unwrap();
   thread::sleep(Duration::from_millis(10));
   println!("Unpark the thread");
//    å”¤é†’
   parked_thread.thread().unpark();
   parked_thread.join().unwrap();
}

// æ­¤å¤–, è¿˜æœ‰ yield_now() è°¦è®©, è®©å‡º cpu æ§åˆ¶æƒ
```

## çº¿ç¨‹åŒæ­¥

### é”™è¯¯ç¤ºä¾‹

```rs
// åœ¨çº¿ç¨‹é—´ä¼ é€’å¯å˜å­—ç¬¦ä¸²
// 



// ç›´æ¥ä½¿ç”¨ String
use std::thread::spawn;
fn main() {
    let s = String::from("hello");
    for _i in 0..3 {
        // error
        spawn(move || {
            s.push_str("xxx");
        });
    }
}


// ä½¿ç”¨ Rc
use std::{rc::Rc, thread::spawn};
fn main() {
    // æƒ³åœ¨å¤šä¸ªçº¿ç¨‹ä¸­å…±äº«sï¼Œåˆ™éœ€è¦ä½¿ç”¨ã€‚ 
    // Rcå®ç°äº†!Send, ä¸å¯åœ¨çº¿ç¨‹é—´ä¼ é€’æ‰€æœ‰æƒ
    let mut s = Rc::new(String::from("hello"));
    for _i in 0..3 {
        let mut s_clone = s.clone();
        // error
        // spawn å‡½æ•°ä¼ å…¥çš„ é—­åŒ…æ²¡æœ‰å®ç° Sendï¼Œè¿™æ˜¯å› ä¸ºæ•è·å˜é‡æ²¡
        // æœ‰å®ç° Sendã€‚æ•è·å˜é‡æ˜¯ Rc<String>ç±»å‹ï¼Œ å®ç°çš„æ˜¯!Sendï¼Œæ­£å¥½å’Œ Sendç›¸å
        spawn(move || {
            s_clone.push_str("xxx");
        });
    }
}


// ä½¿ç”¨å¯ä»¥åœ¨å¤šçº¿ç¨‹é—´è¢«ç§»åŠ¨å’Œå…±äº«çš„ Arc<T>
use std::{sync::Arc, thread::spawn};
fn main() {
    let s = Arc::new(String::from("hello"));
    for _i in 0..3 {
        let s_clone = s.clone();
        // error
        // è¿™æ˜¯å› ä¸º Arc<T>é»˜è®¤æ˜¯ä¸å¯å˜çš„, è€ƒè™‘ä½¿ç”¨å…·æœ‰å†…éƒ¨å¯å˜æ€§çš„ç±»å‹, å¦‚ Cell/RefCell
        spawn(move || {
            s_clone.push_str("xxx");
        });
    }
}


// ä½¿ç”¨ RefCell æä¾›å†…éƒ¨å¯å˜æ€§
use std::{cell::RefCell, sync::Arc, thread::spawn};
fn main() {
    let s = Arc::new(RefCell::new(String::from("hello")));
    for _i in 0..3 {
        let s_clone = s.clone();
        // error
        // `RefCell<String>` cannot be shared between threads safely
        spawn(move || {
            let s_clone = s_clone.borrow_mut();
            s_clone.push_str("xxx");
        });
    }
}


// æ­£ç¡®æ–¹å¼: ä½¿ç”¨ Mutex
// 
use std::{sync::{Arc, Mutex}, thread::spawn};
fn main() {
    // Arc ç”¨äºæ”¯æŒå®‰å…¨çš„å¤šå¼•ç”¨
    // Mutex ç”¨äºå®‰å…¨çš„æä¾›å†…éƒ¨å¯å˜æ€§
    let s = Arc::new(Mutex::new(String::from("hello")));
    let mut ths = vec![];
    for _i in 0..3 {
        let s_ref = s.clone();
        let child = spawn(move || {
            let mut s_ref_mut = s_ref.lock().unwrap();
            s_ref_mut.push_str(" xxx");
        });
        ths.push(child);
    }
    for t in ths {
        t.join().unwrap();
    }
}


```


### é” 

```rs
// Mutex<T> äº’æ–¥é”: æ”¯æŒè·¨çº¿ç¨‹å®‰å…¨å…±äº«å¯å˜å˜é‡çš„å®¹å™¨, åŒæ—¶åªå…è®¸ä¸€ä¸ªçº¿ç¨‹è®¿é—®å†…éƒ¨ å¯å˜æ•°æ®, ç±»ä¼¼ çº¿ç¨‹å®‰å…¨ç‰ˆæœ¬çš„ RefCell
/// - lock() è¿”å›å†…éƒ¨æ•°æ®çš„å¯å˜å¼•ç”¨(é˜»å¡å½“å‰çº¿ç¨‹, ç›´åˆ°æ‹¿åˆ°é”)
//      è¿”å›å€¼ LockResult<MutexGuard<T>>, è¶…å‡ºä½œç”¨åŸŸä¼šè‡ªåŠ¨é‡Šæ”¾é”
// - try_lock() è·å– é”çš„æ—¶å€™ä¸ä¼šé˜»å¡å½“å‰çº¿ç¨‹, å¦‚æœå¾—åˆ°é” ï¼Œ å°±è¿”å› MutexGuard<T>; å¦‚æœå¾—ä¸åˆ°é”ï¼Œå°±è¿”å› Errã€‚
// 
/// RefCell<T>: ä½¿å¾—å†…éƒ¨æ•°æ®å¯å˜
//  Rc<T>: åŸå­å¼•ç”¨è®¡æ•° , å…è®¸å¤šå¼•ç”¨
// 
//  Arc<T> : çº¿ç¨‹å®‰å…¨çš„ Rc<T>, å…è®¸å¤šçº¿ç¨‹ä¸‹çš„å¤šå¼•ç”¨
/// Mutex<T> : çº¿ç¨‹å®‰å…¨çš„ RefCell, æä¾›å¤šçº¿ç¨‹ä¸‹å†…éƒ¨æ•°æ®çš„å¯å˜å¼•ç”¨
///

///
/// é€šé“éƒ½ç±»ä¼¼äºå•æ‰€æœ‰æƒï¼Œå› ä¸ºä¸€æ—¦å°†ä¸€ä¸ªå€¼ä¼ é€åˆ°é€šé“ä¸­ï¼Œå°†æ— æ³•å†ä½¿ç”¨è¿™ä¸ªå€¼ã€‚
/// é”ç±»ä¼¼äºå¤šæ‰€æœ‰æƒ: å¤šä¸ªçº¿ç¨‹å¯ä»¥è®¿é—®ç›¸åŒçš„å†…å­˜ä½ç½® , åªæ˜¯ä¸èƒ½åŒä¸€æ—¶å€™è®¿é—®
///
///
///
///
fn lock_demo() {

    // 
    // è®¡æ•°å™¨ç¤ºä¾‹
    // 
    use std::sync::{Mutex, Arc};
    use std::thread;
    // ä¸èƒ½ä»…ä»…ä½¿ç”¨ Mutex::new(0), å› ä¸ºæœ‰å¤šä¸ª Threadéœ€è¦å®ƒ, counterç§»åŠ¨è¿›å…¥æŸä¸ªThreadåå…¶ä»–Threadå°±æ²¡æ³•æ‹¥æœ‰counteräº†
    // ä¹Ÿä¸èƒ½ç”¨Rc::new(Mutex::new(0)), å› ä¸ºRc<T>çš„å¼•ç”¨è®¡æ•°, åœ¨å¤šçº¿ç¨‹ä¸‹ä¸å®‰å…¨
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        // or
        let counter = counter.clone();
        
        let handle = thread::spawn(move || {
            // lock() è¿™ä¸ªè°ƒç”¨ä¼šé˜»å¡å½“å‰çº¿ç¨‹, ç›´åˆ°è·å–é”ä¸ºæ­¢
            //
            //å¦‚æœå¦ä¸€ä¸ªçº¿ç¨‹æ‹¥æœ‰é”ï¼Œå¹¶ä¸”é‚£ä¸ªçº¿ç¨‹ panic äº†ï¼Œ
            // åˆ™æœ¬çº¿ç¨‹ lock è°ƒç”¨ä¼šå¤±è´¥ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ²¡äººèƒ½å¤Ÿå†è·å–é”ï¼Œ
            // æ‰€ä»¥è¿™é‡Œé€‰æ‹© unwrap åœ¨é‡åˆ°è¿™ç§æƒ…å†µæ—¶ä½¿çº¿ç¨‹ç›´æ¥ panic
            //
            //è¿”å› result, æ‹†åŒ…åæ˜¯ MutexGuard<T>, æ˜¯ä¸ªæ™ºèƒ½æŒ‡é’ˆ, å®ç°äº† Derefæ‰€ä»¥å¯ä»¥è§£å¼•ç”¨
            // å®ç°äº† Drop ,å½“ MutexGuard ç¦»å¼€ä½œç”¨åŸŸæ—¶è‡ªåŠ¨é‡Šæ”¾é”
            //
            let mut num = counter.lock().unwrap();
            // è§£å¼•ç”¨å, æ•°æ®æ˜¯å¯å˜çš„
            *num += 1;
        });
        handles.push(handle);
    }
    for handle in handles {
        handle.join().unwrap();
    }
    println!("Result: {}", *counter.lock().unwrap());



    // ä¸­æ¯’: çº¿ç¨‹åœ¨è·å¾—é”ä¹‹åå‘ç”Ÿææ…Œ
    // 
    let mutex = Arc::new(Mutex::new(1));
    let c_mutex = mutex.clone();
    let _ = thread::spawn(move || {
        let mut data = c_mutex.lock().unwrap();
        *data = 2;
        // å­çº¿ç¨‹ panic, ä¸­æ¯’äº†
        panic!("oh no");
   }).join();
//    æ˜¯å¦ä¸­æ¯’, å³æŸ¥çœ‹è·å–é”çš„å­çº¿ç¨‹æ˜¯å¦ panic
   assert_eq!(mutex.is_poisoned(), true);
//    ä¸»çº¿ç¨‹è·å–é”, å½“ç„¶è·å–ä¸åˆ°
   match mutex.lock() {
    //    ä¸å¯è¾¾
       Ok(_) => unreachable!(),
       Err(p_err) => {
        //    æä¾›äº† get_refæˆ– get_mutæ–¹æ³•, è·å–é”å†…éƒ¨çš„æ•°æ®
           let data = p_err.get_ref();
           println!("recovered: {}", data);//2
       }
   };


    // è¯»å†™é”
    // RwLock<T> æ”¯æŒå¤šä¸ªè¯»çº¿ç¨‹å’Œä¸€ä¸ªå†™çº¿ç¨‹åŒæ—¶è®¿é—® (ä¸åƒ Mutex<T>åªèƒ½çº¿ç¨‹ç‹¬å è®¿é—®)
    // 
    // åªè¦çº¿ç¨‹æ²¡æœ‰æ‹¿åˆ°å†™é” ï¼Œ RwLock<T>å°± å…è®¸ä»»æ„æ•°é‡ çš„è¯»çº¿ç¨‹è·å¾—è¯»é”
    // 
    let lock = RwLock::new(5);
    // è¯»é”å’Œ å†™é”è¦ä½¿ç”¨æ˜¾å¼ä½œç”¨åŸŸå—éš”ç¦»å¼€ ï¼Œè¿™æ ·çš„è¯ ï¼Œ è¯»é”æˆ–å†™é”æ‰èƒ½åœ¨ç¦»å¼€ä½œç”¨ åŸŸä¹‹åè‡ª åŠ¨é‡Šæ”¾ ; å¦åˆ™ä¼šå¼•èµ·æ­»é”ï¼Œå› ä¸ºè¯»é”å’Œå†™é”ä¸èƒ½åŒæ—¶å­˜åœ¨ 
    {
        // è·å–å¤šä¸ªè¯»é”
        let r1 = lock.read().unwrap();
        let r2 = lock.read().unwrap();
        assert_eq!(*r1, 5);
        assert_eq!(*r2, 5);
    } 
   {
    //    è·å–å†™é”
       let mut w = lock.write().unwrap();
       *w += 1;
       assert_eq!(*w, 6);
   }

}



// å±éšœ (ç±»ä¼¼ java çš„ CountDownLatch)
// 
use std::sync::{Arc, Barrier};
use std::thread;
fn main() {
    let mut handles = Vec::with_capacity(5);
    let barrier = Arc::new(Barrier::new(5));
    for _ in 0..5 {
        let c = barrier.clone();
        handles.push(thread::spawn(move|| {
            println!("before wait");
            // ä½¿å¾—å½“å‰å­çº¿ç¨‹é˜»å¡, çŸ¥é“ clone 5 æ¬¡å barrie å½’é›¶å, çº¿ç¨‹æ¢å¤æ‰§è¡Œ
           c.wait();
           println!("after wait");
       }));
   }
   for handle in handles {
       handle.join().unwrap();
   }
}

// æ¡ä»¶å˜é‡
// æ»¡è¶³æŒ‡å®šæ¡ä»¶ä¹‹å‰é˜»å¡æŸä¸€ä¸ªå¾—åˆ°äº’æ–¥é”çš„çº¿ç¨‹ 
// æ¡ä»¶å˜é‡éœ€è¦é…åˆäº’æ–¥é”æ‰èƒ½ä½¿ç”¨
// 
// - æ¯ä¸ªæ¡ä»¶å˜é‡æ¯æ¬¡åªèƒ½å’Œä¸€ä¸ªäº’æ–¥ä½“ä¸€èµ·ä½¿ç”¨
// - ä½¿ç”¨åœºæ™¯: å½“çŠ¶æ€æˆç«‹æ—¶é€šçŸ¥äº’æ–¥ä½“
use std::sync::{Arc, Condvar, Mutex};
use std::thread;
fn main() {
    let pair = Arc::new((Mutex::new(false), Condvar::new()));
    let pair_clone = pair.clone();
    thread::spawn(move || {
        let &(ref lock, ref cvar) = &*pair_clone;
        let mut started = lock.lock().unwrap();
        // ä¿®æ”¹é”å†…éƒ¨æ•°æ®
        *started = true;
        // é€šçŸ¥ä¸»çº¿ç¨‹
       cvar.notify_one();
   });
   let &(ref lock, ref cvar) = &*pair;
   let mut started = lock.lock().unwrap();
   while !*started {
       println!("{}", started); // false
        //é˜»å¡å½“å‰çº¿ç¨‹(ä¸»çº¿ç¨‹), ç›´åˆ°æ”¶åˆ°æ¡ä»¶å˜é‡çš„é€šçŸ¥
       started = cvar.wait(started).unwrap();
       println!("{}", started); // true
   }
}
```


### åŸå­ç±»å‹

```rs
// AtomicBoolã€ AtomicIsizeã€ AtomicPtr å’Œ AtomicUsize

// å®ç°è‡ªæ—‹é”
use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::thread;
fn main() {
    // åˆå§‹å€¼è®¾ç½®ä¸º 1
    let spinlock = Arc::new(AtomicUsize::new(1));
    let spinlock_clone = spinlock.clone();
    let thread = thread::spawn(move|| {
        // ä¿®æ”¹ä¸º 0;
        // åŒæ—¶æŒ‡å®šå†…å­˜é¡ºåº
        spinlock_clone.store(0, Ordering::SeqCst);
    });
    // è‹¥ä¸ä¸º 0, åˆ™è‡ªæ—‹
   while spinlock.load(Ordering::SeqCst) != 0 {}
//    é˜»å¡ä¸»çº¿ç¨‹, ç­‰å¾…å­çº¿ç¨‹å®Œæˆ
   if let Err(panic) = thread.join() {
       println!("Thread had an error: {:?}", panic);
   }
}
```




### channel



```rust


/// channel æ¶ˆæ¯ä¼ é€’
/// 
/// å…·ä½“å®ç°å®é™…ä¸Šæ˜¯ä¸€ä¸ª å¤šç”Ÿäº§è€…å•æ¶ˆè´¹è€… (Multi-Producer-Single-Consumer, MPSC) çš„å…ˆè¿›å…ˆå‡º(FIFOã€• é˜Ÿåˆ—, åº•å±‚åŸºäºé“¾è¡¨å®ç°
// 
// ä¸‰ç§ç±»å‹çš„csp è¿›ç¨‹:
// - Sender ç”¨äºå‘é€å¼‚æ­¥æ¶ˆæ¯
// - SyncSender å‘é€åŒæ­¥æ¶ˆæ¯
// - Receiveræ¥æ”¶æ¶ˆæ¯
// 
// ä¸¤ç§ç±»å‹çš„ channel
// - å¼‚æ­¥æ— ç•Œ Channel -  let (sender, receiver):  (Sender, Receiver) = channel(); å‘é€æ¶ˆæ¯æ˜¯å¼‚æ­¥æ— é˜»å¡çš„, ç¼“å†²åŒºæ— é™å¤§
// - åŒæ­¥æœ‰ç•Œ Channel -  let (sender, receiver):  (SyncSender, Receiver) = sync_channel(size);å¯ä»¥é¢„åˆ†é…å…·æœ‰å›ºå®šå¤§å°çš„ç¼“å†²åŒº , æ»¡äº†å°±é˜»å¡æ¶ˆæ¯å‘é€, è‹¥ç¼“å†²åŒº == 0, senderå’Œ receiver é—´å˜ä¸ºåŸå­æ“ä½œ
// 
fn channel_demo() {
    
    //ä¸€ä¸ªå‘é€è€…ï¼ˆtransmitterï¼‰å’Œä¸€ä¸ªæ¥æ”¶è€…ï¼ˆreceiverï¼‰

    use std::sync::mpsc;// mpsc æ˜¯ å¤šä¸ªç”Ÿäº§è€…ï¼Œå•ä¸ªæ¶ˆè´¹è€…ï¼ˆmultiple producer, single consumerï¼‰çš„ç¼©å†™
    use std::thread;
    // tx: å‘é€è€…
    // rx : æ¥æ”¶è€…
    // æ­¤æ—¶è¿˜æ— æ³•ç¼–è¯‘, å› ä¸º Rust ä¸çŸ¥é“æˆ‘ä»¬æƒ³è¦åœ¨é€šé“ä¸­å‘é€ä»€ä¹ˆç±»å‹, åç»­ç¼–è¯‘å™¨èƒ½å¤Ÿè‡ªåŠ¨æ¨æ–­ç±»å‹
    let (tx, rx) = mpsc::channel();

    //åˆ›å»ºä¸€ä¸ªæ–°çº¿ç¨‹ä½œä¸ºå‘é€è€…
    // 
    // //ä½¿ç”¨ move å°† tx ç§»åŠ¨åˆ°é—­åŒ…ä¸­è¿™æ ·æ–°å»ºçº¿ç¨‹å°±æ‹¥æœ‰ tx äº†, å½“
    // å‘é€è€…æ‰§è¡Œå®Œé€»è¾‘, é€€å‡ºä½œç”¨åŸŸ, tx ä¹Ÿå°±è‡ªåŠ¨ææ„äº†, æ¥æ”¶ç«¯ä¹Ÿå°±æ”¶åˆ°å…³é—­çš„ä¿¡å·
    // (è‹¥æ²¡æœ‰ ä½¿ç”¨ move, tx å§‹ç»ˆå­˜æ´», æ— æ³•è‡ªåŠ¨ææ„, ä¼šé€ æˆ æ¥æ”¶è€…å§‹ç»ˆé˜»å¡)
    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });

    // æ¥æ”¶
    // 
    //è¿™ä¸ªæ–¹æ³•ä¼šé˜»å¡ä¸»çº¿ç¨‹æ‰§è¡Œç›´åˆ°ä»é€šé“ä¸­æ¥æ”¶ä¸€ä¸ªå€¼, 
    //å½“é€šé“å‘é€ç«¯å…³é—­ï¼Œrecv ä¼šè¿”å›ä¸€ä¸ªé”™è¯¯è¡¨æ˜ä¸ä¼šå†æœ‰æ–°çš„å€¼åˆ°æ¥äº†
    //
    //try_recv ä¸ä¼šé˜»å¡ï¼Œç›¸åå®ƒç«‹åˆ»è¿”å›ä¸€ä¸ª Result<T, E>ï¼šOk å€¼åŒ…å«å¯ç”¨çš„ä¿¡æ¯ï¼Œè€Œ Err å€¼ä»£è¡¨æ­¤æ—¶æ²¡æœ‰ä»»ä½•æ¶ˆæ¯
    //å¯ä»¥ç¼–å†™ä¸€ä¸ªå¾ªç¯æ¥é¢‘ç¹è°ƒç”¨ try_recvï¼Œåœ¨æœ‰å¯ç”¨æ¶ˆæ¯æ—¶è¿›è¡Œå¤„ç†ï¼Œå…¶ä½™æ—¶å€™åˆ™å¤„ç†ä¸€ä¼šå…¶ä»–å·¥ä½œç›´åˆ°å†æ¬¡æ£€æŸ¥
    //
    let received = rx.recv().unwrap();
    println!("Got: {}", received);

    //ä¹Ÿå¯ä»¥è¿­ä»£æ¥æ”¶å™¨, å½“é€šé“è¢«å…³é—­æ—¶ï¼Œè¿­ä»£å™¨ä¹Ÿå°†ç»“æŸ
    //
    for received in rx {// æˆ–è€… rx.iter()
        println!("Got: {}", received);
    }






    //é€šè¿‡å…‹éš†å‘é€è€…æ¥åˆ›å»ºå¤šä¸ªç”Ÿäº§è€…
    //
    // 
    use std::sync::mpsc::{Sender, Receiver};
    static NTHREADS: i32 = 3;

    let (tx, rx): (Sender<i32>, Receiver<i32>) = mpsc::channel();// æ‰‹åŠ¨æŒ‡å®šä¼ è¾“æ•°æ®çš„ç±»å‹

    for id in 0..NTHREADS {
        // sender ç«¯å¯è¢«å¤åˆ¶
        let thread_tx = tx.clone();
        // æˆ–è€…
        let tx1 = mpsc::Sender::clone(&tx);


        thread::spawn(move || {
            // è¢«åˆ›å»ºçš„çº¿ç¨‹å–å¾— `thread_tx` çš„æ‰€æœ‰æƒ
            thread_tx.send(id).unwrap();
            println!("thread {} finished", id);
        });
    }

    let mut ids = Vec::with_capacity(NTHREADS as usize);
    for _ in 0..NTHREADS {
        // è‹¥æ— å¯ç”¨æ¶ˆæ¯çš„è¯ï¼Œ`recv` å°†é˜»æ­¢å½“å‰çº¿ç¨‹
        ids.push(rx.recv());
    }

    // æ˜¾ç¤ºæ¶ˆæ¯è¢«å‘é€çš„æ¬¡åº
    println!("{:?}", ids);
}


```


## å¤šçº¿ç¨‹å°ä¾‹å­

### å®ç°çº¿ç¨‹æ± 

ç¬¬ä¸‰æ–¹åŒ…: threadpool

è¿™é‡Œæ‰‹åŠ¨å®ç°

```rs

```

### å®ç° map-reduce ç®—æ³•


```rust


    //ä¾‹å­:
    //å®ç° map-reduce ç®—æ³•
    //
    let data = "86967897737416471853297327050364959
11861322575564723963297542624962850
70856234701860851907960690014725639
38397966707106094172783238747669219
52380795257888236525459303330302837
58495327135744041048897885734297812
69920216438980873548808413720956532
16278424637452589860345374828574668";

     // åˆ›å»ºä¸€ä¸ªå‘é‡ï¼Œç”¨äºå‚¨å­˜å°†è¦åˆ›å»ºçš„å­çº¿ç¨‹
    let mut children = vec![];

    let chunked_data = data.split_whitespace();
    for (i, data_segment) in chunked_data.enumerate() {
        println!("data segment {} is \"{}\"", i, data_segment);

        children.push(thread::spawn(move || -> u32 {
            // è®¡ç®—è¯¥æ®µçš„æ¯ä¸€ä½çš„å’Œï¼š
            let result = data_segment
                        // å¯¹è¯¥æ®µä¸­çš„å­—ç¬¦è¿›è¡Œè¿­ä»£..
                        .chars()
                        // ..æŠŠå­—ç¬¦è½¬æˆæ•°å­—..
                        .map(|c| c.to_digit(10).expect("should be a digit"))
                        // ..å¯¹è¿”å›çš„æ•°å­—ç±»å‹çš„è¿­ä»£å™¨æ±‚å’Œ
                        .sum();

            // println! ä¼šé”ä½æ ‡å‡†è¾“å‡ºï¼Œè¿™æ ·å„çº¿ç¨‹æ‰“å°çš„å†…å®¹ä¸ä¼šäº¤é”™åœ¨ä¸€èµ·
            println!("processed segment {}, result={}", i, result);

            // ä¸éœ€è¦ â€œreturnâ€ï¼Œå› ä¸º Rust æ˜¯ä¸€ç§ â€œè¡¨è¾¾å¼è¯­è¨€â€ï¼Œæ¯ä¸ªä»£ç å—ä¸­
            // æœ€åæ±‚å€¼çš„è¡¨è¾¾å¼å°±æ˜¯ä»£ç å—çš„å€¼ã€‚
            result

        }));
    }

    // æŠŠæ¯ä¸ªçº¿ç¨‹äº§ç”Ÿçš„ä¸­é—´ç»“æœæ”¶å…¥ä¸€ä¸ªæ–°çš„å‘é‡ä¸­
    let mut intermediate_sums = vec![];
    for child in children {
        // æ”¶é›†æ¯ä¸ªå­çº¿ç¨‹çš„è¿”å›å€¼
        let intermediate_sum = child.join().unwrap();
        intermediate_sums.push(intermediate_sum);
    }

    let final_result = intermediate_sums.iter().sum::<u32>();
    println!("Final sum result: {}", final_result);

```

### å¤šçº¿ç¨‹ç»Ÿè®¡å’Œ


```rust

    // 
    //
    //
    const TOTAL_SIZE:usize = 100 * 1000; //æ•°ç»„é•¿åº¦
    const NTHREAD:usize = 6; //çº¿ç¨‹æ•°
    let data : Vec<i32> = (1..(TOTAL_SIZE+1) as i32).collect(); //åˆå§‹åŒ–ä¸€ä¸ªæ•°æ®ä»1åˆ°næ•°ç»„
    let arc_data = Arc::new(data); //data çš„æ‰€æœ‰æƒè½¬ç»™äº† ar_data
    let result  = Arc::new(AtomicU64::new(0)); //æ”¶é›†ç»“æœçš„æ•°ç»„(åŸå­æ“ä½œ)
    let mut thread_handlers = vec![]; // ç”¨äºæ”¶é›†çº¿ç¨‹å¥æŸ„
    for i in 0..NTHREAD {
        // clone Arc å‡†å¤‡moveåˆ°çº¿ç¨‹ä¸­ï¼Œåªå¢åŠ å¼•ç”¨è®¡æ•°ï¼Œä¸ä¼šæ·±æ‹·è´å†…éƒ¨æ•°æ®
        let test_data = arc_data.clone(); 
        let res = result.clone(); 
        thread_handlers.push( 
            thread::spawn(move || {
                let id = i;
                //æ‰¾åˆ°è‡ªå·±çš„åˆ†åŒº
                let chunk_size = TOTAL_SIZE / NTHREAD + 1;
                let start = id * chunk_size;
                let end = std::cmp::min(start + chunk_size, TOTAL_SIZE);
                //è¿›è¡Œæ±‚å’Œè¿ç®—
                let mut sum = 0;
                for  i in start..end  {
                    sum += test_data[i];
                }
                //åŸå­æ“ä½œ
                res.fetch_add(sum as u64, Ordering::SeqCst);
                println!("id={}, sum={}", id, sum );
            }
        ));
    }
    //ç­‰æ‰€æœ‰çš„çº¿ç¨‹æ‰§è¡Œå®Œ
    for th in thread_handlers {
        th.join().expect("The sender thread panic!!!");
    }
    //è¾“å‡ºç»“æœ
    println!("result = {}",result.load(Ordering::SeqCst));
```


### å¸¦çº¿ç¨‹æ± çš„ webserver


main.rs æ˜¯é¡¹ç›®å¯åŠ¨å…¥å£

lib.rs ä¸º é¡¹ç›®å†…éƒ¨çš„ å­åº“

main.rs :

```rs
mod lib;

use std::net::{TcpListener, TcpStream};
use std::io::{Read, Write};
use std::fs::read_to_string;
use std::thread;
use std::time::Duration;
use thread_pool::ThreadPool;// æ¨ªçº¿å˜ä¸ºä¸‹åˆ’çº¿äº†

fn main() {
    let listener = TcpListener::bind("127.0.0.1:8080").unwrap();
    let pool = ThreadPool::new(4);
    for stream in listener.incoming().take(2) {
        match stream {
            Ok(stream) => {
                pool.execute(|| {
                    handle_conn_quick(stream);
                });
                // handle_conn_quick(stream);
            }
            Err(_) => eprintln!("error of connection"),
        }
    }
}

// 
fn handle_conn_quick(mut stream: TcpStream) {
    let mut buf = [0u8; 512];
    stream.read(&mut buf).unwrap();

    println!("************** req ***************");
    println!("{}\n", String::from_utf8_lossy(&buf));

    let get = b"GET / HTTP/1.1\r\n";
    let sleep = b"GET /sleep HTTP/1.1\r\n";
    let (status_line, html_path) = if buf.starts_with(get) {
        ("HTTP/1.1 200 OK\r\n\r\n", "resources/hello.html")// ç›¸å¯¹äºæ ¹è·¯å¾„
    } else if buf.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        ("HTTP/1.1 200 OK\r\n\r\n", "resources/hello.html")
    }
    else {
        ("HTTP/1.1 404 NOT FOUND\r\n\r\n", "resources/404.html")
    };
    let resp = format!("{}{}", status_line, read_to_string(html_path).unwrap());

    println!("************** resp ***************");
    println!("{}\n", resp);

    stream.write(resp.as_bytes()).unwrap();
    stream.flush().unwrap();
}


//  è¿™æ˜¯å•çº¿ç¨‹ webserver çš„ä»£ç 
#[allow(dead_code)]
fn handle_conn(mut stream: TcpStream) {
    let mut buf = [0u8; 1024];
    let mut content = String::new();
    loop {
        let len = stream.read(&mut buf).unwrap();
        content.push_str(&String::from_utf8_lossy(&buf)[..]);
        if len < buf.len() {
            break;
        }
    }

    let get = "GET / HTTP/1.1\r\n";
    let (status_line, html_path) = if content.starts_with(get) {
        ("HTTP/1.1 200 OK\r\n\r\n", "resources/hello.html")
    } else {
        ("HTTP/1.1 404 NOT FOUND\r\n\r\n", "resources/404.html")
    };

    let html = read_to_string(html_path).unwrap();
    let resp = format!("{}{}", status_line, html);
    stream.write(resp.as_bytes()).unwrap();
    stream.flush().unwrap();
}


```



lib.rs:

```rs
use std::thread::{JoinHandle, spawn};
use std::sync::mpsc::{Sender, channel, Receiver};
use std::sync::{Arc, Mutex};

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}

pub struct ThreadPool {
    // è¦å®ç°çš„è¡Œä¸ºæ˜¯åˆ›å»ºçº¿ç¨‹å¹¶ç¨åå‘é€ä»»åŠ¡ä»£ç 
    // æ‰€ä»¥ä¸èƒ½ç›´æ¥å­˜ Thread, è€Œè¦å¼•å…¥ä¸­é—´å±‚ worker
    // è‹¥ç›´æ¥ä½¿ç”¨ Thread, åˆ›å»ºçº¿ç¨‹å, ä»»åŠ¡ä¼šç›´æ¥ç«‹å³æ‰§è¡Œ, ä¸è¡Œ
    workers: Vec<Worker>,
    sender: Sender<Msg>,
}

impl Drop for ThreadPool {
    fn drop(&mut self) {
        // å‘æ¯ä¸ª workerå‘é€ç»ˆæ­¢æ¶ˆæ¯, ä½¿å¾—ä»»åŠ¡ä»£ç è·³å‡ºreceiveå¾ªç¯
        // ä¸ºä»€ä¹ˆè¦åˆ†ä¸ºä¸¤ä¸ªforå¾ªç¯?
        //å¦‚æœå°è¯•åœ¨åŒä¸€å¾ªç¯ä¸­å‘é€æ¶ˆæ¯å¹¶ç«‹å³ join çº¿ç¨‹ï¼Œåˆ™æ— æ³•ä¿è¯å½“å‰è¿­ä»£çš„ worker æ˜¯ä»é€šé“æ”¶åˆ°ç»ˆæ­¢æ¶ˆæ¯çš„ worker
        for _ in &mut self.workers {
            self.sender.send(Msg::TerminateMsg).unwrap();
        }
        for w in &mut self.workers {// éœ€è¦è·å–workersçš„å¯å˜å¼•ç”¨
            println!("worker {} stop", w.id);
            // join è°ƒç”¨è€…éœ€è¦æ˜¯ éå¼•ç”¨
            // é‚£ä¹ˆ, éœ€è¦ä¸€ä¸ªæ–¹æ³•å°† thread ç§»åŠ¨å‡ºæ‹¥æœ‰å…¶æ‰€æœ‰æƒçš„ Worker å®ä¾‹ä»¥ä¾¿ join å¯ä»¥æ¶ˆè´¹è¿™ä¸ªçº¿ç¨‹ã€‚
            //
            // w.thread.join().unwrap();
            if let Some(thread) = w.thread.take() {//take æ–¹æ³•ä¼šå–å‡º Some è€Œç•™ä¸‹ None
                thread.join().unwrap();
            }
        }
    }
}

enum Msg {
    JobMsg(Job),
    TerminateMsg,
}

type Job = Box<dyn FnOnce() + Send + 'static>;

impl ThreadPool {
    /// åˆ›å»ºçº¿ç¨‹æ± ã€‚
    ///
    /// # Panics
    ///
    /// `new` å‡½æ•°åœ¨ size ä¸º 0 æ—¶ä¼š panicã€‚
    pub fn new(size: usize) -> Self {
        assert!(size > 0);

        let mut workers = Vec::with_capacity(size);

        let (sender, receiver) = channel();
        let receiver = Arc::new(Mutex::new(receiver));

        //å¤š ç”Ÿäº§è€…ï¼Œå• æ¶ˆè´¹è€… çš„ã€‚è¿™æ„å‘³ç€ä¸èƒ½ç®€å•çš„å…‹éš†é€šé“çš„æ¶ˆè´¹ç«¯æ¥è§£å†³é—®é¢˜
        //æˆ‘ä»¬å¸Œæœ›é€šè¿‡åœ¨æ‰€æœ‰çš„ worker ä¸­å…±äº«å•ä¸€ receiverï¼Œåœ¨çº¿ç¨‹é—´åˆ†å‘ä»»åŠ¡
        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&receiver)));
        }

        ThreadPool {
            workers,
            sender,
        }
    }

    pub fn execute<F>(&self, f: F)
        // æ²¡å‚æ•°, æ²¡è¿”å›å€¼çš„é—­åŒ…
        where F: FnOnce() + Send + 'static
    {
        let job = Box::new(f);
        self.sender.send(Msg::JobMsg(job)).unwrap();
    }
}

struct Worker {
    id: usize,
    thread: Option<JoinHandle<()>>,// "()" è¡¨ç¤ºçº¿ç¨‹ä¸­çš„ä»»åŠ¡æ²¡æœ‰è¿”å›å€¼
}

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<Receiver<Msg>>>) -> Self {
        let thread = spawn(move|| {
            // ä¸å¯ä½¿ç”¨ while let, å› ä¸ºwhile è¡¨è¾¾å¼ä¸­çš„å€¼è¿˜æœ‰å—éƒ½ä¸€ç›´å¤„äºä½œç”¨åŸŸä¸­, é”æ— æ³•é‡Šæ”¾
            //
            // åªèƒ½ä½¿ç”¨ loop å¾ªç¯,
            //ä½¿ç”¨ loop å¹¶åœ¨å¾ªç¯å—ä¹‹å†…è€Œä¸æ˜¯ä¹‹å¤–è·å–é”å’Œä»»åŠ¡ï¼Œ
            // lock æ–¹æ³•è¿”å›çš„ MutexGuard åœ¨ let job è¯­å¥ç»“
            // æŸä¹‹åç«‹åˆ»å°±è¢«ä¸¢å¼ƒäº†ã€‚è¿™ç¡®ä¿äº† recv è°ƒç”¨è¿‡ç¨‹ä¸­æŒæœ‰é”ï¼Œ
            // è€Œåœ¨ job() è°ƒç”¨å‰é”å°±è¢«é‡Šæ”¾äº†ï¼Œè¿™å°±å…è®¸å¹¶å‘å¤„ç†å¤šä¸ªè¯·æ±‚
            loop {
                let msg = receiver.lock().unwrap().recv().unwrap();
                match msg {
                    Msg::JobMsg(job) => {
                        println!("worker {} running", id);
                        job();
                    },
                    Msg::TerminateMsg => {
                        println!("worker {} receive terminate msg", id);
                        break;
                    },
                }

            }
        });
        Self {
            id,
            thread: Some(thread),
        }
    }
}

```


## rayon å¹¶è¡Œæ‰§è¡Œä»»åŠ¡

è½»æ¾åœ°å°†é¡ºåºè®¡ç®—è½¬æ¢ä¸ºå®‰å…¨çš„å¹¶è¡Œè®¡ç®—ï¼Œå¹¶ä¸”ä¿è¯æ— æ•°æ®ç«äº‰

åº•å±‚ä½¿ç”¨ çº¿ç¨‹æ± æ‰§è¡Œä»»åŠ¡, è‹¥å·¥ä½œçº¿ç¨‹éƒ½è¢«å ç”¨, åˆ™æ–°åŠ çš„ä»»åŠ¡ä¼šé¡ºåºæ‰§è¡Œ

```rs
// å¹¶è¡Œè¿­ä»£å™¨
// 
extern crate rayon;
use rayon::prelude::*;
fn sum_of_squares(input: &[i32]) -> i32 {
    input.par_iter()// è¿”å›ä¸€ä¸ªä¸å¯å˜çš„å¹¶è¡Œè¿­ä»£å™¨ç±»å‹, é€šè¿‡ map æ„é€ äº†æ–°çš„ é›†åˆè¿­ä»£å™¨
        .map(|&i| i * i).sum()
}
fn increment_all(input: &mut [i32]) {
   
    input.par_iter_mut() // å›ä¸€ä¸ªå¯å˜çš„å¹¶è¡Œè¿­ä»£å™¨ç±»å‹ã€‚
        .for_each(|p| *p += 1);// ç›´æ¥åœ¨åŸæœ‰åŸºç¡€ä¸Šä¿®æ”¹
}
fn main(){
   let v = [1,2,3,4,5,6,7,8,9,10];
   let r = sum_of_squares(&v);
   println!("{}", r);
   let mut v = [1,2,3,4,5,6,7,8,9,10];
   increment_all(&mut v);
   println!("{:?}", v);
}


// join()
// å¹¶ä¸ä¿è¯æ¥æ”¶çš„ä¸¤ä¸ªé—­åŒ…ä¸€å®šå¹¶è¡Œæ‰§è¡Œ, å› ä¸º è‹¥ çº¿ç¨‹æ± ä¸­æ²¡æœ‰ç©ºé—²çš„çº¿ç¨‹äº†, æ–°ä»»åŠ¡è¿˜æ˜¯åªèƒ½é¡ºåºæ‰§è¡Œ
// 
extern crate rayon;
fn fib(n: u32) -> u32 {
    if n < 2 { return n; }
    let (a, b) = rayon::join(
        // æ¥æ”¶ä¸¤ä¸ªé—­åŒ… , å¹¶è¡Œæ‰§è¡Œ
        || fib(n - 1), || fib(n - 2)
    );
    a + b
}
fn main() {
    let r = fib(32);
    assert_eq!(r, 2178309);
}
```


## CrossBeam æ— é”çš„æ•°æ®ç»“æ„

æ˜¯å¯¹ æ ‡å‡†åº“çš„æ‰©å±•å’ŒåŒ…è£…ï¼Œ

```rs
// - æ‰©å±•åŸå­ç±»å‹, ä¸ºåŸºç¡€åº“ä¸­çš„åŸå­ç±»å‹å®ç°äº† AtomicConsume trait
// - Scoped çº¿ç¨‹: å…è®¸å­çº¿ç¨‹å¯ä»¥å®‰å…¨åœ°ä½¿ç”¨çˆ¶çº¿ç¨‹ä¸­çš„å¼•ç”¨
// - ä½¿ç”¨ç¼“å­˜è¡Œå¡«å……æå‡äº•å‘æ€§èƒ½
// - MPMC Channel: å¤šç”Ÿäº§è€…å¤šæ¶ˆ è´¹è€…é€šé“
```

## Arc å’Œ Rc

```rs

/// Rc<T> åªèƒ½ç”¨äºå•çº¿ç¨‹åœºæ™¯   
// Arc<T>æ˜¯çº¿ç¨‹å®‰å…¨ç‰ˆæœ¬çš„ Rc<T>ã€‚
```

## RwLock å’Œ RefCell


```rs
// RwLock<T>ç›¸å½“äºçº¿ç¨‹å®‰å…¨ç‰ˆæœ¬çš„ RefCell<T>ï¼ŒåŒæ—¶è¿è¡Œå¤šä¸ª readeræˆ–è€…ä¸€ä¸ª writer
// RwLock è¯»å†™é”ï¼Œæ˜¯å¤šè¯»å•å†™é”ï¼Œä¹Ÿ å«å…±äº«ç‹¬å é” ã€‚ å®ƒå…è®¸å¤šä¸ªçº¿ç¨‹è¯»ï¼Œå•ä¸ªçº¿ç¨‹å†™ ã€‚ ä½†æ˜¯åœ¨å†™çš„æ—¶å€™ ï¼Œ åªèƒ½æœ‰ä¸€ä¸ªçº¿ç¨‹å æœ‰å†™é” ; è€Œåœ¨è¯»çš„æ—¶å€™ï¼Œ å…è®¸ä»»æ„çº¿ç¨‹è·å–è¯»é” ã€‚ è¯»é”å’Œå†™é”ä¸èƒ½è¢«åŒæ—¶è·å–
// æ‰€ä»¥åœ¨åº¦å¤šå†™å°‘çš„åœºæ™¯, ä½¿ç”¨ è¯»å†™é”å¯ä»¥æœ‰æ›´é«˜çš„å¹¶å‘æ”¯æŒ
```


## Mutex

```rs
// Mutex<T>æ˜¯é”ï¼ŒåŒä¸€æ—¶é—´ä»…å…è®¸æœ‰-ä¸ªçº¿ç¨‹è¿›è¡Œæ“ä½œ, ä¸ç®¡æ˜¯è¯»è¿˜æ˜¯å†™ã€‚
// æœ¬è´¨æ˜¯ä¸€ä¸ª struct

```

## AtomicPtr å’Œ Cell

```rs
// Atomic ç³»åˆ—ç±»å‹: AtomicBoolã€ Atomiclsizeã€ AtomicUsizeå’ŒAtomicPtr
// å¯ä»¥ç”¨ AtomicPtr æ¥æ¨¡æ‹Ÿå…¶ä»–æƒ³è¦çš„ç±»å‹
// AtomicPtr ç›¸å½“äºçº¿ç¨‹å®‰å…¨ç‰ˆæœ¬ çš„ Cell<T>
```


# å¼‚æ­¥å¹¶å‘


## å¼‚æ­¥æ¦‚å¿µ


### ä¸ºä»€ä¹ˆä½¿ç”¨å¼‚æ­¥ 

æƒ³è¦åŒæ—¶è¿è¡Œå¤šä¸ªä»»åŠ¡, å¯ä»¥ä½¿ç”¨å¤šçº¿ç¨‹, ä½†æ˜¯åœ¨ä¸åŒçº¿ç¨‹ä¹‹é—´çš„åˆ‡æ¢å’Œçº¿ç¨‹ä¹‹é—´çš„æ•°æ®å…±äº«è¿‡ç¨‹ä¸­ï¼Œæ¶‰åŠåˆ°å¾ˆå¤šå¼€é”€ã€‚å³ä½¿æ˜¯ä¸€ä¸ªåªæ˜¯åç€ä»€ä¹ˆéƒ½ä¸åšçš„çº¿ç¨‹ï¼Œä¹Ÿä¼šæ¶ˆè€—å®è´µçš„ç³»ç»Ÿèµ„æº

å¼‚æ­¥å¯ä»¥åœ¨ä¸åˆ›å»ºå¤šä¸ªçº¿ç¨‹çš„æƒ…å†µä¸‹åŒæ—¶è¿è¡Œå¤šä¸ªä»»åŠ¡, å…·ä½“æ¥è¯´å°±æ˜¯ä½¿ç”¨åç¨‹ coroutine


### æ™®é€šå¤šçº¿ç¨‹ webserver 


ä¾‹å­: ä»ä¸¤ä¸ª serverä¸‹è½½, ç¬¬ä¸€ä¸ªèµ„æº è€—æ—¶ 3s, ç¬¬äºŒä¸ªèµ„æºè€—æ—¶ 1s , æ€»å…±è€—æ—¶ 4s, æ”¹ä¸º å¤šçº¿ç¨‹å¯ä»¥ç¼©çŸ­ä¸º 3s, ä½†æ˜¯æœ‰çº¿ç¨‹åˆ‡æ¢çš„å¼€é”€, æœ€å¥½çš„æ˜¯ æ”¹ä¸ºå¼‚æ­¥

```rust

// client
fn start_client() -> Result<()> {
    // é¡ºåºæ‰§è¡Œ, è€—æ—¶é•¿, 4s
    // connect_to_server("localhost", 8080, "send to server0: 8080")?;
    // connect_to_server("localhost", 8081, "send to server1: 8081")?;




    // å¤šçº¿ç¨‹, è¿›ä¸€æ­¥, å¯ä»¥è€ƒè™‘ ä½¿ç”¨çº¿ç¨‹æ± 
    let mut handles = Vec::new();
    let handle_server0 = spawn(move || {
        connect_to_server("localhost", 8080, "send to server0: 8080");
    });
    handles.push(handle_server0);
    let handle_server1 = spawn(move || {
        connect_to_server("localhost", 8081, "send to server0: 8081");
    });
    handles.push(handle_server1);
    for handle in handles {
        handle.join();
    }


    Ok(())
}

fn connect_to_server(host: &str, port: u16, content: &str) -> Result<()> {
    let mut s = TcpStream::connect((host, port))?;
    s.write(content.as_bytes())?;

    let mut buf_reader = BufReader::new(&s);
    let mut buf = Vec::new();
    buf_reader.read_until(b'\n', &mut buf)?;

    println!(">>> recv from server : {}", std::str::from_utf8(&buf).unwrap());
    Ok(())
}



// server1
fn start_server1() -> Result<()> {
    let tcp_listener = TcpListener::bind("localhost:8080")?;
    for stream in tcp_listener.incoming() {
        handle_conn(&mut stream?, 3)?
    }
    Ok(())
}

//server2
fn start_server2() -> Result<()> {
    let tcp_listener = TcpListener::bind("localhost:8081")?;
    for stream in tcp_listener.incoming() {
        handle_conn(&mut stream?, 1)?
    }
    Ok(())
}

fn handle_conn(s: &mut TcpStream, wait_seconds: u64) -> Result<()> {
    let mut buf = [0; 512];
    loop {
        let len = s.read(&mut buf)?;
        if len == 0 {
            return Ok(());
        }

        sleep(Duration::from_secs(wait_seconds));
        s.write(&buf[..len])?;
        s.write("\n".as_bytes())?;
    }
}


```

### æ”¹è¿›åçš„å¼‚æ­¥ç‰ˆæœ¬


```rs
use std::{
    io::{BufRead, BufReader, Read, Result, Write},
    net::{TcpListener, TcpStream},
    str::from_utf8,
};

use futures::{executor::block_on, join};

fn main() {
    block_on(conn_all_async())
}

async fn conn_all_async() {
    let f0 = conn_server_async("localhost", 8080, "send to server0: 8080");
    let f1 = conn_server_async("localhost", 8081, "send to server0: 8081");
    join!(f0, f1);// ç­‰å¾… f0, f1 å®Œæˆ
}

async fn conn_server_async(host: &str, port: u16, content: &str) -> Result<()> {
    conn_serve(host, port, content)
}

fn conn_serve(host: &str, port: u16, content: &str) -> Result<()> {
    let mut s = TcpStream::connect((host, port))?;
    s.write(content.as_bytes())?;

    let mut buf = Vec::new();
    let mut buf_reader = BufReader::new(&s);
    buf_reader.read_until(b'\n', &mut buf)?;

    println!("recv from server: {}", from_utf8(&buf).unwrap());

    Ok(())
}

```


## åŸºæœ¬ä½¿ç”¨


### block_on


å®šä¹‰å¼‚æ­¥å‡½æ•°, ç„¶åä½¿ç”¨ block_on é˜»å¡ä¸»çº¿ç¨‹:

```rust
// futures = "0.3"

use futures::executor::block_on;

fn main() {
    let hello_future = hello();// å¼‚æ­¥æ‰§è¡Œ (ä¸ä¼šç­‰å¾…æ‰§è¡Œå®Œ), hello_future ä»£è¡¨å¼‚æ­¥å‡½æ•°çš„ handle å¥æŸ„
    println!("main finish");

    // é˜»å¡ main thread,
    // æ¥å—ä¸€ä¸ª future, è¿”å›çœŸå®ç»“æœ
    block_on(hello_future);
}

// å¼‚æ­¥å‡½æ•°
async fn hello() {
    println!("hello async");
}

```


### await


ä½¿ç”¨ .await ç­‰å¾…å¼‚æ­¥å‡½æ•°æ‰§è¡Œå®Œ, ç”¨äºå¤šä¸ªå¼‚æ­¥å‡½æ•°æœ‰ä¾èµ–å…³ç³»

```rust
// futures = "0.3"

use futures::executor::block_on;

fn main() {
    block_on(hello2());// é˜»å¡ç­‰å¾… hello2 æ‰§è¡Œå®Œ
}

async fn hello() {
    println!("hello async");
}

async fn hello1() {
    hello().await;// ç­‰å¾… hello() æ‰§è¡Œå®Œ
    println!("hello 1");
}

async fn hello2() {
    hello1().await; //ç­‰å¾… hello1 æ‰§è¡Œå®Œ
    println!("hello 2");
}



```


###  join


å¹¶è¡Œæ‰§è¡Œå¼‚æ­¥å‡½æ•°

```rust
use futures::executor::block_on;
use std::time::Duration;

fn main() {
    let main = async_main();
    block_on(main);//é˜»å¡
}

#[derive(Debug)]
struct Song;

async fn learn_song() -> Song {
    // ä¸èƒ½ä½¿ç”¨ thread::sleep
    async_std::task::sleep(Duration::from_secs(1)).await; //async-std = "1.5"
    println!("learn song");
    Song
}

async fn sing_song(song: Song) {
    async_std::task::sleep(Duration::from_secs(1)).await;
    println!("sing song: {:?}", song);
}

async fn dance() {
    println!("dance");
}

async fn learn_and_sing() {
    let song = learn_song().await;// ç­‰å¾…æ‰§è¡Œå®Œ
    sing_song(song).await;// ä¹Ÿè¦åŠ  await, å¦åˆ™ä¸»çº¿ç¨‹ä¸ä¼šç­‰å¾… sing_song() æ‰§è¡Œå®Œå°±ç»§ç»­å‰è¿›äº†
}

async fn async_main() {
    let f1 = learn_and_sing();
    let f2 = dance();

    // `join!` ç±»ä¼¼äº `.await` ï¼Œä½†æ˜¯å¯ä»¥ç­‰å¾…å¤šä¸ª future å¹¶å‘å®Œæˆ
    futures::join!(f1, f2); //  f1, f2 å¹¶è¡Œå®Œæˆ, è¿”å› (handle1, handle2)
    
    //dance
    //learn song
    //sing song: Song

}



```




## futureå¹¶å‘æ¨¡å¼

### futureåº•å±‚æ˜¯ç”Ÿæˆå™¨

è¦æ”¯æŒasync/awaitå¼‚æ­¥å¼€å‘ï¼Œ æœ€å¥½æ˜¯èƒ½æœ‰åç¨‹çš„æ”¯æŒ, 

ä¸€ç§æ˜¯æœ‰æ ˆåç¨‹(Stackful); å¦ä¸€ç§æ˜¯æ— æ ˆåç¨‹(Stackless)ã€‚å¯¹äºæœ‰æ ˆåç¨‹çš„å®ç°ï¼Œ ä¸€èˆ¬æ¯ä¸ªåç¨‹éƒ½è‡ªå¸¦ç‹¬ç«‹çš„æ ˆï¼ŒåŠŸèƒ½å¼ºå¤§ï¼Œ ä½†æ˜¯æ¯”è¾ƒè€— å†…å­˜ï¼Œ æ€§èƒ½ä¸å¦‚æ— æ ˆåç¨‹ã€‚ è€Œæ— æ ˆåç¨‹ä¸€èˆ¬æ˜¯åŸºäºçŠ¶æ€æœº(StateMachine) æ¥å®ç°çš„ï¼Œ ä¸ä½¿ ç”¨ç‹¬ç«‹ çš„æ ˆï¼Œå…·ä½“çš„åº”ç”¨å½¢å¼ å«ç”Ÿæˆå™¨( Generator), rust ä½¿ç”¨åè€…

```rs
// åŸºæœ¬ä½¿ç”¨
#![feature(generators, generator_trait)]
use std::{ops::{Generator, GeneratorState}, pin::Pin};
fn main() {
    // ç”Ÿæˆå™¨æ— æ³•æ¥å—å‚æ•°
    // å’Œé—­åŒ…ä¸€æ ·å¯ä»¥æ•è·å¤–éƒ¨ç¯å¢ƒçš„å˜é‡ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨moveå…³é”®å­—
    // ç”Ÿæˆå™¨è‡ªåŠ¨å®ç°äº†Sendå’ŒSync,ä½†ä¸ä¼šè‡ªåŠ¨å®ç°Copyæˆ–Cloneä¹‹ç±»çš„trait
    let mut gen = || {
        yield 1;// æ¯ä¸ª yield å¯¹åº”ä¸€ä¸ªä¸åŒçš„çŠ¶æ€, æ¯æ¬¡è°ƒç”¨ resume(), åˆ™è¿”å›å¯¹åº”å€¼, ç”Ÿæˆå™¨æš‚æ—¶è¢«æŒ‚èµ·, ç›´åˆ°å†æ¬¡ è°ƒç”¨ resume(), 
        yield 2;
        return 3; // è°ƒç”¨ resume è¿”å› 3, åˆ™ ç”Ÿæˆå™¨ç»“æŸ
    };
    match Pin::new(&mut gen).resume(()) {
        GeneratorState::Yielded(1) => {},
        _ => panic!("error 1"),
    }
    match Generator::resume(Pin::new(&mut gen), ()) {
        GeneratorState::Yielded(2) => {},
        _ => panic!("error 2"),
    }
    match Generator::resume(Pin::new(&mut gen), ()) {
        // error
        // GeneratorState::Yielded(3) => {},

        GeneratorState::Complete(3) => {},
        _ => panic!("error 3"),
    }
    // error
    // let state = Generator::resume(Pin::new(&mut gen), ());
    // println!("{:?}", state);
}




// ä½œä¸ºå‡½æ•°è¿”å›å€¼
// 
// 
#![feature(generators, generator_trait)]
use std::ops::Generator;
pub fn up_to(limit: u64) -> impl Generator<Yield = u64, Return = u64> {
    move || {
    for x in 0..limit {
         yield x;
    }
    return limit;
    }
}
fn main(){
    let a = 10;
    let mut b = up_to(a);
    unsafe {
      for _ in 0..=10{
         let c = b.resume();   
         println!("{:?}", c);
      }
    }
}




//  å’Œè¿­ä»£å™¨ çš„å…³ç³»
// 
// 
// Generator<Yield=T, Return=()> - å¦‚æœåªå…³æ³¨è®¡ç®— çš„è¿‡ç¨‹ï¼Œè€Œä¸å…³ å¿ƒè®¡ ç®—çš„ç»“æœï¼Œ åˆ™å¯ä»¥ å°† Return è®¾ç½®ä¸ºå•å…ƒç±»å‹ï¼Œåªä¿ç•™ Yield çš„ç±»å‹ï¼Œ é‚£ ä¹ˆç”Ÿæˆå™¨å°±å¯ä»¥åŒ–èº«ä¸ºæ³•ä»£å™¨
// 
// ç”Ÿæˆå™¨çš„æ€§èƒ½æ¯”è¿­ä»£å™¨æ›´é«˜ã€‚å› ä¸ºç”Ÿæˆå™¨æ˜¯ä¸€ç§å»¶è¿Ÿè®¡ç®—æˆ–æƒ°æ€§è®¡ç®—ï¼Œ å®ƒé¿å…äº†ä¸å¿… è¦çš„è®¡ç®—ï¼Œåªæœ‰åœ¨æ¯æ¬¡éœ€è¦æ—¶æ‰é€šè¿‡ yieldæ¥äº§ç”Ÿç›¸å…³çš„å€¼
// 
#![feature(generators, generator_trait)]

use std::{ops::{Generator, GeneratorState}, pin::Pin};

fn main() {
    let mut gen = gen();
    let mut state = Pin::new(&mut gen);
    for _ in 0..3 {
        match state.as_mut().resume(()) {
            GeneratorState::Yielded(i) => println!("{:?}", i),
            _ => println!("complete"),
        }
    }
}

fn gen() -> impl Generator<Yield = u64, Return = ()> {
    || {
        let mut i = 0;
        loop {
            i += 1;
            yield i;
        }
    }
}





// å’Œ futureå…³ç³»
// 
// Generator<Yield = (), Return = Result<T, E>> - ä¸å…³ å¿ƒè¿‡ ç¨‹ ï¼Œ åªå…³æ³¨ç»“æœ, ç”Ÿæˆå™¨å°±å¯ä»¥åŒ–èº«ä¸º Future
pub fn up_to(limit: u64) -> impl Generator<Yield = (), Return = Result<u64, ()>> {
    move || {
        for x in 0..limit {
            yield ();
        }
        return Ok(limit);
    }
}
fn main(){
    let limit = 2;
    let mut gen = up_to(limit);
    unsafe {
      for i in 0..=limit{
         match gen.resume() {
             GeneratorState::Yielded(v) => println!("resume {:?} : Pending", i),// è¡¨ç¤ºè¿˜æ²¡å¤„ç†å®Œ
             GeneratorState::Complete(v) => println!("resume {:?} : Ready", i), // å¤„ç†å®Œæˆ, æ‹¿åˆ°ç»“æœ
         }
      }
    }
}

```



###  futureåŸºæœ¬ä½¿ç”¨


ç¬¬ä¸‰æ–¹åº“ futures-rs æä¾›


```rs
// åŸºæœ¬ç»„ä»¶
// 
// - Future  çœŸå®ç»“æœçš„åŒ…è£…
//      æ ¸å¿ƒå‡½æ•° poll(), è¿”å› è®¡ç®—ç»“æœæ˜¯å¦å‡†å¤‡å¥½
// - Executor è°ƒåº¦å™¨
// - Task å…·ä½“çš„å¼‚æ­¥ä»»åŠ¡



// å®ç°ä¸€ä¸ª Future traitçš„æ–¹å¼
// 
// æ–¹å¼1ï¼šä½¿ç”¨ async fnï¼Œasync fu ä¼šè‡ªåŠ¨ä¸ºå¼€å‘è€…ç”Ÿæˆè¿”å›å€¼æ˜¯ impl Future ç±» å‹çš„å‡½æ•°
// æ–¹å¼2ï¼šè‡ªå®šä¹‰ ç»“æ„ä½“ï¼Œå¹¶å®ç° Future trait


// async/await åŸç†: 
// async å…³é”®å­—å®šä¹‰å¼‚æ­¥å‡½æ•°/å¼‚æ­¥å—ï¼Œåº•å±‚éƒ½ä¼šå…ˆè½¬ä¸º async å—çš„å½¢å¼, å†å°† async å—ç”Ÿæˆä¸€ä¸ª Generator<Yield=()>ç±»å‹çš„ç”Ÿæˆå™¨æ¥ä½¿ç”¨

```

### åŠ¨æ‰‹å®ç° Future ç±»å‹



https://www.rectcircle.cn/posts/rust%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/

### åŠ¨æ‰‹å®ç° å¼‚æ­¥ sleep


é€šè¿‡è‡ªå®šä¹‰ç±»å‹çš„æ–¹å¼å®ç°ä¸€ä¸ªå¼‚æ­¥çš„sleep, ç±»ä¼¼äºasync_std::task:sleep

```rust
use futures::executor::block_on;
use std::time::Duration;
use async_std::sync::Arc;
use std::sync::Mutex;
use futures::task::{Waker, Context, Poll};
use futures::Future;
use std::pin::Pin;
use std::thread::{spawn, sleep};

fn main() {
    block_on(async { // å¼‚æ­¥ä»£ç å—
        println!("start");
        TimerFuture::new(Duration::from_secs(2)).await;
        println!("end");
    });
}

struct TimerFuture {
    shared_state: Arc<Mutex<SharedState>>,
}

struct SharedState {
    completed: bool,
    waker: Option<Waker>,
}

impl Future for TimerFuture {
    type Output = ();

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        let mut shared_state = self.shared_state.lock().unwrap();
        if shared_state.completed {
            Poll::Ready(())
        } else {
            shared_state.waker = Some(cx.waker().clone());
            Poll::Pending
        }
    }
}

impl TimerFuture {
    fn new(du: Duration) -> Self {
        let shared_state = Arc::new(Mutex::new(SharedState {
            completed: false,
            waker: None,
        }));

        let thread_shared_state = shared_state.clone();
        spawn(move || {
            sleep(du);
            let mut state = thread_shared_state.lock().unwrap();
            state.completed = true;
            if let Some(waker) = state.waker.take() {
                waker.wake();
            }
        });

        TimerFuture {
            shared_state,
        }
    }
}



```



## async-std

ç›¸è¾ƒäº tokio, å¹´è½», æ²¡æœ‰å†å²åŒ…è¢±, å…¼å®¹æ ‡å‡†åº“, æ›´åŠ å°å·§


## tokio



# ç®€å•æ–‡ä»¶ç³»ç»Ÿ
https://zhuanlan.zhihu.com/p/115464045

# ç½‘ç»œç¼–ç¨‹

## tcp


```rs
use std::net::TcpListener;
use std::io::Read;

// server
fn main() -> std::io::Result<()> {
    let listener = TcpListener::bind("127.0.0.1:1080")?;
    for stream in listener.incoming() {
        match stream {
            Ok(mut stream) => {
                let mut buf = [0u8; 512];
                let len = stream.read(&mut buf)?;
                println!("{}", String::from_utf8_lossy(&buf));
            },
            Err(_) => eprintln!("Error of accept request."),
        }
    }

    Ok(())
}


// client

fn main() -> std::io::Result<()> {
    let mut stream = TcpStream::connect("127.0.0.1:1080")?;
    for index in 0..3 {
        let msg = format!("tcp msg {}", index);
        stream.write_all(msg.as_bytes());
        debug!("send: {}", msg);
        let mut buf = [0u8; 512];
        stream.read(&mut buf);
    }

    Ok(())
}
```

## udp


```rs
// server
use std::net::UdpSocket;

fn main() -> std::io::Result<()> {
    let socket = UdpSocket::bind("127.0.0.1:1080")?;

    loop {
        let mut buf = [0u8; 512];

        // receive from client
        // len: data length
        // src_addr: source address
        let (len, src_addr) = socket.recv_from(&mut buf)?;

        println!("recv: {}", String::from_utf8_lossy(&buf));

        let resp_buf = &mut buf[..len];
        resp_buf.reverse();
        socket.send_to(resp_buf, src_addr)?;// send data to client
        println!("send: {}", String::from_utf8_lossy(resp_buf));
    }

    Ok(())
}

// client

fn main() -> std::io::Result<()> {
    let socket = UdpSocket::bind("127.0.0.1:34254")?;
    socket.connect("127.0.0.1:8080");

    for index in 0..3 {
        let msg = format!("udp msg {}", index);
        socket.send(msg.as_bytes());
        println!("send: {}", msg);

        let mut buf = [0u8; 512];
        socket.recv(&mut buf);
        println!("recv: {}", String::from_utf8_lossy(&buf));
    }

    Ok(())
}
```


# æ¶ˆæ¯ä¸­é—´ä»¶

https://github.com/nkbai/learnrustbynats

TODO

# æ¸¸æˆå¼€å‘

https://www.yuque.com/quaint/rust/ldnc5g
TODO

# çˆ¬è™«

Hyper ï¼šä¸€ä¸ªå¿«é€Ÿå’Œæ­£ç¡®çš„ Rust HTTPå®ç°ã€‚ https://github.com/hyperium/hyper
reqwest : rust http clientå®ç° https://github.com/seanmonstar/reqwest
html5everï¼šRust htmlè§£æåº“ https://github.com/servo/html5ever
select :åŸºäºhtml5ever çš„htmlè§£æåº“ï¼Œç±»ä¼¼äºpythonçš„ beautifulsoap https://github.com/utkarshkukreti/select.rs
crates.io https://crates.io/crates/select
é™„ï¼šhttpsï¼š//github.com/carllerche/curl-rust

# rpc æ¡†æ¶

https://zhuanlan.zhihu.com/p/36528189

# ç¼–å†™ä»£ç†

https://github.com/gwuhaolin/blog/issues/12
https://github.com/importcjj/rust-miniproxy
https://github.com/wangyuntao/socks5-rs
https://github.com/importcjj/gkd-rs


https://zhuanlan.zhihu.com/p/28645724
https://www.jianshu.com/p/d1048d0b687f
https://doc.rust-lang.org/std/net/
https://zhuanlan.zhihu.com/p/97200083
https://www.mojidong.com/post/2015-03-07-socket5-1/
https://www.zhihu.com/search?type=content&q=rust%20socket

TODO

https://lowlvl.org/ ä½¿ç”¨ rust å­¦ä¹  tcp

https://github.com/shadowsocks/shadowsocks-rust
https://github.com/trojan-gfw/trojan
https://github.com/p4gefau1t/trojan-r
https://github.com/importcjj/rust-miniproxy

## http ä»£ç†

http ä»£ç†: åŸºäº HTTP åè®®. å±äºåº”ç”¨å±‚åè®®ï¼Œä¸€èˆ¬åªä¼šä»£ç†è½¬å‘ HTTP è¯·æ±‚ï¼Œå½“ç„¶ä¹Ÿå¯ä»¥ä½¿ç”¨ CONNECT æ–¹æ³•æ¥å®ç°ä¸€èˆ¬ TCP çš„ä»£ç†è½¬å‘
https://github.com/linmx0130/rust-http-proxy

## socket ä»£ç†

Socketæ˜¯ä¸€å¥—æ ‡å‡†ï¼Œå®ƒå®Œæˆäº†å¯¹TCP/IPçš„é«˜åº¦å°è£…; Socket = IPåœ°å€ + ç«¯å£ + åè®®ã€‚

socket5ä»£ç†: socket5 æ˜¯ä¸€ä¸ªtcpã€udpçš„ä»£ç†åè®®(socket4ä¸æ”¯æŒudp), ä¼ è¾“å±‚ä»£ç†åè®®, å®ƒç›´æ¥é€šè¿‡åè®®æ¡æ‰‹æ¥è¿›è¡Œè¿æ¥ï¼Œå¹¶ç›´æ¥ä¿®æ”¹æŠ¥å¤´æ¥å®ç°è½¬å‘ï¼Œæ‰€ä»¥é€Ÿåº¦éå¸¸å¿«,å¤§éƒ¨åˆ†è½¯ä»¶éƒ½æ”¯æŒsocket5ä»£ç†ã€‚

https://github.com/importcjj
https://github.com/zhboner/realm æµé‡è½¬å‘
https://cloud.tencent.com/developer/article/1484318
https://github.com/gwuhaolin/blog/issues/12

# webassembly

https://rustwasm.github.io/


# å’Œ Python äº¤äº’

https://github.com/PyO3/pyo3
https://saidvandeklundert.net/learn/2021-11-18-calling-rust-from-python-using-pyo3/
https://zhuanlan.zhihu.com/p/148144823

https://github.com/PyO3/pyo3

# å’Œ js JavaScript nodejs äº¤äº’

https://github.com/napi-rs/napi-rs

# å’Œ java äº¤äº’

https://github.com/jni-rs/jni-rs
https://github.com/astonbitecode/j4rs

## rust è°ƒç”¨ java

j4rsï¼Œä¸€ä¸ªåœ¨ Rust ä¸­è°ƒç”¨ Java ä»£ç çš„ Crate

https://github.com/benanders/rjni

https://github.com/jni-rs/jni-rs Rust bindings to the JNI 

## java è°ƒç”¨ rust

https://github.com/drrb/java-rust-example

https://github.com/jnr/jnr-ffi

https://github.com/drrb/java-rust-example
https://stackoverflow.com/questions/30258427/calling-rust-from-java

https://blog.csdn.net/abcamus/article/details/81017325

https://rustcc.cn/article?id=98b96e69-7a5f-4bba-a38e-35bdd7a0a7dd å„ç§åº“åŒºåˆ«

https://rustcc.cn/article?id=f371a5f1-08fa-4ab8-99a4-21d307223f82 rust å¯¼å‡ºå…±äº«åº“

# å¼€å‘å¾®ä¿¡å°ç¨‹åº-web æ¸¸æˆ

https://github.com/planet0104


# ç¬¬ä¸‰æ–¹ crates

https://crates.io/
https://s0docs0rs.icopy.site/

https://rust-lang-nursery.github.io/rust-cookbook/

## æ¡Œé¢å¼€å‘

https://github.com/tauri-apps/tauri

## è§†é¢‘å¤„ç†

https://github.com/larksuite/rsmpeg é£ä¹¦å›¢é˜Ÿå‡ºå“ ffmpeg çš„ rust binding

## å›¾ç‰‡å¤„ç†

https://github.com/Aloxaf/silicon


## æ¸¸æˆå¼€å‘ä¸‰æ–¹åº“

https://github.com/rust-gamedev/arewegameyet


##  web å¼€å‘

### webæ¡†æ¶

https://www.arewewebyet.org/

rocket https://rocket.rs/

https://github.com/actix/actix-web

https://github.com/iron/iron

tiny_http

https://github.com/yewstack/yew ä½¿ç”¨ jsx è¯­æ³•å†™ wasm

å¯¹æ¯”é€‰å‹ http://jiagoushi.pro/book/export/html/334

https://users.rust-lang.org/t/video-series-build-a-smart-bookmarking-tool-with-rust-and-rocket/47601 rocket å®ä¾‹

### orm

Diesel ORM


### http client

http - HTTPæ ‡å‡†ç›¸å…³çš„åŸºç¡€ç±»å‹ï¼Œå¦‚Request<T> ã€Response<T>ä»¥åŠStatusCodeå’Œå¸¸ç”¨çš„Header

hyper -  HTTPåº•å±‚åº“ï¼Œå®ƒå°è£…äº†HTTPçš„æŠ¥æ–‡è§£æã€æŠ¥æ–‡ç¼–ç å¤„ç†ã€è¿æ¥æ§åˆ¶


## åºåˆ—åŒ–ååºåˆ—åŒ–

serde åº“

### toml

```rs
use std::env::args;

fn main() {
    let config = {
        let config_path = args().nth(1).unwrap();
        let content = std::fs::read_to_string(config_path).unwrap();
        content.parse::<toml::Value>().unwrap()
    };
    println!("{:#?}", config);
    // let tbl = config.as_table().unwrap();
    let input = config.get("input").unwrap();
    println!("{:#?}", input);
    let json_file = input.get("json_file").unwrap().as_str().unwrap();
    println!("{:#?}", json_file);
}


```

### json

serde_json æ˜¯åŸºäº serde å®ç°çš„


## æ—¥å¿—ç³»ç»Ÿ

æ—¥å¿— https://segmentfault.com/a/1190000021681959

log æä¾› api, å¦‚æœåªæ˜¯å¼€å‘ä¸€ä¸ª lib , æ— éœ€å¯¼å…¥å®ç°, å¦‚æœæ˜¯åœ¨ä¸€ä¸ªå¯æ‰§è¡Œç¨‹åºé‡Œ, å¿…é¡»æœ‰å®ç°æ‰èƒ½æ‰“å°

å…·ä½“å®ç°æœ‰å¤šç§


### env_logger

`RUST_LOG=info ./bin_file`

```rs
#[macro_use]
extern crate log;

fn main() {
    env_logger::init();

    debug!("debug");
    info!("info");
    warn!("warn");
    trace!("trace");
    error!("error"); // default
}


```



### log4rs and log

```t
[dependencies]
log = "0.4.11"
log4rs = "0.13.0"
```

log4rs.yml

```yml
refresh_rate: 30 seconds
appenders:
  stdout:
    kind: console
  requests:
    kind: file
    path: "log/requests.log" # ç›¸å¯¹äºé¡¹ç›®æ ¹ç›®å½•
    encoder:
      pattern: "{d} - {m}{n}"
root:
  level: debug
  appenders:
    - stdout
    - requests

#loggers:
#  app::backend::db:
#    level: info
#  app::requests:
#    level: info
#    appenders:
#      - requests
#    additive: false

```

```rs

fn main() {
    let log_file = "config/log4rs.yml"; // ç›¸å¯¹äº é¡¹ç›®æ ¹ç›®å½•
    log4rs::init_file(log_file, Default::default()).unwrap();
    debug!(">>> load log config file: {}", log_file);

    let listener = TcpListener::bind("127.0.0.1:8090").unwrap();
    info!("visit ==> http://127.0.0.1:8090");
}

```




## æ–‡æœ¬è§£æå™¨

https://github.com/Geal/nom
https://zhuanlan.zhihu.com/p/115017849

## lazy static å»¶è¿Ÿåˆå§‹åŒ–

å¯ä»¥æŠŠå®šä¹‰å…¨å±€é™æ€å˜é‡å»¶è¿Ÿåˆ°è¿è¡Œæ—¶ï¼Œè€Œéç¼–è¯‘æ—¶

åœ¨è¿è¡Œæ—¶åˆå§‹åŒ–é™æ€å˜é‡, å³é™æ€å˜é‡å»¶è¿Ÿåˆå§‹åŒ–

ä¾‹å¦‚, æŸäº›é™æ€å˜é‡ç”±å‘½ä»¤è¡Œå‚æ•°å†³å®š, å¾—ç­‰åˆ°è¿è¡Œæ—¶æ‰èƒ½ç¡®å®šé™æ€å˜é‡

```rs
use std::collections::HashMap;

use lazy_static::lazy_static;
// or
// #[macro_use]
// extern crate lazy_static;

lazy_static! {
    static ref HASH_MAP: HashMap<u32, &'static str> = {
        let mut m = HashMap::new();
        m.insert(1, "hello");
        m.insert(2, "world");
        println!("hash map init");
        m
    };
}

fn main() {
    println!("{}", HASH_MAP.get(&1).unwrap());
    print!("{}", HASH_MAP.get(&2).unwrap());
}


```



## ç”µå­ä¹¦

mdBook ç”Ÿæˆç”µå­ä¹¦

## å‘½ä»¤è¡Œç¨‹åº

indicatif è¿›åº¦æ¡

clap å‘½ä»¤è¡Œå‚æ•°è§£æ


å€ŸåŠ©ç¬¬ä¸‰æ–¹è§£æåº“:

https://rust-cli.github.io/book/tutorial/cli-args.html
http://llever.com/cli-wg-zh/tutorial/cli-args.zh.html


https://github.com/rust-cli


ansi_term å½©è‰²è¾“å‡º

https://github.com/fdehau/tui-rs

https://github.com/cjbassi/ytop å‘½ä»¤è¡Œç³»ç»Ÿç›‘æ§ç¨‹åº


### structopt

æ•´åˆ clap, å°†å‚æ•°ç›´æ¥è§£æä¸º struct, æ›´åŠ æ–¹ä¾¿ 

```rs
use std::path::PathBuf;
use structopt::StructOpt;

#[derive(StructOpt, Debug)]
#[structopt(name = "basic")]
struct Opt {
    // ä¸æŒ‡å®š short long, ä¼šä½¿ç”¨ field name
    #[structopt(short = "v", long)]
    verbose: bool,

    #[structopt(short = "r", long = "result", parse(from_os_str))]
    result: PathBuf,

    #[structopt(parse(from_os_str))]
    files: Vec<PathBuf>,


}


fn main() {
    // result this cmd: cargo run input.txt input2.txt -v --result res.xy
    let opt = Opt::from_args();
    println!("{:#?}", opt);
}

```

### clap 

åŠŸèƒ½å¼ºå¤§, ä½¿ç”¨ä¸å¤Ÿç®€å•


## å¼‚æ­¥ç¼–ç¨‹

tokio

## websocket

https://github.com/websockets-rs/rust-websocket

wsl ä¸­å¯èƒ½ build å¤±è´¥, å¦‚ä¸‹è§£å†³:

```sh
apt install -y openssl
apt install -y libssl-dev
apt install -y pkg-config

```

## ç¼©å°ä½“ç§¯

cargo-bloat

## http client

chttp

## å®¹é”™è¿è¡Œæ—¶

bastion

## åˆ†å‘å·¥å…·

Cargo-release

## é”™è¯¯å¤„ç†

https://github.com/rust-cli/human-panic

## å¹¶å‘ç¼–ç¨‹

https://github.com/crossbeam-rs/crossbeam

Rayon å¹¶è¡Œæµ

## gui å›¾å½¢åº“

https://github.com/PistonDevelopers/conrod 2d


## åº•å±‚ç½‘ç»œ api

libpnet, å¦‚ `pnet = "0.25.0"`


## æ­£åˆ™

- regex å®˜æ–¹å®ç°, ä¸æ”¯æŒç¯è§† ( look-around ) å’Œ åå‘å¼•ç”¨ ( backreference)
- fancy-regex , æ”¯æŒ æ”¯æŒç¯è§† ( look-around ) å’Œ åå‘å¼•ç”¨ ( backreference)

## éšæœº

### rand éšæœºæ•°å­— 


```rs

use rand::prelude::*;

fn main() {
    let mut rng = rand::thread_rng();

    let i = rng.gen_range(0..3); // 0/1/2
    println!("{}", i);

    // error
    // let s: &str = rng.gen();

    let boo = rng.gen::<bool>();
    println!("bool true from gen() : {}", boo);
    let rate = rng.gen_ratio(1, 2);
    if rng.gen_bool(1.0 / 2.0) {
        println!("percent of true");
    }
    if rng.gen() {
        println!("bool from gen() without turbofish");
    }
    if rand::random() {
        println!("rand bool from random()");
    }
}

```

## æœç´¢å¼•æ“

https://github.com/valeriansaliou/sonic
https://github.com/tantivy-search/tantivy
https://artem.krylysov.com/blog/2020/07/28/lets-build-a-full-text-search-engine/ å®ç°åŸç†

## æ¸¸æˆå¼•æ“

bevy

## å¼€æºé›†åˆå®¹å™¨

https://github.com/jonhoo/flurry  A port of Java's ConcurrentHashMap to Rust

# å¼€æºé¡¹ç›®

https://zhuanlan.zhihu.com/p/62325234
https://zhuanlan.zhihu.com/p/139180791
https://www.zhihu.com/question/30511494


# å‚è€ƒé“¾æ¥


https://github.com/wisespace-io/binance-rs

https://www.youtube.com/watch?v=qyRIkcdRfRg&t=974s ä¼ä¸šçº§å¼€å‘æœ€ä½³å®è·µ
https://www.youtube.com/watch?v=36_TiWriqQ4 rust and webasembly

https://course.rs/about-book.html

https://github.com/sunface/rust-course

https://books.budshome.com/

https://github.com/sunface/rust-course

https://github.com/0voice/Understanding_in_Rust

https://github.com/KernelErr/awesome-rust-zh
https://github.com/studyrs/fancy-rust
https://github.com/TaKO8Ki/awesome-alternatives-in-rust


https://github.com/pingcap/talent-plan è¯¾ç¨‹

https://github.com/meilisearch/MeiliSearch æœç´¢å¼•æ“, ç±»ä¼¼ algolia, ä¸è¿‡æ˜¯å¼€æºçš„


https://docs.rs/  cates api æ–‡æ¡£
https://crates.io/ crates æœç´¢


https://github.com/pretzelhammer/rust-blog

https://github.com/rust-embedded/rust-raspberrypi-OS-tutorials åœ¨æ ‘è“æ´¾ä¸Šå®ç°æ“ä½œç³»ç»Ÿ

https://github.com/mre/idiomatic-rust æœ€ä½³å®è·µ
https://github.com/ctjhoa/rust-learning

https://github.com/sassman/t-rec-rs ç»ˆç«¯è®°å½•å·¥å…· å½•åˆ¶ gif

https://github.com/wtklbm/crm ç®€å•é¡¹ç›® é•œåƒæºåˆ‡æ¢

https://github.com/rust-embedded/rust-raspberrypi-OS-tutorials åµŒå…¥å¼ os å†…æ ¸ å¼€å‘

https://folyd.com/blog/ Rustçš„Pinä¸Unpin

https://github.com/ajmwagar rust å°é¡¹ç›®
https://github.com/kilerd
https://github.com/ramsayleung



https://github.com/warycat/rustgym ç®—æ³•
https://github.com/aylei/leetcode-rust ç®—æ³•å®ç°
https://github.com/sunface/rust-algos
https://github.com/dxx/datastructure-algorithm
https://github.com/aylei/leetcode-rust/blob/master/src/solution/s0001_two_sum.rs

https://github.com/rust-unofficial/awesome-rust
https://github.com/rust-lang-nursery/rust-cookbook

https://play.integer32.com/
https://play.rust-lang.org/

https://rust-unofficial.github.io/patterns/ è®¾è®¡æ¨¡å¼

https://www.rust-lang.org/ å®˜æ–¹ç«™

https://www.zhihu.com/question/31038569 å¦‚ä½•å­¦

https://users.rust-lang.org/ ç¤¾åŒº
https://rustcc.cn/ ä¸­æ–‡ç¤¾åŒº

https://doc.rust-lang.org/std/ std api


https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html the book æ‰‹å†Œ
https://kaisery.github.io/trpl-zh-cn/title-page.html the book ç¿»è¯‘
https://course.rs/into-rust.html
https://rust-by-example.budshome.com/

https://github.com/rust-lang/nomicon æ­»çµä¹¦ è®¾è®¡åŸç†

https://doc.rust-lang.org/stable/reference/introduction.html


https://doc.rust-lang.org/stable/rust-by-example/macros/dsl.html example
https://books.budshome.com/rust-by-example/testing/unit_testing.html ä¸­æ–‡

https://rust-unofficial.github.io/too-many-lists/ another tutorial

https://cheats.rs/#data-structures é€ŸæŸ¥è¡¨

https://doc.rust-lang.org/cargo/index.html cargo book
https://cargo.budshome.com/index.html

https://github.com/chinanf-boy?tab=stars - çˆ±å¥½è€…
https://github.com/AurevoirXavier - çˆ±å¥½è€…
https://github.com/BurntSushi - master
https://github.com/mre master
https://github.com/rust-lang å®˜æ–¹GitHub

http://intorust.com/ åŠ¨ç”»ä»‹ç»

https://zhuanlan.zhihu.com/c_208092758/ çŸ¥ä¹ä¸“æ 
https://zhuanlan.zhihu.com/c_118514498

https://github.com/phil-opp/blog_os rust å®ç°os

https://github.com/Kilerd/resource - ä¸­æ–‡èµ„æ–™æ”¶é›†
https://zhuanlan.zhihu.com/rust-lang
https://wiki.jikexueyuan.com/project/rust-primer/concurrency-parallel-thread/thread.html


https://www.zhihu.com/question/382172347/answer/1103525234 tips
https://www.zhihu.com/question/393796866/answer/1213171124

https://www.zhihu.com/question/30407715/answer/48032883

https://www.zhihu.com/question/34665842?sort=created ç»ƒæ‰‹
https://www.zhihu.com/question/352420716/answer/973279231

https://www.zhihu.com/question/30511494/answer/649921526 å€¼å¾—å…³æ³¨

https://github.com/rajasekarv/vega spark æ›¿ä»£
